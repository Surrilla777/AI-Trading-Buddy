<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Zenith</title>

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#3b82f6">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TradeBuddy">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üß†</text></svg>">

    <!-- Mobile optimization -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Firebase SDK for Push Notifications -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js"></script>
    <script src="/firebase-config.js"></script>
    <!-- TradingView Lightweight Charts for Trade Replay -->
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .gradient-bg { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%); }
        .card-gradient { background: linear-gradient(145deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.02) 100%); }
        .urgent-pulse { animation: pulse 2s infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(20px) translateX(-50%); }
            15% { opacity: 1; transform: translateY(0) translateX(-50%); }
            85% { opacity: 1; transform: translateY(0) translateX(-50%); }
            100% { opacity: 0; transform: translateY(-20px) translateX(-50%); }
        }
        .talk-me-down-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
        }
        .talk-me-down-btn:hover {
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.6);
            transform: translateY(-2px);
        }
    
        /* Rocket blink animation */
        @keyframes rocketPulse {
            0%, 100% { opacity: 1; filter: drop-shadow(0 0 4px rgba(255,255,255,0.8)); }
            50% { opacity: 0.7; filter: drop-shadow(0 0 8px rgba(255,255,0,1)); }
        }
        .rocket-blink {
            animation: rocketPulse 1.5s ease-in-out infinite;
        }
</style>
</head>
<body class="gradient-bg min-h-screen text-white">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // All subreddits to scan (penny stocks to mega caps)
        const SUBREDDITS = [
            { name: 'wallstreetbets', label: 'WSB', category: 'meme' },
            { name: 'stocks', label: 'Stocks', category: 'general' },
            { name: 'investing', label: 'Investing', category: 'general' },
            { name: 'options', label: 'Options', category: 'general' },
            { name: 'pennystocks', label: 'Pennies', category: 'penny' },
            { name: 'smallstreetbets', label: 'SmallBets', category: 'penny' },
            { name: 'Superstonk', label: 'Superstonk', category: 'meme' },
            { name: 'shortsqueeze', label: 'Squeeze', category: 'meme' },
            { name: 'stockmarket', label: 'Market', category: 'general' }
        ];

        // Chart patterns we support (IDs match Finviz filter values)
        const CHART_PATTERNS = [
            // Wedges
            { id: 'wedgedown', name: 'Falling Wedge', emoji: 'üü¢', type: 'bullish', desc: 'Bullish reversal - converging down, breakout up', category: 'wedge' },
            { id: 'wedgeup', name: 'Rising Wedge', emoji: 'üî¥', type: 'bearish', desc: 'Bearish reversal - converging up, breakdown likely', category: 'wedge' },

            // Channels
            { id: 'channelup', name: 'Channel Up', emoji: 'üü¢', type: 'bullish', desc: 'Uptrend between parallel lines', category: 'channel' },
            { id: 'channeldown', name: 'Channel Down', emoji: 'üî¥', type: 'bearish', desc: 'Downtrend between parallel lines', category: 'channel' },

            // Double/Triple Tops & Bottoms (combined)
            { id: 'doubletop,multipletop', name: 'Double/Triple Top', emoji: 'üî¥', type: 'bearish', desc: 'Multiple peaks at resistance - reversal signal', category: 'reversal' },
            { id: 'doublebottom,multiplebottom', name: 'Double/Triple Bottom', emoji: 'üü¢', type: 'bullish', desc: 'Multiple troughs at support - reversal signal', category: 'reversal' },

            // Head & Shoulders
            { id: 'headandshoulders', name: 'Head & Shoulders', emoji: 'üî¥', type: 'bearish', desc: 'Classic top reversal pattern', category: 'reversal' },
            { id: 'headandshouldersinv', name: 'Inverse H&S', emoji: 'üü¢', type: 'bullish', desc: 'Classic bottom reversal pattern', category: 'reversal' },

            // Triangles
            { id: 'tlresistance', name: 'Ascending Triangle', emoji: 'üü¢', type: 'bullish', desc: 'Flat top, rising bottom - breakout up', category: 'triangle' },
            { id: 'tlsupport', name: 'Descending Triangle', emoji: 'üî¥', type: 'bearish', desc: 'Flat bottom, falling top - breakdown', category: 'triangle' },

            // Flags & Pennants (using Finviz wedge variations)
            { id: 'wedgesupport', name: 'Bull Flag', emoji: 'üü¢', type: 'bullish', desc: 'Uptrend pause, continuation up likely', category: 'flag' },
            { id: 'wedgeresistance', name: 'Bear Flag', emoji: 'üî¥', type: 'bearish', desc: 'Downtrend pause, continuation down likely', category: 'flag' },

            // Neutral patterns at bottom
            { id: 'tltriangle', name: 'Symmetrical Triangle', emoji: 'üü°', type: 'neutral', desc: 'Converging trendlines - breakout either way', category: 'triangle' },
        ];

        // Request counter to track latest request and prevent stale data
        let patternRequestId = 0;

        // Fetch stocks matching a chart pattern from Finviz
        // Filters: Market cap > $300M, Avg volume > 200K, Price > $5
        const fetchPatternStocks = async (patternId, signal = null) => {
            const thisRequestId = ++patternRequestId;
            const pattern = CHART_PATTERNS.find(p => p.id === patternId);

            // Handle comma-separated pattern IDs (e.g., "doubletop,multipletop")
            const patternIds = patternId.split(',');
            const isMultiPattern = patternIds.length > 1;

            console.log(`üîç Pattern: ${patternId} (Request #${thisRequestId})${isMultiPattern ? ' [MULTI]' : ''}`);

            try {
                // For multi-patterns, fetch all and merge results
                if (isMultiPattern) {
                    const allStocks = [];
                    const seen = new Set();

                    for (const pid of patternIds) {
                        const patternFilter = `ta_pattern_${pid}`;
                        console.log(`üîó Fetching: ${patternFilter}`);
                        const response = await fetch('/api/finviz?pattern=' + patternFilter);

                        if (thisRequestId !== patternRequestId) {
                            console.log(`‚è≠Ô∏è Request #${thisRequestId} superseded, discarding`);
                            return null;
                        }

                        const html = await response.text();
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const links = doc.querySelectorAll('a[href*="quote.ashx?t="]');

                        links.forEach(link => {
                            const ticker = link.textContent.trim();
                            if (ticker && /^[A-Z]{1,5}$/.test(ticker) && !seen.has(ticker) && allStocks.length < 25) {
                                seen.add(ticker);
                                const row = link.closest('tr');
                                let price = '', change = '', marketCap = '';
                                if (row) {
                                    row.querySelectorAll('td').forEach(cell => {
                                        const t = cell.textContent.trim();
                                        if (!marketCap && /^\d+\.?\d*[BMK]$/.test(t)) marketCap = t;
                                        if (!price && /^\d+\.\d{2}$/.test(t)) price = '$' + t;
                                        if (!change && /^-?\d+\.?\d*%$/.test(t)) change = t;
                                    });
                                }
                                allStocks.push({ ticker, company: '', sector: '', marketCap, price, change, changeNum: parseFloat((change || '').replace('%', '')) || 0 });
                            }
                        });
                    }

                    console.log(`‚úÖ Request #${thisRequestId}: Merged ${allStocks.length} stocks from ${patternIds.length} patterns`);
                    if (allStocks.length > 0) return allStocks;
                    return [{ ticker: 'ERROR', company: 'No stocks found for this pattern.', error: true }];
                }

                // Single pattern - original logic
                let patternFilter = pattern?.filterType === 'ta_candlestick'
                    ? `ta_${patternId}`
                    : `ta_pattern_${patternId}`;
                console.log(`üîó Filter: ${patternFilter}`);

                const finvizUrl = `https://finviz.com/screener.ashx?v=111&f=${patternFilter},cap_smallover,sh_avgvol_o200,sh_price_o5&o=-marketcap`;
                const response = await fetch('/api/finviz?pattern=' + patternFilter);

                // Check if this request was superseded by a newer one
                if (thisRequestId !== patternRequestId) {
                    console.log(`‚è≠Ô∏è Request #${thisRequestId} superseded by #${patternRequestId}, discarding`);
                    return null;
                }

                const html = await response.text();

                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                const links = doc.querySelectorAll('a[href*="quote.ashx?t="]');
                const seen = new Set();
                const stocks = [];

                links.forEach(link => {
                    const ticker = link.textContent.trim();
                    if (ticker && /^[A-Z]{1,5}$/.test(ticker) && !seen.has(ticker) && stocks.length < 25) {
                        seen.add(ticker);
                        const row = link.closest('tr');
                        let price = '', change = '', marketCap = '';
                        if (row) {
                            row.querySelectorAll('td').forEach(cell => {
                                const t = cell.textContent.trim();
                                if (!marketCap && /^\d+\.?\d*[BMK]$/.test(t)) marketCap = t;
                                if (!price && /^\d+\.\d{2}$/.test(t)) price = '$' + t;
                                if (!change && /^-?\d+\.?\d*%$/.test(t)) change = t;
                            });
                        }
                        stocks.push({ ticker, company: '', sector: '', marketCap, price, change, changeNum: parseFloat((change || '').replace('%', '')) || 0 });
                    }
                });

                console.log(`‚úÖ Request #${thisRequestId}: Parsed ${stocks.length} stocks`);

                if (stocks.length > 0) {
                    return stocks;
                }
                return [{ ticker: 'ERROR', company: 'No stocks found for this pattern.', error: true, finvizUrl }];
            } catch (error) {
                console.error(`‚ùå Request #${thisRequestId} failed:`, error.message);
                if (error.name === 'AbortError') return null;
                return [{ ticker: 'ERROR', company: 'Couldn\'t fetch data. Check console for details.', error: true, finvizUrl }];
            }
        };

        // Fetch multiple patterns at once
        const fetchAllPatterns = async (patternIds) => {
            const results = {};
            await Promise.all(
                patternIds.map(async (id) => {
                    results[id] = await fetchPatternStocks(id);
                })
            );
            return results;
        };

        // Technical indicator screener types
        const TECHNICAL_SCREENERS = [
            { id: 'rsi_oversold', name: 'RSI Oversold', emoji: 'üìâ', desc: 'Stocks with RSI below 30 - potential bounce', type: 'bullish' },
            { id: 'rsi_overbought', name: 'RSI Overbought', emoji: 'üìà', desc: 'Stocks with RSI above 70 - extended', type: 'bearish' },
            { id: 'golden_cross', name: 'Golden Cross', emoji: '‚ö°', desc: '50 SMA crossed above 200 SMA - major bullish signal', type: 'bullish' },
            { id: 'death_cross', name: 'Death Cross', emoji: 'üíÄ', desc: '50 SMA crossed below 200 SMA - major bearish signal', type: 'bearish' },
            { id: 'sma_super', name: 'SMA Scanner', emoji: 'üéØ', desc: 'Stocks near 50 & 200 SMA levels', type: 'special' },
        ];

        // Fetch technical screener results from server
        const fetchTechnicalScreener = async (screenType) => {
            try {
                console.log(`[Technical Screener] Fetching: ${screenType}`);
                const response = await fetch(`/api/technical-screener?type=${screenType}`);
                const data = await response.json();
                console.log(`[Technical Screener] Got ${data.count} results`);
                return data.stocks || [];
            } catch (error) {
                console.error('[Technical Screener] Error:', error);
                return [];
            }
        };

        // Fetch insider trading data from OpenInsider
        const fetchInsiderTrading = async () => {
            try {
                const response = await fetch('/api/openinsider');
                const html = await response.text();

                // Parse the HTML table
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const rows = doc.querySelectorAll('table.tinytable tbody tr');

                const insiderTrades = [];
                rows.forEach((row, index) => {
                    if (index >= 20) return; // Limit to 20 results
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 12) {
                        const ticker = cells[3]?.textContent?.trim();
                        const company = cells[4]?.textContent?.trim();
                        const insiderName = cells[5]?.textContent?.trim();
                        const title = cells[6]?.textContent?.trim();
                        const tradeType = cells[7]?.textContent?.trim();
                        const price = cells[8]?.textContent?.trim();
                        const qty = cells[9]?.textContent?.trim();
                        const owned = cells[10]?.textContent?.trim();
                        const value = cells[12]?.textContent?.trim();
                        const filingDate = cells[1]?.textContent?.trim();

                        if (ticker && value) {
                            // Parse value to number for sorting
                            const valueNum = parseFloat(value.replace(/[$,]/g, '')) || 0;
                            insiderTrades.push({
                                ticker,
                                company: company?.substring(0, 30),
                                insiderName: insiderName?.substring(0, 25),
                                title: title?.substring(0, 20),
                                tradeType,
                                price,
                                qty,
                                value,
                                valueNum,
                                filingDate
                            });
                        }
                    }
                });

                // Sort by value descending
                return insiderTrades.sort((a, b) => b.valueNum - a.valueNum);
            } catch (error) {
                console.error('Error fetching insider data:', error);
                return [];
            }
        };

        // Fetch from multiple subreddits and aggregate
        const fetchMultiReddit = async () => {
            const tickerCounts = {};
            const tickerSources = {};
            const allPosts = [];

            // Fetch all subreddits in parallel using local proxy
            const results = await Promise.allSettled(
                SUBREDDITS.map(async (sub) => {
                    try {
                        const response = await fetch(`/api/reddit?sub=${sub.name}`);
                        const data = await response.json();
                        return { sub, data };
                    } catch (e) {
                        return { sub, data: null };
                    }
                })
            );

            // Process results
            const tickerRegex = /\$([A-Z]{1,5})\b|\b([A-Z]{2,5})\b/g;
            const blacklist = ['CEO', 'IPO', 'ETF', 'WSB', 'YOLO', 'IMO', 'USA', 'GDP', 'CPI', 'ATH', 'ATL', 'DD', 'PT', 'SEC', 'FDA', 'THE', 'FOR', 'AND', 'BUT', 'ALL', 'ARE', 'THIS', 'THAT', 'WITH', 'NOT', 'NOW', 'OUT', 'HOW', 'WHY', 'HAS', 'HAD', 'GET', 'GOT', 'CAN', 'NEW', 'ONE', 'TWO', 'ITS', 'ANY', 'MAY', 'DAY', 'BIG', 'TOP', 'LOW', 'HIGH', 'JUST', 'LIKE', 'WHAT', 'WHEN', 'BEEN', 'HAVE', 'WILL', 'MORE', 'SOME', 'VERY', 'ONLY', 'OVER', 'SUCH', 'INTO', 'YEAR', 'YOUR', 'THEM', 'THAN', 'THEY', 'WERE', 'SAID', 'EACH', 'SHE', 'HER', 'HIM', 'HIS', 'WAS', 'FROM', 'THAT', 'ALSO', 'MADE', 'DID', 'RUN', 'PUT', 'SAY', 'SHE', 'TOO', 'USE'];

            results.forEach(result => {
                if (result.status !== 'fulfilled' || !result.value.data?.data?.children) return;

                const { sub, data } = result.value;
                data.data.children.forEach(post => {
                    const title = post.data.title;
                    const body = post.data.selftext || '';
                    const score = post.data.score;
                    const text = title + ' ' + body;
                    const matches = text.match(tickerRegex) || [];

                    matches.forEach(match => {
                        const ticker = match.replace('$', '').toUpperCase();
                        if (!blacklist.includes(ticker) && ticker.length >= 2 && ticker.length <= 5) {
                            // Weight by upvotes and subreddit size
                            const weight = sub.name === 'wallstreetbets' ? 1.5 :
                                          sub.category === 'penny' ? 0.8 : 1;
                            tickerCounts[ticker] = (tickerCounts[ticker] || 0) + (score * weight);

                            // Track which subreddits mention this ticker
                            if (!tickerSources[ticker]) tickerSources[ticker] = new Set();
                            tickerSources[ticker].add(sub.label);
                        }
                    });

                    // Collect hot posts
                    if (score > 50) {
                        allPosts.push({
                            title: title.substring(0, 80) + (title.length > 80 ? '...' : ''),
                            score,
                            subreddit: sub.label,
                            category: sub.category,
                            url: `https://reddit.com${post.data.permalink}`
                        });
                    }
                });
            });

            // Sort tickers by aggregate score
            const trending = Object.entries(tickerCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 25)
                .map(([ticker, score]) => ({
                    ticker,
                    score: Math.round(score),
                    sources: Array.from(tickerSources[ticker] || []),
                    heat: score > 10000 ? 'extreme' : score > 5000 ? 'high' : score > 1000 ? 'medium' : 'low'
                }));

            // Sort posts by score
            const posts = allPosts
                .sort((a, b) => b.score - a.score)
                .slice(0, 15);

            return { trending, posts };
        };

        // Fetch Yahoo Finance trending tickers
        const fetchYahooTrending = async () => {
            try {
                const response = await fetch('/api/yahoo-trending');
                const html = await response.text();

                // Parse trending tickers from Yahoo HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const tickers = [];

                // Look for ticker symbols in the page
                doc.querySelectorAll('a[href*="/quote/"]').forEach(link => {
                    const match = link.href.match(/\/quote\/([A-Z]{1,5})/);
                    if (match && !tickers.find(t => t.ticker === match[1])) {
                        tickers.push({ ticker: match[1], source: 'Yahoo' });
                    }
                });

                return tickers.slice(0, 25);
            } catch (error) {
                console.error('Error fetching Yahoo trending:', error);
                return [];
            }
        };

        // Fetch Stocktwits trending (uses proxy endpoint)
        const fetchStocktwits = async () => {
            try {
                const response = await fetch('/api/proxy?url=' + encodeURIComponent('https://api.stocktwits.com/api/2/trending/symbols.json'));
                const data = await response.json();

                if (data.symbols) {
                    return data.symbols.map(s => ({
                        ticker: s.symbol,
                        source: 'Stocktwits',
                        title: s.title
                    }));
                }
                return [];
            } catch (error) {
                console.error('Error fetching Stocktwits:', error);
                return [];
            }
        };

        // Fetch Finviz most active stocks
        const fetchFinvizBuzz = async () => {
            try {
                const response = await fetch('/api/finviz?pattern=ta_mostactive');
                const html = await response.text();

                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const links = doc.querySelectorAll('a[href*="quote.ashx?t="]');

                const seen = new Set();
                const stocks = [];
                links.forEach(link => {
                    const ticker = link.textContent.trim();
                    if (ticker && /^[A-Z]{1,5}$/.test(ticker) && !seen.has(ticker) && stocks.length < 20) {
                        seen.add(ticker);
                        stocks.push({ ticker, source: 'Finviz' });
                    }
                });
                return stocks;
            } catch (error) {
                console.error('Error fetching Finviz:', error);
                return [];
            }
        };

        // Fetch MarketWatch trending
        const fetchMarketWatch = async () => {
            try {
                const response = await fetch('/api/marketwatch');
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const tickers = [];

                doc.querySelectorAll('a[href*="/investing/stock/"]').forEach(link => {
                    const match = link.href.match(/\/stock\/([A-Z]{1,5})/i);
                    if (match && !tickers.find(t => t.ticker === match[1].toUpperCase())) {
                        tickers.push({ ticker: match[1].toUpperCase(), source: 'MarketWatch' });
                    }
                });
                return tickers.slice(0, 20);
            } catch (error) {
                console.error('Error fetching MarketWatch:', error);
                return [];
            }
        };

        // Fetch CNBC mentions
        const fetchCNBC = async () => {
            try {
                const response = await fetch('/api/cnbc');
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const tickers = [];

                doc.querySelectorAll('a[href*="/quotes/"]').forEach(link => {
                    const match = link.href.match(/\/quotes\/([A-Z]{1,5})/i);
                    if (match && !tickers.find(t => t.ticker === match[1].toUpperCase())) {
                        tickers.push({ ticker: match[1].toUpperCase(), source: 'CNBC' });
                    }
                });
                return tickers.slice(0, 20);
            } catch (error) {
                console.error('Error fetching CNBC:', error);
                return [];
            }
        };

        // Fetch Seeking Alpha mentions
        const fetchSeekingAlpha = async () => {
            try {
                const response = await fetch('/api/seekingalpha');
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const tickers = [];

                doc.querySelectorAll('a[href*="/symbol/"]').forEach(link => {
                    const match = link.href.match(/\/symbol\/([A-Z]{1,5})/i);
                    if (match && !tickers.find(t => t.ticker === match[1].toUpperCase())) {
                        tickers.push({ ticker: match[1].toUpperCase(), source: 'SeekingAlpha' });
                    }
                });
                return tickers.slice(0, 20);
            } catch (error) {
                console.error('Error fetching SeekingAlpha:', error);
                return [];
            }
        };

        // Fetch Motley Fool mentions
        const fetchMotleyFool = async () => {
            try {
                const response = await fetch('/api/motleyfool');
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const tickers = [];

                // Look for ticker patterns in links and text
                doc.querySelectorAll('a[href*="/quote/"]').forEach(link => {
                    const match = link.href.match(/\/quote\/[a-z]+\/([A-Z]{1,5})/i);
                    if (match && !tickers.find(t => t.ticker === match[1].toUpperCase())) {
                        tickers.push({ ticker: match[1].toUpperCase(), source: 'MotleyFool' });
                    }
                });
                return tickers.slice(0, 20);
            } catch (error) {
                console.error('Error fetching MotleyFool:', error);
                return [];
            }
        };

        // Fetch Bloomberg mentions
        const fetchBloomberg = async () => {
            try {
                const response = await fetch('/api/bloomberg');
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const tickers = [];

                doc.querySelectorAll('a[href*="/quote/"]').forEach(link => {
                    const match = link.href.match(/\/quote\/([A-Z]{1,5}):US/i);
                    if (match && !tickers.find(t => t.ticker === match[1].toUpperCase())) {
                        tickers.push({ ticker: match[1].toUpperCase(), source: 'Bloomberg' });
                    }
                });
                return tickers.slice(0, 20);
            } catch (error) {
                console.error('Error fetching Bloomberg:', error);
                return [];
            }
        };

        // Aggregate all sources into unified hot stocks list
        const fetchHotStocks = async () => {
            const tickerData = {};
            const allPosts = [];

            // Fetch all sources in parallel (10 sources total)
            const [
                redditData, yahooData, stocktwitsData, finvizData,
                marketwatchData, cnbcData, seekingalphaData, motleyfoolData, bloombergData
            ] = await Promise.allSettled([
                fetchMultiReddit(),
                fetchYahooTrending(),
                fetchStocktwits(),
                fetchFinvizBuzz(),
                fetchMarketWatch(),
                fetchCNBC(),
                fetchSeekingAlpha(),
                fetchMotleyFool(),
                fetchBloomberg()
            ]);

            // Helper to process source data
            const processSource = (result, sourceName, weight = 50) => {
                if (result.status === 'fulfilled' && result.value) {
                    result.value.forEach((item, index) => {
                        if (!tickerData[item.ticker]) {
                            tickerData[item.ticker] = { ticker: item.ticker, score: 0, sources: new Set(), redditScore: 0 };
                        }
                        tickerData[item.ticker].score += (20 - Math.min(index, 19)) * weight;
                        tickerData[item.ticker].sources.add(sourceName);
                    });
                }
            };

            // Process Reddit data (special handling for posts)
            if (redditData.status === 'fulfilled' && redditData.value) {
                redditData.value.trending.forEach(item => {
                    if (!tickerData[item.ticker]) {
                        tickerData[item.ticker] = { ticker: item.ticker, score: 0, sources: new Set(), redditScore: 0 };
                    }
                    tickerData[item.ticker].score += item.score;
                    tickerData[item.ticker].redditScore = item.score;
                    item.sources.forEach(s => tickerData[item.ticker].sources.add('r/' + s));
                });
                allPosts.push(...(redditData.value.posts || []));
            }

            // Process all other sources
            processSource(yahooData, 'Yahoo', 100);
            processSource(stocktwitsData, 'Stocktwits', 80);
            processSource(finvizData, 'Finviz', 60);
            processSource(marketwatchData, 'MarketWatch', 70);
            processSource(cnbcData, 'CNBC', 90);
            processSource(seekingalphaData, 'SeekingAlpha', 75);
            processSource(motleyfoolData, 'MotleyFool', 65);
            processSource(bloombergData, 'Bloomberg', 95);

            // Convert to sorted array
            const trending = Object.values(tickerData)
                .map(item => ({
                    ...item,
                    sources: Array.from(item.sources),
                    sourceCount: item.sources.size,
                    heat: item.sources.size >= 5 ? 'extreme' : item.sources.size >= 3 ? 'high' : item.sources.size >= 2 ? 'medium' : 'low'
                }))
                .sort((a, b) => {
                    // Sort by number of sources first, then by score
                    if (b.sourceCount !== a.sourceCount) return b.sourceCount - a.sourceCount;
                    return b.score - a.score;
                })
                .slice(0, 30);

            return { trending, posts: allPosts };
        };

        // Fetch trending stocks (now aggregates all sources)
        const fetchTrendingStocks = async () => {
            return await fetchHotStocks();
        };

        // Fetch news for a ticker
        const fetchNews = async (ticker) => {
            try {
                const response = await fetch('/api/proxy?url=' + encodeURIComponent(`https://www.reddit.com/r/stocks/search.json?q=${ticker}&sort=hot&limit=5`));
                const data = await response.json();

                if (data.data && data.data.children) {
                    return data.data.children.map(post => ({
                        title: post.data.title,
                        score: post.data.score,
                        url: `https://reddit.com${post.data.permalink}`
                    }));
                }
                return [];
            } catch (error) {
                console.error('Error fetching news:', error);
                return [];
            }
        };

        // Fetch real stock data from Yahoo Finance
        const fetchStockData = async (ticker) => {
            try {
                const response = await fetch('/api/proxy?url=' + encodeURIComponent(`https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?interval=1d&range=1mo`));
                const data = await response.json();

                if (data.chart && data.chart.result && data.chart.result[0]) {
                    const result = data.chart.result[0];
                    const prices = result.indicators.quote[0].close.filter(p => p !== null);
                    const currentPrice = prices[prices.length - 1];
                    const weekAgoPrice = prices[Math.max(0, prices.length - 6)] || prices[0];
                    const monthAgoPrice = prices[0];

                    const weekChange = ((currentPrice - weekAgoPrice) / weekAgoPrice) * 100;
                    const monthChange = ((currentPrice - monthAgoPrice) / monthAgoPrice) * 100;

                    let momentum = 'flat';
                    if (weekChange > 10 || monthChange > 20) momentum = 'ripping';
                    else if (weekChange < -10 || monthChange < -20) momentum = 'bleeding';
                    else if (weekChange > 3) momentum = 'uptrend';
                    else if (weekChange < -3) momentum = 'downtrend';

                    return {
                        currentPrice,
                        weekChange: weekChange.toFixed(1),
                        monthChange: monthChange.toFixed(1),
                        momentum,
                        prices
                    };
                }
                return null;
            } catch (error) {
                console.error('Error fetching stock data:', error);
                return null;
            }
        };

        // Fetch chart data for Trade Replay feature
        const fetchTradeChartData = async (ticker, entryDate, exitDate, preferredInterval = null) => {
            try {
                // Calculate date range - get data from 2 days before entry to 2 days after exit
                const entryTs = new Date(entryDate).getTime();
                const exitTs = new Date(exitDate).getTime();
                const dayMs = 24 * 60 * 60 * 1000;

                // Use 5d for intraday trades, longer range for swing trades
                const tradeDuration = exitTs - entryTs;
                const isIntraday = tradeDuration < dayMs;

                let interval = '5m';
                let range = '5d';

                // If user specified a preferred interval, use it
                if (preferredInterval) {
                    interval = preferredInterval;
                    // Adjust range based on interval
                    if (preferredInterval === '1m') range = '1d';
                    else if (preferredInterval === '5m') range = '5d';
                    else if (preferredInterval === '15m') range = '5d';
                    else if (preferredInterval === '1h') range = '1mo';
                    else if (preferredInterval === '1d') range = '3mo';
                } else if (isIntraday) {
                    // Default: Use 5m for intraday (less noise than 1m)
                    interval = '5m';
                    range = '5d';
                } else if (tradeDuration < 7 * dayMs) {
                    interval = '15m';
                    range = '5d';
                } else if (tradeDuration < 30 * dayMs) {
                    interval = '1h';
                    range = '1mo';
                } else {
                    interval = '1d';
                    range = '3mo';
                }

                const response = await fetch('/api/proxy?url=' + encodeURIComponent(
                    `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?interval=${interval}&range=${range}`
                ));
                const data = await response.json();

                if (data.chart && data.chart.result && data.chart.result[0]) {
                    const result = data.chart.result[0];
                    const timestamps = result.timestamp || [];
                    const quotes = result.indicators.quote[0];

                    // Format for lightweight-charts
                    const candlestickData = [];
                    for (let i = 0; i < timestamps.length; i++) {
                        if (quotes.open[i] && quotes.high[i] && quotes.low[i] && quotes.close[i]) {
                            candlestickData.push({
                                time: timestamps[i],
                                open: quotes.open[i],
                                high: quotes.high[i],
                                low: quotes.low[i],
                                close: quotes.close[i]
                            });
                        }
                    }

                    return {
                        candlestickData,
                        entryTime: Math.floor(entryTs / 1000),
                        exitTime: Math.floor(exitTs / 1000),
                        interval,
                        range
                    };
                }
                return null;
            } catch (error) {
                console.error('Error fetching trade chart data:', error);
                return null;
            }
        };

        // AI Trade Rating - Analyzes a potential trade and gives 1-10 rating with reasoning
        const analyzeTradeRating = async (formData) => {
            const { ticker, type, optionType, strike, expiration, entryPrice, quantity, strategy } = formData;

            if (!ticker || !entryPrice) {
                return { rating: 0, reasons: ['Enter ticker and price first'], color: 'gray' };
            }

            const reasons = [];
            let score = 5; // Start neutral

            try {
                // Fetch current stock data from Finviz
                const response = await fetch(`/api/finviz?pattern=&ticker=${ticker}`);
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // Try to extract key metrics from Finviz
                const getText = (label) => {
                    const cells = doc.querySelectorAll('td.snapshot-td2');
                    for (const cell of cells) {
                        if (cell.textContent.includes(label)) {
                            const next = cell.nextElementSibling;
                            return next ? next.textContent.trim() : null;
                        }
                    }
                    return null;
                };

                // Get current price from page
                const priceEl = doc.querySelector('strong.quote-price');
                const currentPrice = priceEl ? parseFloat(priceEl.textContent) : parseFloat(entryPrice);

                // ===== STOCK ANALYSIS =====
                if (type === 'stock') {
                    // Check if buying at a reasonable price
                    const entryNum = parseFloat(entryPrice);

                    if (strategy === 'day') {
                        reasons.push('‚ö†Ô∏è Day trading is high-risk, most lose money');
                        score -= 1;
                    } else if (strategy === 'long') {
                        reasons.push('‚úÖ Long-term holding reduces timing risk');
                        score += 1;
                    }

                    // Position size check
                    const positionValue = entryNum * parseFloat(quantity);
                    if (positionValue > 10000) {
                        reasons.push('‚ö†Ô∏è Large position - ensure proper risk management');
                    }

                    // General stock advice
                    reasons.push('üìä Stock trades have lower risk than options');
                    score += 1;
                }

                // ===== OPTIONS ANALYSIS =====
                if (type === 'option') {
                    const strikeNum = parseFloat(strike);
                    const entryNum = parseFloat(entryPrice);

                    // Days to expiration
                    if (expiration) {
                        const expiryDate = new Date(expiration);
                        const today = new Date();
                        const daysToExpiry = Math.ceil((expiryDate - today) / (1000 * 60 * 60 * 24));

                        if (daysToExpiry <= 7) {
                            reasons.push('üî¥ WEEKLY OPTION - Extreme theta decay, very risky');
                            score -= 3;
                        } else if (daysToExpiry <= 14) {
                            reasons.push('üü† Under 2 weeks to expiry - High theta decay');
                            score -= 2;
                        } else if (daysToExpiry <= 30) {
                            reasons.push('üü° Under 30 days - Moderate theta risk');
                            score -= 1;
                        } else if (daysToExpiry >= 180) {
                            reasons.push('‚úÖ LEAP - Time is on your side');
                            score += 2;
                        } else if (daysToExpiry >= 60) {
                            reasons.push('‚úÖ Good runway - 60+ days to expiry');
                            score += 1;
                        }
                    } else {
                        reasons.push('‚ö†Ô∏è No expiration date entered');
                    }

                    // Strike distance from current price
                    if (strikeNum && currentPrice) {
                        const strikeDistance = ((strikeNum - currentPrice) / currentPrice) * 100;

                        if (optionType === 'call') {
                            if (strikeDistance > 20) {
                                reasons.push(`üî¥ Strike ${strikeDistance.toFixed(0)}% above current price - Low probability`);
                                score -= 2;
                            } else if (strikeDistance > 10) {
                                reasons.push(`üü† Strike ${strikeDistance.toFixed(0)}% OTM - Needs big move`);
                                score -= 1;
                            } else if (strikeDistance < 0) {
                                reasons.push(`‚úÖ ITM call - Higher cost but safer`);
                                score += 1;
                            } else {
                                reasons.push(`üü¢ Strike near the money - Reasonable target`);
                            }
                        } else {
                            if (strikeDistance < -20) {
                                reasons.push(`üî¥ Strike ${Math.abs(strikeDistance).toFixed(0)}% below current - Low probability`);
                                score -= 2;
                            } else if (strikeDistance < -10) {
                                reasons.push(`üü† Strike ${Math.abs(strikeDistance).toFixed(0)}% OTM - Needs big drop`);
                                score -= 1;
                            } else if (strikeDistance > 0) {
                                reasons.push(`‚úÖ ITM put - Higher cost but safer`);
                                score += 1;
                            }
                        }
                    }

                    // Premium cost analysis
                    if (entryNum && currentPrice) {
                        const premiumPercent = (entryNum / currentPrice) * 100;
                        if (premiumPercent > 10) {
                            reasons.push(`‚ö†Ô∏è Premium is ${premiumPercent.toFixed(1)}% of stock price - Expensive`);
                            score -= 1;
                        }
                    }

                    // Options are inherently riskier
                    reasons.push('‚ö†Ô∏è Options can go to zero - size accordingly');
                }

                // ===== CRYPTO ANALYSIS =====
                if (type === 'crypto') {
                    reasons.push('‚ö†Ô∏è Crypto is highly volatile - expect 20%+ swings');

                    if (strategy === 'day') {
                        reasons.push('üî¥ Day trading crypto is extremely risky');
                        score -= 2;
                    } else if (strategy === 'long') {
                        reasons.push('‚úÖ Long-term crypto hold has historically worked');
                        score += 1;
                    }

                    const positionValue = parseFloat(entryPrice) * parseFloat(quantity);
                    if (positionValue > 5000) {
                        reasons.push('‚ö†Ô∏è Large crypto position - high volatility risk');
                    }
                }

                // Always remind about timeframes
                reasons.push('üìä Check multiple timeframes before entry');

                // Clamp score between 1 and 10
                score = Math.max(1, Math.min(10, score));

                // Determine color based on score
                let color = 'yellow';
                if (score >= 7) color = 'green';
                else if (score <= 3) color = 'red';

                return { rating: score, reasons, color, currentPrice };

            } catch (error) {
                console.error('Error analyzing trade:', error);
                // Return basic analysis without live data
                if (type === 'option') {
                    reasons.push('‚ö†Ô∏è Options are risky - can lose 100%');
                    if (expiration) {
                        const expiryDate = new Date(expiration);
                        const daysToExpiry = Math.ceil((expiryDate - new Date()) / (1000 * 60 * 60 * 24));
                        if (daysToExpiry <= 7) {
                            reasons.push('üî¥ WEEKLY - Extreme risk');
                            score = 2;
                        } else if (daysToExpiry <= 30) {
                            reasons.push('üü† Short-dated option');
                            score = 4;
                        }
                    }
                }
                return { rating: Math.max(1, Math.min(10, score)), reasons, color: score >= 7 ? 'green' : score <= 3 ? 'red' : 'yellow' };
            }
        };

        // Mock price data (fallback)
        const mockPrices = {
            'NVDA': 148.50,
            'TSLA': 242.30,
            'AAPL': 189.20,
            'BTC': 94500,
            'ETH': 3350,
            'SOL': 185.40
        };

        // Sample positions for demo
        const samplePositions = [
            {
                id: 1,
                ticker: 'NVDA',
                type: 'option',
                optionType: 'call',
                strike: 150,
                expiration: '2026-01-16',
                entryPrice: 5.20,
                currentPrice: 3.10,
                quantity: 10,
                strategy: 'swing'
            },
            {
                id: 2,
                ticker: 'TSLA',
                type: 'stock',
                entryPrice: 250,
                currentPrice: 242.30,
                quantity: 50,
                strategy: 'long'
            },
            {
                id: 3,
                ticker: 'BTC',
                type: 'crypto',
                entryPrice: 98000,
                currentPrice: 94500,
                quantity: 0.5,
                strategy: 'swing'
            },
            {
                id: 4,
                ticker: 'AAPL',
                type: 'option',
                optionType: 'call',
                strike: 190,
                expiration: '2027-01-15',
                entryPrice: 12.50,
                currentPrice: 14.80,
                quantity: 5,
                strategy: 'swing'
            },
            {
                id: 5,
                ticker: 'TSLA',
                type: 'option',
                optionType: 'call',
                strike: 800,
                expiration: '2027-01-15',
                entryPrice: 34.00,
                currentPrice: 27.20,
                quantity: 1,
                strategy: 'swing'
            },
            {
                id: 6,
                ticker: 'OSCR',
                type: 'option',
                optionType: 'call',
                strike: 30,
                expiration: '2026-03-20',
                entryPrice: 1.22,
                currentPrice: 0.33,
                quantity: 3,
                strategy: 'swing',
                momentum: 'ripping'
            }
        ];

        // Calculate days to expiration
        const getDaysToExpiry = (expiration) => {
            if (!expiration) return null;
            const today = new Date();
            const expDate = new Date(expiration);
            const diffTime = expDate - today;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            return diffDays;
        };

        // Format expiration date for display (e.g., "Jan 17, 2025")
        const formatExpirationDate = (expiration) => {
            if (!expiration) return null;
            const date = new Date(expiration + 'T00:00:00');
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        };

        // Generate Yahoo Finance option contract symbol
        // Format: {TICKER}{YYMMDD}{C/P}{STRIKE*1000 padded to 8 digits}
        // Example: NVDA250117C00150000 for NVDA $150 Call expiring Jan 17, 2025
        const generateOptionSymbol = (ticker, expiration, optionType, strike) => {
            if (!ticker || !expiration || !optionType || !strike) return null;

            const date = new Date(expiration + 'T00:00:00');
            const yy = String(date.getFullYear()).slice(-2);
            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const dd = String(date.getDate()).padStart(2, '0');

            const type = optionType.toLowerCase() === 'call' ? 'C' : 'P';
            const strikeFormatted = String(Math.round(parseFloat(strike) * 1000)).padStart(8, '0');

            return `${ticker.toUpperCase()}${yy}${mm}${dd}${type}${strikeFormatted}`;
        };

        // Fetch option contract price from Yahoo Finance
        const fetchOptionPrice = async (ticker, expiration, optionType, strike) => {
            try {
                // Convert expiration to Unix timestamp for Yahoo API
                // Use UTC to avoid timezone issues
                const expDate = new Date(expiration + 'T00:00:00Z');
                const expTimestamp = Math.floor(expDate.getTime() / 1000);

                console.log(`[Option Price] Fetching ${ticker} ${strike} ${optionType} exp:${expiration} ts:${expTimestamp}`);

                const response = await fetch(`/api/yahoo?ticker=${ticker}&type=options&expiry=${expTimestamp}`);
                const data = await response.json();

                if (data.optionChain?.result?.[0]?.options?.[0]) {
                    const options = data.optionChain.result[0].options[0];
                    const contracts = optionType.toLowerCase() === 'call' ? options.calls : options.puts;

                    console.log(`[Option Price] Got ${contracts?.length || 0} ${optionType} contracts for ${ticker}`);

                    // Find the matching strike
                    const strikeNum = parseFloat(strike);
                    const contract = contracts?.find(c => Math.abs(c.strike - strikeNum) < 0.01);

                    if (contract) {
                        // Use mid price (average of bid/ask), fallback to lastPrice
                        const midPrice = contract.bid && contract.ask
                            ? (contract.bid + contract.ask) / 2
                            : contract.lastPrice;

                        console.log(`[Option Price] ${ticker} ${strike}${optionType.charAt(0).toUpperCase()}: bid=${contract.bid} ask=${contract.ask} mid=${midPrice}`);

                        return {
                            price: midPrice,
                            bid: contract.bid,
                            ask: contract.ask,
                            lastPrice: contract.lastPrice,
                            change: contract.change,
                            percentChange: contract.percentChange,
                            volume: contract.volume,
                            openInterest: contract.openInterest,
                            impliedVolatility: contract.impliedVolatility
                        };
                    } else {
                        console.log(`[Option Price] No contract found for strike ${strikeNum}. Available strikes:`, contracts?.slice(0, 5).map(c => c.strike));
                    }
                } else {
                    console.log(`[Option Price] No options data returned for ${ticker}`, data);
                }
                return null;
            } catch (error) {
                console.error('[Option Price] Error:', error);
                return null;
            }
        };

        // ============================================
        // SCALPER TOOLKIT - Day Trading Features
        // ============================================

        // Momentum Indicator - Based on recent price action
        const getMomentum = (dayChange, volume, avgVolume) => {
            const change = parseFloat(dayChange) || 0;
            const volRatio = volume && avgVolume ? volume / avgVolume : 1;

            if (change > 5 || (change > 3 && volRatio > 2)) {
                return { status: 'RIPPING', emoji: 'üöÄ', color: 'text-green-400', bg: 'bg-green-500/20' };
            } else if (change > 2) {
                return { status: 'BULLISH', emoji: 'üìà', color: 'text-green-400', bg: 'bg-green-500/10' };
            } else if (change > 0.5) {
                return { status: 'UPTREND', emoji: '‚ÜóÔ∏è', color: 'text-green-300', bg: 'bg-green-500/5' };
            } else if (change < -5 || (change < -3 && volRatio > 2)) {
                return { status: 'DRILLING', emoji: 'üìâ', color: 'text-red-400', bg: 'bg-red-500/20' };
            } else if (change < -2) {
                return { status: 'BEARISH', emoji: 'üêª', color: 'text-red-400', bg: 'bg-red-500/10' };
            } else if (change < -0.5) {
                return { status: 'DOWNTREND', emoji: '‚ÜòÔ∏è', color: 'text-red-300', bg: 'bg-red-500/5' };
            } else {
                return { status: 'CHOPPY', emoji: 'üòê', color: 'text-gray-400', bg: 'bg-gray-500/10' };
            }
        };

        // Volume Spike Detection
        const getVolumeStatus = (volume, avgVolume) => {
            if (!volume || !avgVolume) return null;
            const ratio = volume / avgVolume;

            if (ratio >= 3) {
                return { status: 'EXTREME', emoji: 'üî•üî•üî•', color: 'text-orange-400', multiplier: ratio.toFixed(1) };
            } else if (ratio >= 2) {
                return { status: 'HIGH', emoji: 'üî•üî•', color: 'text-orange-400', multiplier: ratio.toFixed(1) };
            } else if (ratio >= 1.5) {
                return { status: 'ELEVATED', emoji: 'üî•', color: 'text-yellow-400', multiplier: ratio.toFixed(1) };
            } else if (ratio <= 0.5) {
                return { status: 'LOW', emoji: 'üò¥', color: 'text-gray-500', multiplier: ratio.toFixed(1) };
            }
            return { status: 'NORMAL', emoji: 'üìä', color: 'text-gray-400', multiplier: ratio.toFixed(1) };
        };

        // VWAP Indicator (simplified - based on day's price action)
        const getVWAPStatus = (currentPrice, vwap) => {
            if (!currentPrice || !vwap) return null;
            const diff = ((currentPrice - vwap) / vwap) * 100;

            if (diff > 1) {
                return { status: 'ABOVE VWAP', emoji: '‚úÖ', color: 'text-green-400', diff: `+${diff.toFixed(2)}%` };
            } else if (diff < -1) {
                return { status: 'BELOW VWAP', emoji: '‚ö†Ô∏è', color: 'text-red-400', diff: `${diff.toFixed(2)}%` };
            }
            return { status: 'AT VWAP', emoji: '‚û°Ô∏è', color: 'text-yellow-400', diff: `${diff.toFixed(2)}%` };
        };

        // Speed Alert - Detect rapid price movements
        const checkSpeedAlert = (ticker, currentPrice, previousPrice, timeframeSecs = 60) => {
            if (!currentPrice || !previousPrice) return null;
            const changePercent = ((currentPrice - previousPrice) / previousPrice) * 100;

            if (Math.abs(changePercent) >= 2) {
                return {
                    ticker,
                    change: changePercent,
                    direction: changePercent > 0 ? 'UP' : 'DOWN',
                    emoji: changePercent > 0 ? 'üöÄ' : 'üìâ',
                    message: `${ticker} moved ${changePercent > 0 ? '+' : ''}${changePercent.toFixed(1)}% in ${timeframeSecs}s!`
                };
            }
            return null;
        };

        // Hot Streak Tracker - Load from localStorage
        const loadTradeStats = () => {
            try {
                const saved = localStorage.getItem('tradeStats');
                return saved ? JSON.parse(saved) : {
                    wins: 0,
                    losses: 0,
                    streak: 0,
                    streakType: null, // 'win' or 'loss'
                    todayPnL: 0,
                    todayTrades: 0,
                    lastTradeDate: null
                };
            } catch (e) {
                return { wins: 0, losses: 0, streak: 0, streakType: null, todayPnL: 0, todayTrades: 0, lastTradeDate: null };
            }
        };

        const saveTradeStats = (stats) => {
            localStorage.setItem('tradeStats', JSON.stringify(stats));
        };

        // Daily Goal Tracker - Load from localStorage
        const loadDailyGoal = () => {
            try {
                const saved = localStorage.getItem('dailyGoal');
                return saved ? parseFloat(saved) : 500; // Default $500 goal
            } catch (e) {
                return 500;
            }
        };

        const saveDailyGoal = (goal) => {
            localStorage.setItem('dailyGoal', goal.toString());
        };

        // ===== TRADE JOURNAL - TradeZella Style =====
        // Complete trade logging, analytics, and performance tracking

        const SETUP_TYPES = [
            { id: 'breakout', label: 'Breakout', emoji: 'üöÄ' },
            { id: 'breakdown', label: 'Breakdown', emoji: 'üìâ' },
            { id: 'reversal', label: 'Reversal', emoji: 'üîÑ' },
            { id: 'momentum', label: 'Momentum', emoji: '‚ö°' },
            { id: 'scalp', label: 'Scalp', emoji: 'üéØ' },
            { id: 'swing', label: 'Swing', emoji: 'üåä' },
            { id: 'earnings', label: 'Earnings Play', emoji: 'üìä' },
            { id: 'news', label: 'News Catalyst', emoji: 'üì∞' },
            { id: 'gap', label: 'Gap Fill', emoji: '‚¨ÜÔ∏è' },
            { id: 'support', label: 'Support Bounce', emoji: 'üõ°Ô∏è' },
            { id: 'resistance', label: 'Resistance Break', emoji: 'üí•' },
            { id: 'vwap', label: 'VWAP Play', emoji: 'üìà' },
            { id: 'options_flow', label: 'Options Flow', emoji: 'üåä' },
            { id: 'squeeze', label: 'Short Squeeze', emoji: 'üçã' },
            { id: 'other', label: 'Other', emoji: 'üìù' }
        ];

        const MISTAKE_TYPES = [
            { id: 'fomo', label: 'FOMO Entry', emoji: 'üò∞' },
            { id: 'no_stop', label: 'No Stop Loss', emoji: 'üõë' },
            { id: 'moved_stop', label: 'Moved Stop', emoji: 'üîÑ' },
            { id: 'oversized', label: 'Oversized Position', emoji: 'üêã' },
            { id: 'revenge', label: 'Revenge Trade', emoji: 'üò§' },
            { id: 'early_exit', label: 'Early Exit', emoji: 'üèÉ' },
            { id: 'late_exit', label: 'Late Exit', emoji: 'üê¢' },
            { id: 'chasing', label: 'Chasing', emoji: 'üèÉ‚Äç‚ôÇÔ∏è' },
            { id: 'no_plan', label: 'No Trade Plan', emoji: '‚ùì' },
            { id: 'overtrading', label: 'Overtrading', emoji: 'üî•' },
            { id: 'ignored_rules', label: 'Ignored Rules', emoji: '‚ö†Ô∏è' },
            { id: 'emotional', label: 'Emotional Decision', emoji: 'üò¢' },
            { id: 'none', label: 'No Mistakes', emoji: '‚úÖ' }
        ];

        const EMOTIONS = [
            { id: 'confident', label: 'Confident', emoji: 'üòé', color: 'text-green-400' },
            { id: 'neutral', label: 'Neutral', emoji: 'üòê', color: 'text-gray-400' },
            { id: 'anxious', label: 'Anxious', emoji: 'üò∞', color: 'text-yellow-400' },
            { id: 'fearful', label: 'Fearful', emoji: 'üò®', color: 'text-orange-400' },
            { id: 'greedy', label: 'Greedy', emoji: 'ü§ë', color: 'text-yellow-400' },
            { id: 'frustrated', label: 'Frustrated', emoji: 'üò§', color: 'text-red-400' },
            { id: 'revenge', label: 'Revenge Mode', emoji: 'üëä', color: 'text-red-500' },
            { id: 'fomo', label: 'FOMO', emoji: 'üò±', color: 'text-purple-400' },
            { id: 'excited', label: 'Excited', emoji: 'ü§©', color: 'text-blue-400' },
            { id: 'bored', label: 'Bored', emoji: 'üò¥', color: 'text-gray-500' }
        ];

        const TRADE_STYLES = [
            { id: 'scalp', label: 'Scalp', emoji: '‚ö°', desc: 'Quick in/out (minutes)', expectedDuration: 15 },
            { id: 'day', label: 'Day Trade', emoji: '‚òÄÔ∏è', desc: 'Same day (hours)', expectedDuration: 240 },
            { id: 'swing', label: 'Swing', emoji: 'üåä', desc: 'Multi-day (days/weeks)', expectedDuration: 1440 }
        ];

        // Sample trades for testing AI Coach features
        const sampleJournalTrades = [
            {
                id: 1001,
                ticker: 'NVDA',
                side: 'long',
                assetType: 'stock',
                tradeStyle: 'day',
                entryPrice: 875.50,  // Average entry price
                exitPrice: 912.25,   // Average exit price
                quantity: 10,        // Total quantity
                entryDate: '2026-01-14T09:45:00',
                exitDate: '2026-01-14T14:30:00',
                // Multiple entries (scaling in)
                entries: [
                    { price: 878.00, quantity: 5, date: '2026-01-14T09:45:00', note: 'Initial entry on breakout' },
                    { price: 873.00, quantity: 5, date: '2026-01-14T10:30:00', note: 'Added on pullback to support' }
                ],
                // Multiple exits (scaling out)
                exits: [
                    { price: 905.00, quantity: 5, date: '2026-01-14T13:00:00', note: 'Took half off at first target' },
                    { price: 919.50, quantity: 5, date: '2026-01-14T14:30:00', note: 'Let runner hit extended target' }
                ],
                pnl: 367.50,
                fees: 2.00,
                setup: 'breakout',
                mistakes: ['none'],
                emotionBefore: 'confident',
                emotionAfter: 'confident',
                followedPlan: true,
                riskAmount: 150,
                notes: 'Perfect breakout above resistance. Held through the pullback. Let it run to target.'
            },
            {
                id: 1002,
                ticker: 'TSLA',
                side: 'long',
                assetType: 'option',
                tradeStyle: 'scalp',
                entryPrice: 4.50,
                exitPrice: 2.10,
                quantity: 5,
                entryDate: '2025-01-06T10:15:00',
                exitDate: '2025-01-06T11:00:00',
                pnl: -1200.00,
                fees: 3.50,
                setup: 'momentum',
                mistakes: ['fomo', 'oversized'],
                emotionBefore: 'greedy',
                emotionAfter: 'frustrated',
                followedPlan: false,
                riskAmount: 200,
                notes: 'Chased after seeing it run. Position too big. Got crushed on the reversal.'
            },
            {
                id: 1003,
                ticker: 'SPY',
                side: 'short',
                assetType: 'option',
                tradeStyle: 'scalp',
                entryPrice: 3.20,
                exitPrice: 4.85,
                quantity: 10,
                entryDate: '2025-01-07T09:35:00',
                exitDate: '2025-01-07T10:45:00',
                pnl: 1650.00,
                fees: 5.00,
                setup: 'reversal',
                mistakes: ['none'],
                emotionBefore: 'focused',
                emotionAfter: 'confident',
                followedPlan: true,
                riskAmount: 300,
                notes: 'Caught the morning fade perfectly. Scaled out at targets.'
            },
            {
                id: 1004,
                ticker: 'AAPL',
                side: 'long',
                assetType: 'stock',
                tradeStyle: 'day',
                entryPrice: 185.20,
                exitPrice: 183.50,
                quantity: 50,
                entryDate: '2025-01-07T13:00:00',
                exitDate: '2025-01-07T14:30:00',
                pnl: -85.00,
                fees: 1.00,
                setup: 'support_bounce',
                mistakes: ['none'],
                emotionBefore: 'calm',
                emotionAfter: 'neutral',
                followedPlan: true,
                riskAmount: 100,
                notes: 'Support didnt hold. Stopped out as planned. Good process, bad outcome.'
            },
            {
                id: 1005,
                ticker: 'AMD',
                side: 'long',
                assetType: 'stock',
                tradeStyle: 'day',
                entryPrice: 142.30,
                exitPrice: 148.75,
                quantity: 30,
                entryDate: '2025-01-08T09:50:00',
                exitDate: '2025-01-08T15:30:00',
                pnl: 193.50,
                fees: 1.50,
                setup: 'breakout',
                mistakes: ['early_exit'],
                emotionBefore: 'confident',
                emotionAfter: 'frustrated',
                followedPlan: false,
                riskAmount: 120,
                notes: 'Good entry but took profits too early. It ran another 3% after I sold.'
            },
            {
                id: 1006,
                ticker: 'META',
                side: 'long',
                assetType: 'stock',
                tradeStyle: 'scalp',
                entryPrice: 485.00,
                exitPrice: 472.25,
                quantity: 15,
                entryDate: '2025-01-08T11:30:00',
                exitDate: '2025-01-08T13:15:00',
                pnl: -191.25,
                fees: 1.00,
                setup: 'momentum',
                mistakes: ['revenge', 'no_plan'],
                emotionBefore: 'frustrated',
                emotionAfter: 'angry',
                followedPlan: false,
                riskAmount: 100,
                notes: 'Revenge trade after AMD. No real setup. Just trying to make back losses.'
            },
            {
                id: 1007,
                ticker: 'NVDA',
                side: 'long',
                assetType: 'option',
                tradeStyle: 'scalp',
                entryPrice: 12.50,
                exitPrice: 18.20,
                quantity: 8,
                entryDate: '2025-01-09T09:32:00',
                exitDate: '2025-01-09T11:15:00',
                pnl: 4560.00,
                fees: 8.00,
                setup: 'gap_fill',
                mistakes: ['none'],
                emotionBefore: 'focused',
                emotionAfter: 'euphoric',
                followedPlan: true,
                riskAmount: 500,
                notes: 'Gap up continuation. Added on the first pullback. Best trade of the week!'
            },
            {
                id: 1008,
                ticker: 'GOOGL',
                side: 'short',
                assetType: 'stock',
                tradeStyle: 'day',
                entryPrice: 175.80,
                exitPrice: 177.40,
                quantity: 40,
                entryDate: '2025-01-09T14:00:00',
                exitDate: '2025-01-09T15:45:00',
                pnl: -64.00,
                fees: 2.00,
                setup: 'reversal',
                mistakes: ['overtrading'],
                emotionBefore: 'greedy',
                emotionAfter: 'neutral',
                followedPlan: true,
                riskAmount: 80,
                notes: 'Shouldnt have taken this trade. Already had a big winner today. Overtrading.'
            },
            {
                id: 1009,
                ticker: 'MSFT',
                side: 'long',
                assetType: 'stock',
                tradeStyle: 'day',
                entryPrice: 395.50,
                exitPrice: 401.25,
                quantity: 20,
                entryDate: '2025-01-10T10:00:00',
                exitDate: '2025-01-10T14:00:00',
                pnl: 115.00,
                fees: 1.00,
                setup: 'support_bounce',
                mistakes: ['none'],
                emotionBefore: 'calm',
                emotionAfter: 'confident',
                followedPlan: true,
                riskAmount: 100,
                notes: 'Clean bounce off 50 SMA. Textbook setup.'
            },
            {
                id: 1010,
                ticker: 'AMZN',
                side: 'long',
                assetType: 'option',
                tradeStyle: 'scalp',
                entryPrice: 8.75,
                exitPrice: 5.20,
                quantity: 6,
                entryDate: '2025-01-10T09:35:00',
                exitDate: '2025-01-10T10:30:00',
                pnl: -2130.00,
                fees: 6.00,
                setup: 'earnings',
                mistakes: ['oversized', 'no_stop'],
                emotionBefore: 'greedy',
                emotionAfter: 'devastated',
                followedPlan: false,
                riskAmount: 400,
                notes: 'Held through earnings like an idiot. Way too big. No stop. Expensive lesson.'
            },
            {
                id: 1011,
                ticker: 'COIN',
                side: 'long',
                assetType: 'stock',
                tradeStyle: 'day',
                entryPrice: 245.00,
                exitPrice: 268.50,
                quantity: 25,
                entryDate: '2025-01-13T09:40:00',
                exitDate: '2025-01-13T13:30:00',
                pnl: 587.50,
                fees: 2.00,
                setup: 'breakout',
                mistakes: ['none'],
                emotionBefore: 'confident',
                emotionAfter: 'confident',
                followedPlan: true,
                riskAmount: 200,
                notes: 'Bitcoin pumping, COIN breaking out. Rode the momentum.'
            },
            {
                id: 1012,
                ticker: 'PLTR',
                side: 'long',
                assetType: 'stock',
                tradeStyle: 'scalp',
                entryPrice: 72.50,
                exitPrice: 71.25,
                quantity: 100,
                entryDate: '2025-01-13T11:00:00',
                exitDate: '2025-01-13T12:30:00',
                pnl: -125.00,
                fees: 1.00,
                setup: 'momentum',
                mistakes: ['fomo'],
                emotionBefore: 'anxious',
                emotionAfter: 'frustrated',
                followedPlan: false,
                riskAmount: 150,
                notes: 'Chased it after seeing COIN work. Different setup, different result.'
            },
            {
                id: 1013,
                ticker: 'AAPL',
                side: 'long',
                assetType: 'option',
                tradeStyle: 'swing',
                entryPrice: 15.50,
                exitPrice: 22.75,
                quantity: 10,
                entryDate: '2024-12-15T10:00:00',
                exitDate: '2025-01-10T14:30:00',
                pnl: 725.00,
                fees: 10.00,
                setup: 'support_bounce',
                mistakes: ['none'],
                emotionBefore: 'calm',
                emotionAfter: 'confident',
                followedPlan: true,
                riskAmount: 300,
                notes: 'LEAP call on AAPL. Held through the holiday volatility. Patience paid off.'
            }
        ];

        // Load journal entries from localStorage
        const loadJournalEntries = () => {
            try {
                const saved = localStorage.getItem('tradeJournal');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Return saved if has trades, otherwise return samples
                    return parsed.length > 0 ? parsed : sampleJournalTrades;
                }
                return sampleJournalTrades; // Return samples for new users
            } catch (e) {
                return sampleJournalTrades;
            }
        };

        // Save journal entries
        const saveJournalEntries = (entries) => {
            localStorage.setItem('tradeJournal', JSON.stringify(entries));
        };

        // Calculate journal statistics
        const calculateJournalStats = (entries) => {
            if (!entries || entries.length === 0) {
                return {
                    totalTrades: 0,
                    wins: 0,
                    losses: 0,
                    breakeven: 0,
                    winRate: 0,
                    totalPnL: 0,
                    avgWin: 0,
                    avgLoss: 0,
                    profitFactor: 0,
                    largestWin: 0,
                    largestLoss: 0,
                    avgRMultiple: 0,
                    currentStreak: 0,
                    streakType: null,
                    bestDay: null,
                    worstDay: null,
                    avgTradesPerDay: 0,
                    totalFees: 0,
                    netPnL: 0,
                    expectancy: 0,
                    setupStats: {},
                    mistakeStats: {},
                    emotionStats: {},
                    dayOfWeekStats: {},
                    hourStats: {}
                };
            }

            const wins = entries.filter(e => e.pnl > 0);
            const losses = entries.filter(e => e.pnl < 0);
            const breakeven = entries.filter(e => e.pnl === 0);

            const totalWins = wins.reduce((sum, e) => sum + e.pnl, 0);
            const totalLosses = Math.abs(losses.reduce((sum, e) => sum + e.pnl, 0));
            const totalPnL = entries.reduce((sum, e) => sum + e.pnl, 0);
            const totalFees = entries.reduce((sum, e) => sum + (e.fees || 0), 0);

            // Calculate streaks
            let currentStreak = 0;
            let streakType = null;
            const sortedEntries = [...entries].sort((a, b) => new Date(b.exitDate) - new Date(a.exitDate));
            for (const entry of sortedEntries) {
                const isWin = entry.pnl > 0;
                if (currentStreak === 0) {
                    streakType = isWin ? 'win' : 'loss';
                    currentStreak = 1;
                } else if ((isWin && streakType === 'win') || (!isWin && streakType === 'loss')) {
                    currentStreak++;
                } else {
                    break;
                }
            }

            // Group by day for best/worst day
            const dayPnL = {};
            entries.forEach(e => {
                const day = e.exitDate?.split('T')[0] || e.entryDate?.split('T')[0];
                if (day) {
                    dayPnL[day] = (dayPnL[day] || 0) + e.pnl;
                }
            });
            const days = Object.entries(dayPnL);
            const bestDay = days.length > 0 ? days.reduce((a, b) => b[1] > a[1] ? b : a) : null;
            const worstDay = days.length > 0 ? days.reduce((a, b) => b[1] < a[1] ? b : a) : null;

            // Setup performance
            const setupStats = {};
            entries.forEach(e => {
                if (e.setup) {
                    if (!setupStats[e.setup]) {
                        setupStats[e.setup] = { trades: 0, wins: 0, pnl: 0 };
                    }
                    setupStats[e.setup].trades++;
                    if (e.pnl > 0) setupStats[e.setup].wins++;
                    setupStats[e.setup].pnl += e.pnl;
                }
            });

            // Mistake tracking
            const mistakeStats = {};
            entries.forEach(e => {
                (e.mistakes || []).forEach(m => {
                    if (!mistakeStats[m]) {
                        mistakeStats[m] = { count: 0, totalLoss: 0 };
                    }
                    mistakeStats[m].count++;
                    if (e.pnl < 0) mistakeStats[m].totalLoss += Math.abs(e.pnl);
                });
            });

            // Emotion correlation
            const emotionStats = {};
            entries.forEach(e => {
                if (e.emotionBefore) {
                    if (!emotionStats[e.emotionBefore]) {
                        emotionStats[e.emotionBefore] = { trades: 0, wins: 0, pnl: 0 };
                    }
                    emotionStats[e.emotionBefore].trades++;
                    if (e.pnl > 0) emotionStats[e.emotionBefore].wins++;
                    emotionStats[e.emotionBefore].pnl += e.pnl;
                }
            });

            // Day of week performance
            const dayOfWeekStats = { 0: { pnl: 0, trades: 0 }, 1: { pnl: 0, trades: 0 }, 2: { pnl: 0, trades: 0 }, 3: { pnl: 0, trades: 0 }, 4: { pnl: 0, trades: 0 }, 5: { pnl: 0, trades: 0 }, 6: { pnl: 0, trades: 0 } };
            entries.forEach(e => {
                const day = new Date(e.entryDate).getDay();
                dayOfWeekStats[day].trades++;
                dayOfWeekStats[day].pnl += e.pnl;
            });

            // Hour performance
            const hourStats = {};
            entries.forEach(e => {
                const hour = new Date(e.entryDate).getHours();
                if (!hourStats[hour]) hourStats[hour] = { trades: 0, pnl: 0, wins: 0 };
                hourStats[hour].trades++;
                hourStats[hour].pnl += e.pnl;
                if (e.pnl > 0) hourStats[hour].wins++;
            });

            const avgWin = wins.length > 0 ? totalWins / wins.length : 0;
            const avgLoss = losses.length > 0 ? totalLosses / losses.length : 0;
            const winRate = entries.length > 0 ? (wins.length / entries.length) * 100 : 0;
            const profitFactor = totalLosses > 0 ? totalWins / totalLosses : totalWins > 0 ? Infinity : 0;
            const expectancy = entries.length > 0 ? totalPnL / entries.length : 0;

            // R-Multiple calculations
            const rMultiples = entries.filter(e => e.riskAmount && e.riskAmount > 0).map(e => e.pnl / e.riskAmount);
            const avgRMultiple = rMultiples.length > 0 ? rMultiples.reduce((a, b) => a + b, 0) / rMultiples.length : 0;

            return {
                totalTrades: entries.length,
                wins: wins.length,
                losses: losses.length,
                breakeven: breakeven.length,
                winRate,
                totalPnL,
                avgWin,
                avgLoss,
                profitFactor,
                largestWin: wins.length > 0 ? Math.max(...wins.map(e => e.pnl)) : 0,
                largestLoss: losses.length > 0 ? Math.min(...losses.map(e => e.pnl)) : 0,
                avgRMultiple,
                currentStreak,
                streakType,
                bestDay,
                worstDay,
                avgTradesPerDay: days.length > 0 ? entries.length / days.length : 0,
                totalFees,
                netPnL: totalPnL - totalFees,
                expectancy,
                setupStats,
                mistakeStats,
                emotionStats,
                dayOfWeekStats,
                hourStats
            };
        };

        // Grade a trade (A+ to F)
        const gradeJournalTrade = (trade) => {
            let score = 50; // Start at C
            const reasons = [];

            // Win/Loss impact (+/- 20 points)
            if (trade.pnl > 0) {
                score += 15;
                reasons.push('Winner');
            } else if (trade.pnl < 0) {
                score -= 10;
                reasons.push('Loser');
            }

            // R-Multiple bonus (up to +20)
            if (trade.riskAmount && trade.riskAmount > 0) {
                const rMultiple = trade.pnl / trade.riskAmount;
                if (rMultiple >= 3) { score += 20; reasons.push('3R+ trade!'); }
                else if (rMultiple >= 2) { score += 15; reasons.push('2R+ trade'); }
                else if (rMultiple >= 1) { score += 10; reasons.push('1R+ trade'); }
                else if (rMultiple <= -1) { score -= 10; reasons.push('Full stop hit'); }
            }

            // Plan followed (+15)
            if (trade.followedPlan) {
                score += 15;
                reasons.push('Followed plan');
            } else {
                score -= 10;
                reasons.push('Deviated from plan');
            }

            // Mistakes (-5 each)
            const mistakes = trade.mistakes || [];
            if (mistakes.length > 0 && !mistakes.includes('none')) {
                score -= mistakes.length * 5;
                reasons.push(`${mistakes.length} mistake(s)`);
            } else if (mistakes.includes('none')) {
                score += 10;
                reasons.push('Clean execution');
            }

            // Emotional state impact
            const badEmotions = ['revenge', 'fomo', 'frustrated', 'greedy'];
            if (badEmotions.includes(trade.emotionBefore)) {
                score -= 10;
                reasons.push('Traded with bad mindset');
            }
            if (trade.emotionBefore === 'confident' || trade.emotionBefore === 'neutral') {
                score += 5;
                reasons.push('Good mental state');
            }

            // Notes bonus
            if (trade.notes && trade.notes.length > 50) {
                score += 5;
                reasons.push('Detailed notes');
            }

            // Clamp and convert to letter grade
            score = Math.max(0, Math.min(100, score));
            let grade, color;
            if (score >= 90) { grade = 'A+'; color = 'text-green-400'; }
            else if (score >= 80) { grade = 'A'; color = 'text-green-400'; }
            else if (score >= 70) { grade = 'B'; color = 'text-blue-400'; }
            else if (score >= 60) { grade = 'C'; color = 'text-yellow-400'; }
            else if (score >= 50) { grade = 'D'; color = 'text-orange-400'; }
            else { grade = 'F'; color = 'text-red-400'; }

            return { grade, score, color, reasons };
        };

        // Get Voice of Logic review for a trade - UNIQUE per trade
        const getTradeReview = (trade, personality = 'homie') => {
            const isWin = trade.pnl > 0;
            const pnlAbs = Math.abs(trade.pnl);
            const rMultiple = trade.riskAmount ? trade.pnl / trade.riskAmount : null;
            const grade = gradeJournalTrade(trade);
            const mistakes = trade.mistakes || [];
            const hasMistakes = mistakes.length > 0 && !mistakes.includes('none');

            // Get specific trade details
            const ticker = trade.ticker;
            const setupInfo = SETUP_TYPES.find(s => s.id === trade.setup);
            const setupName = setupInfo?.label || trade.setup || 'trade';
            const assetType = trade.assetType === 'option' ? 'options' : trade.assetType === 'crypto' ? 'crypto' : 'stock';
            const side = trade.side === 'long' ? 'long' : 'short';
            const entryPrice = trade.entryPrice?.toFixed(2);
            const exitPrice = trade.exitPrice?.toFixed(2);

            // Calculate duration
            const entryTime = new Date(trade.entryDate);
            const exitTime = new Date(trade.exitDate || trade.entryDate);
            const durationMins = Math.round((exitTime - entryTime) / 60000);
            const durationStr = durationMins < 60 ? `${durationMins} min` : `${(durationMins/60).toFixed(1)} hrs`;

            // Time of day
            const hour = entryTime.getHours();
            const timeStr = hour < 10 ? 'at open' : hour < 12 ? 'mid-morning' : hour < 14 ? 'midday' : 'afternoon';

            // Mistake names
            const mistakeNames = mistakes.filter(m => m !== 'none').map(m => MISTAKE_TYPES.find(mt => mt.id === m)?.label || m);

            if (personality === 'homie') {
                if (isWin && grade.grade.includes('A')) {
                    const openers = [`${ticker} ${setupName} was MONEY! üî•`, `Yo, that ${ticker} play was textbook!`, `${ticker} printed! Clean ${setupName} execution.`];
                    const middles = [
                        `${side === 'long' ? 'Bought' : 'Shorted'} at $${entryPrice}, out at $${exitPrice} for +$${pnlAbs.toFixed(2)}.`,
                        `In at $${entryPrice}, closed $${exitPrice}. ${durationStr} hold time, +$${pnlAbs.toFixed(2)} secured.`,
                        `$${entryPrice} ‚Üí $${exitPrice} in ${durationStr}. That's a ${rMultiple ? rMultiple.toFixed(1) + 'R' : '+$' + pnlAbs.toFixed(2)} bag.`
                    ];
                    const closers = [
                        trade.followedPlan ? `Followed the plan, got paid. This is how it's done.` : ``,
                        rMultiple && rMultiple >= 2 ? `${rMultiple.toFixed(1)}R winner - you let it breathe.` : ``,
                        `More ${setupName}s like this please.`
                    ].filter(c => c);
                    return `${openers[trade.id % openers.length]} ${middles[trade.id % middles.length]} ${closers[trade.id % closers.length]}`;

                } else if (isWin && hasMistakes) {
                    return `${ticker} made money (+$${pnlAbs.toFixed(2)}) but let's keep it real - ${mistakeNames.join(' and ')} almost cost you. You ${side === 'long' ? 'bought' : 'shorted'} at $${entryPrice} ${timeStr} and the market bailed you out. Don't confuse luck with skill on this ${assetType} play.`;

                } else if (isWin) {
                    const openers = [`${ticker} W secured.`, `Nice ${ticker} ${setupName}.`, `${ticker} ${assetType} worked out.`];
                    return `${openers[trade.id % openers.length]} ${side === 'long' ? 'Long' : 'Short'} from $${entryPrice} to $${exitPrice}, +$${pnlAbs.toFixed(2)} in ${durationStr}. ${trade.notes ? 'Good note-taking too.' : 'Keep stacking these.'}`;

                } else if (!isWin && grade.grade === 'F') {
                    return `${ticker} hurt. üò§ ${side === 'long' ? 'Bought' : 'Shorted'} at $${entryPrice}, stopped at $${exitPrice}. -$${pnlAbs.toFixed(2)} ${timeStr}. ${hasMistakes ? `The ${mistakeNames.join(', ')} killed you here.` : ''} ${!trade.followedPlan ? `You broke your own rules on this ${assetType} trade - that's the real L.` : `${durationStr} of pain.`}`;

                } else if (!isWin) {
                    return `${ticker} L, but controlled. $${entryPrice} ‚Üí $${exitPrice}, -$${pnlAbs.toFixed(2)}. ${trade.followedPlan ? `${setupName} didn't work this time but you followed rules.` : `Broke your plan on this one.`} ${rMultiple && rMultiple >= -1 ? `${rMultiple.toFixed(1)}R loss - risk managed.` : `Review that stop placement.`}`;
                }
            }

            // Oracle personality - Warren Buffett style
            if (personality === 'oracle') {
                if (isWin) {
                    return `Your ${ticker} ${setupName} demonstrates sound judgment. Entry at $${entryPrice}, exit at $${exitPrice} over ${durationStr} - patience rewarded with $${pnlAbs.toFixed(2)}. ${rMultiple ? `A ${rMultiple.toFixed(1)}R return shows you understand position sizing.` : ''} ${trade.followedPlan ? `Most importantly, you followed your rules. Process over outcome.` : `Though profitable, the deviation from your plan concerns me.`}`;
                } else {
                    return `The ${ticker} ${setupName} resulted in a -$${pnlAbs.toFixed(2)} loss. Entry $${entryPrice}, exit $${exitPrice}. ${trade.followedPlan ? `You followed your process - losses are simply the cost of doing business in markets. A ${rMultiple ? rMultiple.toFixed(1) + 'R' : 'controlled'} loss is acceptable.` : `The deviation from your rules is more concerning than the dollar amount. Discipline is everything.`}`;
                }
            }

            return `${ticker} ${isWin ? 'winner' : 'loser'}: $${entryPrice} ‚Üí $${exitPrice}, ${isWin ? '+' : '-'}$${pnlAbs.toFixed(2)}. Grade: ${grade.grade}.`;
        };

        // ===== AI TRADING COACH =====
        // Generates personalized insights from journal data

        const DAY_NAMES = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

        // Deep analysis of a SINGLE trade
        const analyzeIndividualTrade = (trade, allTrades = [], personality = 'homie') => {
            // Safety check for missing trade data
            if (!trade || !trade.ticker) {
                return {
                    summary: 'Unable to analyze - missing trade data.',
                    grade: { grade: 'N/A', color: 'text-gray-400' },
                    insights: [],
                    improvements: [],
                    positives: []
                };
            }

            const analysis = {
                summary: '',
                grade: gradeJournalTrade(trade),
                insights: [],
                improvements: [],
                positives: []
            };

            const isWin = (trade.pnl || 0) > 0;
            const pnlAbs = Math.abs(trade.pnl || 0);
            const rMultiple = trade.riskAmount ? (trade.pnl || 0) / trade.riskAmount : null;
            const mistakes = trade.mistakes || [];
            const hasMistakes = mistakes.length > 0 && !mistakes.includes('none');

            // Calculate trade duration (with safety checks)
            const entryTime = trade.entryDate ? new Date(trade.entryDate) : new Date();
            const exitTime = trade.exitDate ? new Date(trade.exitDate) : entryTime;
            const durationMs = Math.max(0, exitTime - entryTime);
            const durationMins = Math.round(durationMs / 60000);
            const durationHours = (durationMs / 3600000).toFixed(1);

            // Day of week (with safety check)
            const dayOfWeek = DAY_NAMES[entryTime.getDay()] || 'Unknown';
            const hour = entryTime.getHours() || 12;
            const timeOfDay = hour < 10 ? 'market open' : hour < 12 ? 'mid-morning' : hour < 14 ? 'lunch hours' : 'afternoon';

            // Compare to similar trades (same setup, same ticker)
            const sameSetupTrades = allTrades.filter(t => t.setup === trade.setup && t.id !== trade.id);
            const sameTickerTrades = allTrades.filter(t => t.ticker === trade.ticker && t.id !== trade.id);

            // === BUILD INSIGHTS ===

            // 1. Entry Timing
            if (hour >= 9 && hour < 10) {
                if (isWin) {
                    analysis.positives.push({
                        title: 'Good Open Play',
                        detail: `Caught momentum at market open (${hour}:${entryTime.getMinutes().toString().padStart(2, '0')}). This is high-volatility time and you played it right.`
                    });
                } else {
                    analysis.insights.push({
                        title: 'Risky Open Entry',
                        detail: `Entered during the chaotic first 30 minutes. Opening volatility can be unpredictable - consider waiting for the dust to settle.`
                    });
                }
            }

            // 2. Trade Duration Analysis
            if (durationMins < 5 && isWin) {
                analysis.positives.push({
                    title: 'Quick Scalp',
                    detail: `In and out in ${durationMins} minutes. Clean execution, didn't overstay your welcome.`
                });
            } else if (durationMins < 5 && !isWin) {
                analysis.insights.push({
                    title: 'Fast Stop Out',
                    detail: `Stopped out in ${durationMins} minutes. Was this a real setup or chasing? Review your entry trigger.`
                });
            } else if (durationMins > 120 && !isWin) {
                analysis.improvements.push({
                    title: 'Held Too Long?',
                    detail: `${durationHours} hours in a losing trade. Did you have a time stop? Sometimes the best move is to cut and re-evaluate.`
                });
            }

            // 2b. Trade Style vs Duration Mismatch Analysis
            const tradeStyle = trade.tradeStyle || 'day'; // default to day trade
            const isOptions = trade.assetType === 'option';
            const tradeDurationDays = durationMins / 1440; // convert to days

            // Detect potential 0DTE (options that close same day they opened, or very short duration)
            const sameDay = entryTime.toDateString() === exitTime.toDateString();
            const is0DTE = isOptions && sameDay && durationMins < 360; // Options closed same day within 6 hours = likely 0DTE

            if (is0DTE) {
                // 0DTE Mode - Maximum Urgency
                if (!isWin) {
                    analysis.insights.push({
                        title: '‚ö° 0DTE Alert',
                        detail: `0DTE options are BRUTAL - theta decay accelerates exponentially. That ${durationMins < 60 ? durationMins + ' minute' : durationHours + ' hour'} hold cost you with time decay eating into your position. 0DTE = surgical precision or get sliced.`
                    });
                } else if (isWin && durationMins > 60) {
                    analysis.insights.push({
                        title: '‚ö° 0DTE Survived',
                        detail: `You held a 0DTE for ${durationMins < 60 ? durationMins + ' mins' : durationHours + ' hours'} and won. Bold move. Just remember: every minute that passes, theta is eating your premium. Quick in, quick out on 0DTE.`
                    });
                }
            }

            // Scalp held too long
            if (tradeStyle === 'scalp' && durationMins > 30) {
                const scalpWarnings = [
                    `Uhhh... this "scalp" took ${durationMins} minutes. That's not a scalp anymore, that's a day trade in denial! üòÖ Scalps should be 5-15 min max. If it's not working fast, CUT IT.`,
                    `Yo this was supposed to be a scalp but it turned into a ${durationMins} minute hold. Either your thesis was wrong or you missed your exit. Scalps don't wait around!`,
                    `${durationMins} minutes on a "scalp"? That's like ordering espresso and sitting there for an hour. Scalps = quick momentum moves. If it stalls, you bounce.`
                ];
                if (durationMins > 60) {
                    // Held way too long for a scalp
                    analysis.improvements.push({
                        title: '‚ö° Scalp Identity Crisis',
                        detail: is0DTE
                            ? `${durationMins} mins on a 0DTE "scalp"?! With theta CRUSHING you every second?! This should've been a 5-10 min play or CUT. 0DTE scalps need LIGHTNING execution!`
                            : scalpWarnings[trade.id % scalpWarnings.length]
                    });
                } else {
                    analysis.insights.push({
                        title: '‚è±Ô∏è Scalp Timing',
                        detail: `${durationMins} min hold for a scalp is pushing it. True scalps are 5-15 minutes. Consider tighter time stops for quicker decision-making.`
                    });
                }
            }

            // Swing trade - calm panic sellers
            if (tradeStyle === 'swing' && !isWin) {
                const lossPercent = trade.riskAmount ? Math.abs(trade.pnl / trade.riskAmount) * 100 : 0;
                const pnlPercent = trade.entryPrice ? Math.abs((trade.exitPrice - trade.entryPrice) / trade.entryPrice * 100) : 0;

                // If loss is relatively small for a swing trade
                if (pnlPercent < 10 && tradeDurationDays < 5) {
                    // Short duration loss on swing = possible panic exit
                    const calmingMessages = [
                        `Breathe... this was a SWING trade. ${pnlPercent.toFixed(1)}% move on a multi-day/week thesis doesn't mean the trade is dead. Did you panic or was this a planned exit?`,
                        `Woooosah... üßò You labeled this a swing but exited in ${tradeDurationDays < 1 ? durationHours + ' hours' : Math.round(tradeDurationDays) + ' days'}. Swings need room to breathe. Small drawdowns are NORMAL.`,
                        `Hey, swing trades are supposed to be patient plays. Exiting after ${tradeDurationDays < 1 ? durationMins + ' mins' : Math.round(tradeDurationDays) + ' days'} with a ${pnlPercent.toFixed(1)}% loss? That's scalp behavior on a swing idea.`
                    ];
                    analysis.insights.push({
                        title: 'üåä Swing Trade Patience',
                        detail: isOptions
                            ? `${calmingMessages[trade.id % calmingMessages.length]} With options, you paid for TIME - use it! Unless it's a 0DTE, you have room.`
                            : calmingMessages[trade.id % calmingMessages.length]
                    });
                }
            }

            // LEAP / Long-term swing calming
            if (tradeStyle === 'swing' && isOptions && tradeDurationDays > 5 && !isWin) {
                const pnlPercent = trade.entryPrice ? Math.abs((trade.exitPrice - trade.entryPrice) / trade.entryPrice * 100) : 0;
                if (pnlPercent < 30) {
                    analysis.insights.push({
                        title: 'üìÖ Long-Term Options',
                        detail: `You held this options position for ${Math.round(tradeDurationDays)} days but took a ${pnlPercent.toFixed(0)}% loss. If this was a LEAP or longer-dated option, remember: you bought TIME. Unless fundamentals changed, early exits on long-dated options often look foolish in hindsight. Was this panic or conviction?`
                    });
                }
            }

            // 3. Risk Management
            if (rMultiple !== null) {
                if (rMultiple >= 2) {
                    analysis.positives.push({
                        title: 'Great R:R',
                        detail: `${rMultiple.toFixed(1)}R winner. You let this one run - that's how you build accounts.`
                    });
                } else if (rMultiple >= 1 && rMultiple < 2) {
                    analysis.positives.push({
                        title: 'Solid R:R',
                        detail: `${rMultiple.toFixed(1)}R - took what the market gave you. Consistency over home runs.`
                    });
                } else if (rMultiple < -1.5) {
                    analysis.improvements.push({
                        title: 'Large Loss',
                        detail: `${rMultiple.toFixed(1)}R loss. This exceeded your planned risk. Was your stop too wide or did you move it?`
                    });
                } else if (rMultiple >= -1 && rMultiple < 0) {
                    analysis.positives.push({
                        title: 'Controlled Loss',
                        detail: `${rMultiple.toFixed(1)}R - you kept the damage small. Good risk management.`
                    });
                }
            }

            // 4. Mistakes Analysis
            if (hasMistakes) {
                mistakes.forEach(m => {
                    const mistakeInfo = MISTAKE_TYPES.find(mt => mt.id === m);
                    if (mistakeInfo) {
                        const mistakeAdvice = {
                            'fomo': 'FOMO entries usually mean chasing. If you feel rushed, it\'s probably too late.',
                            'oversized': 'Position too big = emotions too big. Size down to think clearly.',
                            'no_stop': 'No stop = hoping. Hope is not a strategy. Always know your exit BEFORE entry.',
                            'moved_stop': 'Moving your stop to avoid a loss just creates a bigger loss. Trust your original analysis.',
                            'early_exit': 'Taking profits too early kills your R:R. Let winners breathe.',
                            'revenge': 'Revenge trading is giving money back. Walk away after a loss.',
                            'overtrading': 'More trades ‚â† more profits. Quality over quantity.',
                            'no_plan': 'No plan = gambling. Write down entry, stop, and target BEFORE you click buy.'
                        };
                        analysis.improvements.push({
                            title: `${mistakeInfo.emoji} ${mistakeInfo.label}`,
                            detail: mistakeAdvice[m] || `You flagged ${mistakeInfo.label} as a mistake. Be mindful of this pattern.`
                        });
                    }
                });
            }

            // 5. Plan Adherence
            if (trade.followedPlan) {
                if (isWin) {
                    analysis.positives.push({
                        title: 'Followed Your Plan',
                        detail: 'You stuck to your rules AND won. This is peak trading - process over outcome.'
                    });
                } else {
                    analysis.positives.push({
                        title: 'Good Process, Bad Outcome',
                        detail: 'You followed your plan but lost. That\'s okay - variance happens. Trust your edge over time.'
                    });
                }
            } else {
                if (isWin) {
                    analysis.insights.push({
                        title: 'Won Despite Breaking Rules',
                        detail: 'You made money but didn\'t follow your plan. This is dangerous - you\'re training bad habits.'
                    });
                } else {
                    analysis.improvements.push({
                        title: 'Didn\'t Follow Plan',
                        detail: 'Lost AND broke your rules. This is a double L. What made you deviate?'
                    });
                }
            }

            // 6. Emotional State Impact
            if (trade.emotionBefore) {
                const emotionInfo = EMOTIONS.find(e => e.id === trade.emotionBefore);
                if (['fearful', 'anxious', 'frustrated'].includes(trade.emotionBefore) && !isWin) {
                    analysis.insights.push({
                        title: 'Traded in Bad Headspace',
                        detail: `You entered feeling ${emotionInfo?.label || trade.emotionBefore}. Negative emotions before a trade often lead to poor decisions. Consider not trading when you feel this way.`
                    });
                } else if (['confident', 'focused', 'calm'].includes(trade.emotionBefore) && isWin) {
                    analysis.positives.push({
                        title: 'Right Mindset',
                        detail: `Entered feeling ${emotionInfo?.label || trade.emotionBefore} and executed well. This is your ideal trading state.`
                    });
                }
            }

            // 7. Setup Performance (compare to other trades with same setup)
            if (sameSetupTrades.length >= 2) {
                const setupWinRate = sameSetupTrades.filter(t => t.pnl > 0).length / sameSetupTrades.length * 100;
                const setupAvgPnl = sameSetupTrades.reduce((sum, t) => sum + t.pnl, 0) / sameSetupTrades.length;
                const setupInfo = SETUP_TYPES.find(s => s.id === trade.setup);

                if (setupWinRate < 40) {
                    analysis.insights.push({
                        title: 'Struggling Setup',
                        detail: `Your ${setupInfo?.label || trade.setup} setup has a ${setupWinRate.toFixed(0)}% win rate (${sameSetupTrades.length} trades). Consider refining your criteria or dropping this setup.`
                    });
                } else if (setupWinRate > 60) {
                    analysis.positives.push({
                        title: 'Strong Setup',
                        detail: `${setupInfo?.label || trade.setup} is working for you - ${setupWinRate.toFixed(0)}% win rate over ${sameSetupTrades.length} trades. Keep trading it.`
                    });
                }
            }

            // 8. Ticker History
            if (sameTickerTrades.length >= 2) {
                const tickerWinRate = sameTickerTrades.filter(t => t.pnl > 0).length / sameTickerTrades.length * 100;
                const tickerTotalPnl = sameTickerTrades.reduce((sum, t) => sum + t.pnl, 0);

                if (tickerTotalPnl < -100) {
                    analysis.insights.push({
                        title: `${trade.ticker} Not Your Friend`,
                        detail: `You're down $${Math.abs(tickerTotalPnl).toFixed(2)} on ${trade.ticker} over ${sameTickerTrades.length} trades. This ticker doesn't match your style.`
                    });
                } else if (tickerTotalPnl > 100 && tickerWinRate > 50) {
                    analysis.positives.push({
                        title: `${trade.ticker} Is Your Ticker`,
                        detail: `+$${tickerTotalPnl.toFixed(2)} on ${trade.ticker} with ${tickerWinRate.toFixed(0)}% win rate. You read this one well.`
                    });
                }
            }

            // === TRADING IN THE ZONE - Mark Douglas Wisdom ===
            // 9. The 5 Fundamental Truths & Probabilistic Mindset

            // Truth #1: Anything can happen - applies to unexpected outcomes
            if (isWin && hasMistakes) {
                const zoneInsights = [
                    `Mark Douglas reminds us: "Anything can happen." This win despite mistakes was random variance - NOT skill. The market will correct this luck.`,
                    `"Trading in the Zone" truth: You don't need to know what will happen to make money. But winning with poor process trains bad habits.`,
                    `Remember the 5 Fundamental Truths: there's a random distribution between wins and losses. This win was variance, not edge.`
                ];
                analysis.insights.push({
                    title: 'üìö Zone Check: Lucky Win',
                    detail: zoneInsights[trade.id % zoneInsights.length]
                });
            }

            // Truth #3: Random distribution - applies to loss streaks
            const recentTrades = allTrades.slice(-5);
            const recentLosses = recentTrades.filter(t => t.pnl < 0).length;
            const recentWins = recentTrades.filter(t => t.pnl > 0).length;

            if (recentLosses >= 3 && !isWin) {
                const streakInsights = [
                    `"There's a random distribution between wins and losses." You're in a losing streak - this is NORMAL. Your edge plays out over many trades, not the next one.`,
                    `Mark Douglas: "Every moment in the market is unique." This loss is not connected to the previous ones. Don't let the streak affect your next decision.`,
                    `From Trading in the Zone: Losing streaks are part of the game. Your job is to execute YOUR system, not predict which trade will win.`
                ];
                analysis.insights.push({
                    title: 'üìö Zone Check: Losing Streak',
                    detail: streakInsights[trade.id % streakInsights.length]
                });
            }

            // Accepting risk - if position was oversized or no stop
            if (mistakes.includes('oversized') || mistakes.includes('no_stop')) {
                const riskInsights = [
                    `"You must completely accept the risk." If you had truly accepted it, you wouldn't have oversized or skipped your stop. Accepting risk = peace with any outcome.`,
                    `Mark Douglas: "The best traders have learned to accept risk." Your sizing/stop issues suggest fear of missing out overpowered fear of losing.`,
                    `Trading in the Zone: "Risk acceptance is the cornerstone of a winning attitude." You weren't truly okay losing this money when you entered.`
                ];
                analysis.improvements.push({
                    title: 'üìö Zone: Risk Acceptance',
                    detail: riskInsights[trade.id % riskInsights.length]
                });
            }

            // Fear of missing out (FOMO)
            if (mistakes.includes('fomo')) {
                analysis.insights.push({
                    title: 'üìö Zone: Fear of Missing Out',
                    detail: `Mark Douglas identifies FOMO as "fear of leaving money on the table." The market offers endless opportunities. Missing one trade means NOTHING. There's always another.`
                });
            }

            // Early exit - fear of giving back profits
            if (mistakes.includes('early_exit')) {
                analysis.insights.push({
                    title: 'üìö Zone: Fear of Giving Back',
                    detail: `"Fear of giving back profits" made you exit early. Douglas says: "Let your winners run and cut your losers short." Your fear inverted this rule.`
                });
            }

            // Revenge trading - not accepting the loss
            if (mistakes.includes('revenge')) {
                analysis.improvements.push({
                    title: 'üìö Zone: Not Accepting Loss',
                    detail: `Revenge trading = refusing to accept the loss. Douglas: "The best traders don't try to get their money back from the market." Each trade is independent. The market owes you nothing.`
                });
            }

            // Great execution - in the zone
            if (trade.followedPlan && analysis.improvements.length === 0) {
                const zonePositives = [
                    `This is what "the zone" looks like - you executed without emotional interference. Process over outcome. Douglas would be proud.`,
                    `Mark Douglas: "Consistency is the result of a carefree, objective state of mind." You demonstrated that here. No fear, no greed - just execution.`,
                    `"Trading in the Zone" defines it as: uncertainty with equanimity. You accepted the risk, followed your rules, and let the market do its thing. A+.`
                ];
                analysis.positives.push({
                    title: 'üìö In The Zone',
                    detail: zonePositives[trade.id % zonePositives.length]
                });
            }

            // Process over outcome - good loss
            if (!isWin && trade.followedPlan && rMultiple && rMultiple >= -1.5) {
                const processInsights = [
                    `Douglas: "Winning and losing have NOTHING to do with being right or wrong." You followed your process - the outcome is irrelevant to your development as a trader.`,
                    `"Trading in the Zone": Focus on executing well, not on the outcome. This loss with proper process is more valuable than a lucky win.`,
                    `Mark Douglas reminds us: you can't control outcomes, only process. You executed your plan. The market did what it does. Move on.`
                ];
                analysis.positives.push({
                    title: 'üìö Zone: Process > Outcome',
                    detail: processInsights[trade.id % processInsights.length]
                });
            }

            // Emotional state - detecting potential tilt
            if (['frustrated', 'angry', 'fearful'].includes(trade.emotionBefore) && ['frustrated', 'angry', 'devastated'].includes(trade.emotionAfter)) {
                analysis.improvements.push({
                    title: 'üìö Zone: Emotional Interference',
                    detail: `You entered negative and exited worse. Douglas: "Negative emotional energy eliminates our ability to perceive opportunity." Consider stepping away when emotions are high.`
                });
            }

            // Euphoria warning
            if (trade.emotionAfter === 'euphoric') {
                analysis.insights.push({
                    title: 'üìö Zone: Euphoria Warning',
                    detail: `Douglas warns about euphoria: it creates the expectation of easy money, leading to oversized bets and rule-breaking. Ground yourself. This win changes nothing about your edge.`
                });
            }

            // === THE DISCIPLINED TRADER - Mark Douglas (his first book) ===
            // 10. Self-discipline and mental framework insights

            // Gap between knowing and doing
            if (!trade.followedPlan && hasMistakes) {
                const disciplineInsights = [
                    `"The Disciplined Trader": There's a gap between KNOWING what to do and DOING it. You knew better. Bridge that gap or keep paying tuition.`,
                    `Douglas (Disciplined Trader): "Taking responsibility means acknowledging that YOUR beliefs create your results." You broke your rules - own it.`,
                    `From The Disciplined Trader: Self-discipline isn't about willpower, it's about having beliefs that SUPPORT your rules. Examine why you deviated.`
                ];
                analysis.improvements.push({
                    title: 'üìï Disciplined Trader: Know vs Do',
                    detail: disciplineInsights[trade.id % disciplineInsights.length]
                });
            }

            // Mental flexibility - adapting to what the market gives
            if (mistakes.includes('moved_stop')) {
                analysis.improvements.push({
                    title: 'üìï Disciplined Trader: Rigidity',
                    detail: `Douglas: "Rigid beliefs about what the market should do cause traders to move stops and fight the tape." The market doesn't care what you think SHOULD happen. Accept what IS.`
                });
            }

            // Taking responsibility
            if (!isWin && !trade.followedPlan) {
                const responsibilityInsights = [
                    `"The Disciplined Trader": Take 100% responsibility. Not the market maker, not the algorithms, not bad luck - YOU made this trade.`,
                    `Douglas: "Winners take complete responsibility. Losers blame external factors." What could YOU have done differently?`
                ];
                analysis.insights.push({
                    title: 'üìï Disciplined Trader: Responsibility',
                    detail: responsibilityInsights[trade.id % responsibilityInsights.length]
                });
            }

            // === HIGH PROBABILITY TRADING - Marcel Link ===
            // 11. Setup quality and patience

            // Overtrading detection
            const todayTrades = allTrades.filter(t => {
                const tDate = new Date(t.entryDate).toDateString();
                const thisDate = new Date(trade.entryDate).toDateString();
                return tDate === thisDate;
            });

            if (todayTrades.length > 5) {
                const overtradingInsights = [
                    `Marcel Link (High Probability Trading): "Overtrading is the silent account killer." ${todayTrades.length} trades today? Quality over quantity. The best trade is sometimes NO trade.`,
                    `From High Probability Trading: "Wait for the A+ setup. Skip the B's and C's." Were ALL ${todayTrades.length} of today's trades truly A+ setups?`,
                    `Link says: "Patience is a trading SKILL, not a personality trait." ${todayTrades.length} trades suggests you're forcing it. Wait for YOUR pitch.`
                ];
                analysis.improvements.push({
                    title: 'üìó High Prob: Overtrading',
                    detail: overtradingInsights[trade.id % overtradingInsights.length]
                });
            }

            // Setup type + outcome analysis for probability
            if (trade.setup === 'momentum' && !isWin) {
                analysis.insights.push({
                    title: 'üìó High Prob: Momentum Chasing',
                    detail: `Marcel Link: "Chasing momentum is a low-probability play. By the time you see it, smart money is exiting." Wait for pullbacks to support, not breakouts already extended.`
                });
            }

            // No plan = low probability
            if (mistakes.includes('no_plan')) {
                analysis.improvements.push({
                    title: 'üìó High Prob: No Plan = Gambling',
                    detail: `Link: "Every trade needs entry, stop, and target BEFORE you click buy. Without a plan, you're just gambling with extra steps." Write it down next time.`
                });
            }

            // Good setup recognition
            if (trade.followedPlan && isWin && rMultiple && rMultiple >= 2) {
                analysis.positives.push({
                    title: 'üìó High Prob: A+ Execution',
                    detail: `Marcel Link would approve: you waited for your setup, followed your plan, and let it run to ${rMultiple.toFixed(1)}R. THIS is high probability trading.`
                });
            }

            // === DAYTRADING FOR DUMMIES - Ann Logue ===
            // 12. Practical day trading wisdom

            // Position sizing check
            if (trade.riskAmount && pnlAbs > trade.riskAmount * 2 && !isWin) {
                analysis.improvements.push({
                    title: 'üìò DTD: Risk Management',
                    detail: `Daytrading for Dummies rule: "Never risk more than 1-2% of your account on a single trade." You lost ${(pnlAbs / trade.riskAmount).toFixed(1)}x your planned risk. That's how accounts blow up.`
                });
            }

            // Lunch hour trading
            if (hour >= 11 && hour < 14 && !isWin) {
                const lunchInsights = [
                    `Daytrading for Dummies: "The lunch hours (11am-2pm) have lower volume and more choppy action." This is when smart money takes breaks. Should you?`,
                    `From DTD: "Avoid the midday lull unless you have a specific thesis." Volume dries up, spreads widen, and fakeouts increase.`
                ];
                analysis.insights.push({
                    title: 'üìò DTD: Lunch Hour Warning',
                    detail: lunchInsights[trade.id % lunchInsights.length]
                });
            }

            // Fees impact
            if (trade.fees && trade.fees > pnlAbs * 0.1 && isWin) {
                analysis.insights.push({
                    title: 'üìò DTD: Fees Eating Profits',
                    detail: `Daytrading for Dummies warns: "Commissions and fees can eat 10-20% of day trading profits." Your fees were ${((trade.fees / pnlAbs) * 100).toFixed(0)}% of this win. Consider position sizing.`
                });
            }

            // Earnings/news play
            if (trade.setup === 'earnings' && !isWin) {
                analysis.improvements.push({
                    title: 'üìò DTD: Earnings Gamble',
                    detail: `Daytrading for Dummies: "Trading earnings without a specific strategy is gambling, not trading." Binary events are unpredictable. Either have a defined edge or stay out.`
                });
            }

            // Beginner's luck trap - win streak
            if (recentWins >= 4 && isWin) {
                analysis.insights.push({
                    title: 'üìò DTD: Hot Streak Warning',
                    detail: `Daytrading for Dummies warns of "beginner's luck" and hot streaks. ${recentWins} wins in a row feels great but can lead to overconfidence and oversizing. Stay humble, stay sized.`
                });
            }

            // Stop loss discipline
            if (trade.followedPlan && !isWin && rMultiple && rMultiple >= -1) {
                analysis.positives.push({
                    title: 'üìò DTD: Stop Discipline',
                    detail: `Daytrading for Dummies: "Your stop loss is your best friend." You honored it and kept the loss to ${rMultiple.toFixed(1)}R. This discipline will save your account long-term.`
                });
            }

            // === JESSE LIVERMORE - Reminiscences of a Stock Operator ===
            // The greatest speculator who ever lived - lessons from his wins AND his losses

            // Patience and waiting for the right moment
            if (trade.followedPlan && isWin && rMultiple && rMultiple >= 2) {
                const livermoreWinInsights = [
                    `Jesse Livermore: "It was never my thinking that made the big money for me. It was always my sitting." You sat through this trade to ${rMultiple.toFixed(1)}R - that's where the real money is.`,
                    `Livermore: "The big money is not in the buying and selling, but in the waiting." You waited for your setup, executed, and let it work. ${rMultiple.toFixed(1)}R is your reward.`,
                    `"Reminiscences of a Stock Operator": Money is made by sitting, not trading. This ${rMultiple.toFixed(1)}R winner came from patience, not overactivity.`
                ];
                analysis.positives.push({
                    title: 'üìñ Livermore: Sitting Tight',
                    detail: livermoreWinInsights[trade.id % livermoreWinInsights.length]
                });
            }

            // Being right too early is the same as being wrong
            if (!isWin && durationMins < 30 && trade.followedPlan) {
                const livermoreTimingInsights = [
                    `Livermore: "Being right too early is the same as being wrong." Your thesis might be correct - but timing is everything. Markets can stay irrational longer than you can stay solvent.`,
                    `Jesse Livermore learned the hard way: "The market will go your way eventually... AFTER it stops you out first." The thesis matters, but so does the timing.`,
                    `"Reminiscences": Even Livermore got stopped out before big moves. Being early IS being wrong in trading. Wait for the market to confirm YOUR timing.`
                ];
                analysis.insights.push({
                    title: 'üìñ Livermore: Timing',
                    detail: livermoreTimingInsights[trade.id % livermoreTimingInsights.length]
                });
            }

            // Adding to winners, not losers
            if (mistakes.includes('oversized') && !isWin) {
                analysis.improvements.push({
                    title: 'üìñ Livermore: Pyramiding',
                    detail: `Livermore: "Always sell what shows you a loss and keep what shows you a profit." NEVER average down on losers. Add to WINNERS only. You did the opposite.`
                });
            }

            // Market always wins
            if (mistakes.includes('moved_stop') || (rMultiple && rMultiple < -2)) {
                const livermoreHumilityInsights = [
                    `Livermore: "The market is designed to fool most of the people most of the time." Don't fight it. When you're wrong, you're wrong. Cut and reassess.`,
                    `Jesse Livermore went bankrupt FOUR times despite being a legend. Why? Fighting the tape. "When the market speaks, listen." Your stop was your plan - honor it.`,
                    `"Reminiscences": Livermore's biggest losses came from stubbornness. "A loss never bothers me after I take it... It's being wrong and not taking the loss that damages the pocket and the soul."`
                ];
                analysis.improvements.push({
                    title: 'üìñ Livermore: Humility',
                    detail: livermoreHumilityInsights[trade.id % livermoreHumilityInsights.length]
                });
            }

            // Trend following
            if (trade.setup === 'trend' || trade.setup === 'breakout') {
                if (isWin) {
                    analysis.positives.push({
                        title: 'üìñ Livermore: Trend',
                        detail: `Livermore: "Trade in the direction of the general market." You identified the trend and rode it. "${trade.setup === 'breakout' ? 'Breakouts' : 'Trend trades'} in the direction of the bigger move" - exactly what Jesse would do.`
                    });
                } else {
                    analysis.insights.push({
                        title: 'üìñ Livermore: Trend Check',
                        detail: `Livermore: "Don't fight the tape." Before your next ${trade.setup} play, ask: "Is the GENERAL market supporting this direction?" Individual stocks can't swim against the tide forever.`
                    });
                }
            }

            // FOMO and chasing
            if (mistakes.includes('fomo')) {
                analysis.improvements.push({
                    title: 'üìñ Livermore: FOMO',
                    detail: `Livermore: "There is only one side to the stock market... not the bull side or the bear side, but the RIGHT side." FOMO puts you on the CROWD side, not the right side. Wait for YOUR setup.`
                });
            }

            // Revenge trading / trying to get it back
            if (mistakes.includes('revenge')) {
                analysis.improvements.push({
                    title: 'üìñ Livermore: Revenge',
                    detail: `Jesse Livermore's final lesson: he lost everything trying to "get it back." The market owes you NOTHING. Each trade stands alone. Revenge trading killed the greatest speculator who ever lived.`
                });
            }

            // === WILLIAM O'NEIL - CANSLIM & How to Make Money in Stocks ===
            // Founder of Investor's Business Daily - systematic growth stock investing

            // Cutting losses short - the 7-8% rule
            if (!isWin && rMultiple && rMultiple >= -1 && rMultiple < 0) {
                const oneilCutLossInsights = [
                    `William O'Neil: "Cut ALL losses at 7-8%, no exceptions." You kept this to ${Math.abs(rMultiple * 100 / 7).toFixed(0)}% of O'Neil's max loss rule. EXACTLY right.`,
                    `O'Neil (CANSLIM): "The whole secret to winning in the stock market is to lose the least amount possible when you're wrong." Small loss = survival.`,
                    `"How to Make Money in Stocks": O'Neil studied every market winner for 100+ years. They ALL had one thing in common: cutting losers FAST. You did that here.`
                ];
                analysis.positives.push({
                    title: 'üìï O\'Neil: Cut Losses',
                    detail: oneilCutLossInsights[trade.id % oneilCutLossInsights.length]
                });
            }

            // Let winners run - O'Neil's hold rules
            if (isWin && rMultiple && rMultiple >= 3) {
                analysis.positives.push({
                    title: 'üìï O\'Neil: Let It Run',
                    detail: `William O'Neil: "The winning stocks you own should be held as long as they continue to rise." ${rMultiple.toFixed(1)}R means you let this winner BREATHE. Most traders would've cut at 1R out of fear.`
                });
            }

            // Don't buy on the way down
            if (mistakes.includes('oversized') || (trade.setup === 'reversal' && !isWin)) {
                analysis.insights.push({
                    title: 'üìï O\'Neil: Don\'t Catch Knives',
                    detail: `O'Neil: "Never buy a stock on the way down trying to get a bargain." He studied THOUSANDS of winners - they break OUT, not down. Buy strength, not weakness.`
                });
            }

            // Volume confirmation
            if (trade.setup === 'breakout') {
                const oneilVolumeInsights = isWin
                    ? `O'Neil (CANSLIM): "Volume is your best friend." Breakouts need volume confirmation. If this had heavy volume, that's institutional buying - smart money agrees with you.`
                    : `William O'Neil: "Breakouts that fail usually lack volume." Check next time: was there 50%+ above-average volume? Without institutions buying, breakouts fade.`;
                analysis.insights.push({
                    title: 'üìï O\'Neil: Volume',
                    detail: oneilVolumeInsights
                });
            }

            // Market direction - most important factor
            if (!isWin && todayTrades.length >= 3) {
                const todayLosses = todayTrades.filter(t => t.pnl < 0).length;
                if (todayLosses >= 2) {
                    analysis.improvements.push({
                        title: 'üìï O\'Neil: Market Direction',
                        detail: `O'Neil: "3 out of 4 stocks follow the market direction." You had ${todayLosses} losses today out of ${todayTrades.length} trades. Check: is the MARKET in an uptrend? If not, even good stocks will fail.`
                    });
                }
            }

            // Holding through earnings
            if (trade.setup === 'earnings') {
                const oneilEarningsInsights = isWin
                    ? `O'Neil allows holding through earnings IF: the stock is up 20%+ from buy point AND market is strong. Did this meet those criteria?`
                    : `William O'Neil: "Sell BEFORE earnings unless you're up big." Earnings are binary events. Even great companies disappoint. You gambled, not traded.`;
                analysis.insights.push({
                    title: 'üìï O\'Neil: Earnings',
                    detail: oneilEarningsInsights
                });
            }

            // The N in CANSLIM - New highs
            if (trade.setup === 'breakout' && isWin) {
                analysis.positives.push({
                    title: 'üìï O\'Neil: New Highs',
                    detail: `CANSLIM "N" = New highs. O'Neil: "Stocks making new highs tend to go higher. Stocks making new lows tend to go lower." You bought strength. That's how winners trade.`
                });
            }

            // === OLIVER KELL - US Investing Championship Winner ===
            // Price action master, breakout specialist, swing trader

            // Breakout execution
            if (trade.setup === 'breakout') {
                if (isWin && rMultiple && rMultiple >= 1.5) {
                    const kellBreakoutInsights = [
                        `Oliver Kell: "The best breakouts resolve quickly." This ${rMultiple.toFixed(1)}R winner shows you caught a REAL breakout - not a fakeout.`,
                        `Kell (US Investing Champ): "I want to see immediate follow-through after I enter." Your breakout followed through. That's the sign of institutional demand.`,
                        `Oliver Kell's rule: "If a breakout doesn't work in 2-3 days, something's wrong." This one WORKED. You read the setup correctly.`
                    ];
                    analysis.positives.push({
                        title: 'üèÜ Kell: Breakout',
                        detail: kellBreakoutInsights[trade.id % kellBreakoutInsights.length]
                    });
                } else if (!isWin) {
                    const kellFailedBreakoutInsights = [
                        `Oliver Kell: "Failed breakouts are the market telling you something. Listen." Not all breakouts work - the key is cutting when they don't.`,
                        `Kell: "I want immediate follow-through. If a stock stalls or reverses on the breakout day, I'm out." Did you wait too long to cut this?`,
                        `Oliver Kell loses on breakouts too. His edge? "I cut fast and move on. There's always another setup." Don't dwell on this one.`
                    ];
                    analysis.insights.push({
                        title: 'üèÜ Kell: Failed Breakout',
                        detail: kellFailedBreakoutInsights[trade.id % kellFailedBreakoutInsights.length]
                    });
                }
            }

            // Tight price action and volatility contraction
            if (trade.setup === 'consolidation' || trade.setup === 'flag') {
                analysis.positives.push({
                    title: 'üèÜ Kell: VCP',
                    detail: `Oliver Kell loves volatility contraction patterns (VCPs). "${trade.setup === 'flag' ? 'Flags' : 'Consolidations'} with tightening price action = coiled spring." Less noise, cleaner setup, better odds.`
                });
            }

            // Position sizing based on conviction
            if (trade.riskAmount && isWin && rMultiple && rMultiple >= 2) {
                analysis.positives.push({
                    title: 'üèÜ Kell: Conviction',
                    detail: `Oliver Kell: "I size up on my highest conviction setups." ${rMultiple.toFixed(1)}R winner - if this was a high-conviction trade, you should've sized bigger. Next time, scale into winners.`
                });
            }

            // Relative strength
            if (isWin) {
                analysis.insights.push({
                    title: 'üèÜ Kell: Relative Strength',
                    detail: `Oliver Kell screens for stocks showing RELATIVE STRENGTH vs the market. "If SPY is down and your stock is flat or up - that's a leader." Was ${trade.ticker} showing relative strength?`
                });
            }

            // Cut losers fast - Kell's discipline
            if (!isWin && rMultiple && rMultiple >= -0.5) {
                analysis.positives.push({
                    title: 'üèÜ Kell: Quick Cut',
                    detail: `Oliver Kell: "My average loss is tiny because I cut immediately when wrong." ${rMultiple.toFixed(1)}R loss is EXACTLY what a champion does. Preserve capital for the next A+ setup.`
                });
            }

            // === PAUL TUDOR JONES - Macro Legend ===
            // Risk management and capital preservation master

            // Risk management excellence
            if (trade.riskAmount && !isWin && rMultiple && rMultiple >= -1) {
                const ptjRiskInsights = [
                    `Paul Tudor Jones: "The most important rule of trading is to play great defense, not great offense." You defended your capital. ${rMultiple.toFixed(1)}R loss is professional.`,
                    `PTJ: "I'm always thinking about losing money as opposed to making money." This loss was CONTROLLED. That's how you survive long enough to catch the big winners.`,
                    `Paul Tudor Jones keeps a "LOSER" photo above his desk. Why? To remember: "The single most important thing is capital preservation." You preserved yours.`
                ];
                analysis.positives.push({
                    title: 'üíº PTJ: Defense',
                    detail: ptjRiskInsights[trade.id % ptjRiskInsights.length]
                });
            }

            // Losing positions - get out
            if (mistakes.includes('moved_stop') || (rMultiple && rMultiple < -2)) {
                analysis.improvements.push({
                    title: 'üíº PTJ: Losers',
                    detail: `Paul Tudor Jones: "Losers average losers." Don't add to losing positions. Don't move stops. "If something doesn't feel right, get out. You can always get back in."`
                });
            }

            // Market cycles awareness
            if (!isWin && todayTrades.filter(t => t.pnl < 0).length >= 2) {
                analysis.insights.push({
                    title: 'üíº PTJ: Cycles',
                    detail: `PTJ: "Markets have cycles. Don't fight them." Multiple losses today might mean the ENVIRONMENT is wrong, not your setups. Sometimes the best trade is no trade.`
                });
            }

            // === ED SEYKOTA - Trend Following Pioneer ===
            // Systems trader, emotional discipline expert

            // Trend following
            if ((trade.setup === 'trend' || trade.setup === 'momentum') && isWin) {
                analysis.positives.push({
                    title: 'üåä Seykota: Trend',
                    detail: `Ed Seykota: "The trend is your friend until the end." You rode this trend for ${rMultiple?.toFixed(1) || 'a solid'}R. Seykota made hundreds of millions doing exactly this.`
                });
            }

            // Cutting losses - Seykota's rules
            if (!isWin && trade.followedPlan) {
                const seykotaRules = [
                    `Ed Seykota's rules: "1) Cut losses. 2) Ride winners. 3) Keep bets small. 4) Follow the rules without question." You followed rule #1. Most can't.`,
                    `Seykota: "There are old traders and there are bold traders, but there are very few old, bold traders." Cutting this loss keeps you in the old trader category.`,
                    `Ed Seykota: "Win or lose, everybody gets what they want out of the market." You wanted discipline. You got it. The P&L is secondary.`
                ];
                analysis.positives.push({
                    title: 'üåä Seykota: Rules',
                    detail: seykotaRules[trade.id % seykotaRules.length]
                });
            }

            // Emotional awareness
            if (trade.emotionBefore && ['fearful', 'anxious', 'frustrated'].includes(trade.emotionBefore)) {
                analysis.insights.push({
                    title: 'üåä Seykota: Psychology',
                    detail: `Ed Seykota: "Win or lose, everybody gets what they want out of the market. Some people seem to like to lose, so they win by losing money." You entered ${trade.emotionBefore}. Was that subconsciously setting up a loss?`
                });
            }

            // Position sizing
            if (mistakes.includes('oversized')) {
                analysis.improvements.push({
                    title: 'üåä Seykota: Bet Size',
                    detail: `Seykota: "Risk no more than you can afford to lose, and also risk enough so that a win is meaningful." You oversized - that's fear of missing out overpowering risk management.`
                });
            }

            // === LINDA RASCHKE - Professional Trader ===
            // Short-term trading, price action, trader psychology

            // Quick execution
            if (isWin && durationMins < 60 && trade.followedPlan) {
                analysis.positives.push({
                    title: '‚ö° Raschke: Execution',
                    detail: `Linda Raschke: "Good traders take what the market gives them and don't overstay their welcome." ${durationMins} minute trade, clean entry/exit. This is professional execution.`
                });
            }

            // Missed exits
            if (!isWin && (mistakes.includes('early_exit') || mistakes.includes('moved_stop'))) {
                const raschkeExitInsights = [
                    `Linda Raschke: "An exit is more important than an entry." You had an exit plan - but you deviated. The best traders are GREAT at exits, not entries.`,
                    `Raschke: "Your first loss is your best loss." You didn't take it. Now you have a bigger one. Trust your initial read next time.`
                ];
                analysis.improvements.push({
                    title: '‚ö° Raschke: Exit',
                    detail: raschkeExitInsights[trade.id % raschkeExitInsights.length]
                });
            }

            // Adapting to conditions
            if (!isWin && todayTrades.filter(t => t.pnl < 0).length >= 2) {
                analysis.insights.push({
                    title: '‚ö° Raschke: Adapt',
                    detail: `Linda Raschke: "If the market environment doesn't fit your strategy, STOP TRADING. Wait for your market." Multiple losses today = maybe this isn't your environment.`
                });
            }

            // === RICHARD DENNIS - Turtle Trader ===
            // Proved trading can be taught, systematic approach

            // Following the system
            if (trade.followedPlan) {
                const dennisSystemInsights = isWin
                    ? `Richard Dennis (Turtle Trader): "Trade the system, not your gut." You followed your plan. Dennis turned $400 into $200M doing exactly this.`
                    : `Dennis: "The system will have losses. That's normal." You followed your rules despite the loss. That's how the Turtles made millions - not by winning every trade.`;
                analysis.positives.push({
                    title: 'üê¢ Dennis: System',
                    detail: dennisSystemInsights
                });
            }

            // Not following the system
            if (!trade.followedPlan && !isWin) {
                analysis.improvements.push({
                    title: 'üê¢ Dennis: Discipline',
                    detail: `Richard Dennis: "I could publish my trading rules in the newspaper and no one would follow them." Why? Because following rules is HARD. You broke yours. Was the deviation worth it?`
                });
            }

            // === BUILD SUMMARY - DYNAMICALLY BUILT UNIQUE MESSAGES ===
            const setupInfo = SETUP_TYPES.find(s => s.id === trade.setup);
            const setupName = setupInfo?.label || 'trade';
            // isOptions already declared above in trade style section
            const pnlStr = `${isWin ? '+' : '-'}$${pnlAbs.toFixed(2)}`;
            const rStr = rMultiple ? `${rMultiple.toFixed(1)}R` : '';

            // Price display - different for options vs stock
            const entryStr = isOptions ? `$${trade.entryPrice?.toFixed(2)}/contract` : `$${trade.entryPrice?.toFixed(2)}`;
            const exitStr = isOptions ? `$${trade.exitPrice?.toFixed(2)}/contract` : `$${trade.exitPrice?.toFixed(2)}`;
            const qtyStr = isOptions ? `${trade.quantity} contract${trade.quantity > 1 ? 's' : ''}` : `${trade.quantity} shares`;

            // Multiple hash sources for different parts of the message
            const tickerHash = trade.ticker.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
            const idHash = trade.id;
            const pnlHash = Math.abs(Math.floor(trade.pnl));
            const priceHash = Math.floor(trade.entryPrice * 100);

            // Generate UNIQUE summary by combining parts
            const generateUniqueSummary = (p) => {
                const ticker = trade.ticker;
                const grade = analysis.grade.grade;

                // Calculate specific trade details for personalized analysis
                const entryHour = new Date(trade.entryDate).getHours();
                const entryDay = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][new Date(trade.entryDate).getDay()];
                const holdMins = Math.round((new Date(trade.exitDate) - new Date(trade.entryDate)) / 60000);
                const holdTimeStr = holdMins < 60 ? `${holdMins} minutes` : `${(holdMins/60).toFixed(1)} hours`;
                const wasOpenPlay = entryHour >= 9 && entryHour < 10;
                const wasLunchTrade = entryHour >= 11 && entryHour < 14;
                const wasAfternoon = entryHour >= 14;
                const isScalp = trade.tradeStyle === 'scalp' || holdMins < 30;
                const isSwing = trade.tradeStyle === 'swing' || holdMins > 1440;
                const bigWin = rMultiple && rMultiple >= 2;
                const hugeWin = rMultiple && rMultiple >= 5;
                const perfectTrade = trade.followedPlan && analysis.improvements.length === 0;

                // Build unique context observations
                const getSpecificObservation = () => {
                    const observations = [];

                    if (hugeWin) observations.push(`A ${rMultiple.toFixed(1)}R winner is exceptional - this single trade justifies many small losses.`);
                    else if (bigWin) observations.push(`${rMultiple.toFixed(1)}R shows you let this one breathe instead of cutting early.`);

                    if (wasOpenPlay && isWin) observations.push(`Catching the opening momentum on ${entryDay} takes conviction.`);
                    if (wasLunchTrade && isWin) observations.push(`Winning during lunch hours - most traders avoid this period, but you read it correctly.`);
                    if (wasAfternoon && isWin) observations.push(`Afternoon execution when others are tired - you stayed sharp.`);

                    if (isScalp && isWin) observations.push(`Quick ${holdTimeStr} scalp, surgical precision.`);
                    if (isSwing && isWin) observations.push(`Holding for ${holdTimeStr} required patience most lack.`);

                    if (perfectTrade) observations.push(`Zero mistakes flagged - this is your A-game.`);
                    if (trade.setup === 'breakout' && isWin) observations.push(`Breakout trades are your bread and butter - keep hunting these.`);
                    if (trade.setup === 'reversal' && isWin) observations.push(`Catching reversals is contrarian by nature - you trusted your read.`);
                    if (trade.setup === 'gap_fill' && isWin) observations.push(`Gap fills require patience to let the thesis play out.`);

                    if (isOptions && isWin && holdMins < 120) observations.push(`Options in and out in ${holdTimeStr} - you didn't let theta eat your profits.`);
                    if (isOptions && bigWin) observations.push(`Options leverage amplified this win - same edge, bigger payoff.`);

                    return observations.length > 0 ? observations[priceHash % observations.length] : '';
                };

                if (p === 'oracle') {
                    const specificObs = getSpecificObservation();

                    // Multiple phrasings for variety - selected by different hashes
                    const openers = [
                        `${ticker}. ${setupName}. ${entryDay}.`,
                        `Let's break down ${ticker}:`,
                        `${isOptions ? 'Options on' : ''} ${ticker} (${entryDay}):`,
                        `${ticker} - ${isWin ? 'a winner' : 'a lesson'}:`,
                        `Looking at ${ticker}:`,
                        `${ticker}, ${setupName} setup:`,
                        `The ${ticker} ${isOptions ? 'options play' : 'trade'}:`,
                        `${setupName}: ${ticker} on ${entryDay}.`
                    ];
                    // Use combination of multiple unique factors for better distribution
                    const openerIndex = (trade.id + tickerHash + Math.floor(trade.entryPrice)) % openers.length;

                    const entryPhrases = [
                        `Entry at ${entryStr} ${wasOpenPlay ? 'amid opening volatility' : wasLunchTrade ? 'during the midday lull' : wasAfternoon ? 'in afternoon trading' : ''}, held ${holdTimeStr}.`,
                        `You positioned at ${entryStr} ${wasOpenPlay ? 'right at the bell' : wasLunchTrade ? 'when volume was thin' : wasAfternoon ? 'late in the session' : ''} for a ${holdTimeStr} hold.`,
                        `${entryStr} entry ${wasOpenPlay ? 'catching the open' : wasLunchTrade ? 'during quiet hours' : wasAfternoon ? 'in the PM' : ''}, ${holdTimeStr} duration.`,
                        `Bought at ${entryStr} ${wasOpenPlay ? 'on the opening move' : wasLunchTrade ? 'midday' : wasAfternoon ? 'afternoon' : ''} and held ${holdTimeStr}.`
                    ];

                    const exitPhrases = [
                        `Exit at ${exitStr} captured ${pnlStr}${rStr ? ` (${rStr})` : ''}.`,
                        `Closed at ${exitStr} for ${pnlStr}${rStr ? `, a ${rStr} return` : ''}.`,
                        `${exitStr} exit locked in ${pnlStr}${rStr ? ` - ${rStr} on risk` : ''}.`,
                        `Out at ${exitStr}, securing ${pnlStr}${rStr ? ` at ${rStr}` : ''}.`
                    ];

                    const rStr2 = rMultiple ? rMultiple.toFixed(1) : '2.0';
                    const hugeWinPhrases = [
                        `${rStr2}R is exceptional - this single trade justifies many controlled losses.`,
                        `A ${rStr2}R winner changes your week. This is how accounts grow.`,
                        `${rStr2}R return - you caught a real move and rode it.`,
                        `When you hit ${rStr2}R, you're doing something right. This trade paid for many lessons.`
                    ];

                    const bigWinPhrases = [
                        `${rStr2}R shows you let this breathe rather than cutting early.`,
                        `Holding to ${rStr2}R required patience most lack.`,
                        `${rStr2}R - you resisted the urge to take quick profits.`,
                        `The discipline to hold for ${rStr2}R separates amateurs from professionals.`
                    ];

                    const perfectPhrases = [
                        `Zero mistakes, plan followed, paid in full. This is your template.`,
                        `Flawless execution - no deviations, just results.`,
                        `This is what disciplined trading looks like. Replicate this.`,
                        `Clean entry, clean exit, clean profit. Remember this feeling.`
                    ];

                    const optionsPhrases = [
                        `Options require time awareness - your ${holdTimeStr} duration was appropriate.`,
                        `Managing decay with a ${holdTimeStr} hold shows you understand options.`,
                        `${holdTimeStr} on options - you didn't let theta eat your edge.`,
                        `Smart options management - in and out in ${holdTimeStr}.`
                    ];

                    const closerPhrases = [
                        `Grade: ${grade}. Process and outcome aligned.`,
                        `${grade} execution. Consistency compounds.`,
                        `Grade: ${grade}. This is what edge looks like over time.`,
                        `${grade}. The market rewarded your discipline.`
                    ];

                    if (isWin && analysis.improvements.length <= 1) {
                        // Build comprehensive deep dive for clean wins with variety
                        let deepDive = openers[openerIndex] + ' ';
                        // Use unique combinations for each phrase selection
                        const entryIdx = (trade.id * 3 + holdMins) % entryPhrases.length;
                        const exitIdx = (trade.id * 7 + pnlHash) % exitPhrases.length;
                        const winIdx = (trade.id * 11 + priceHash) % (hugeWin ? hugeWinPhrases : bigWinPhrases).length;
                        const perfectIdx = (trade.id * 13 + tickerHash) % perfectPhrases.length;
                        const optIdx = (trade.id * 17 + holdMins) % optionsPhrases.length;
                        const closeIdx = (trade.id * 19 + pnlHash + tickerHash) % closerPhrases.length;

                        deepDive += entryPhrases[entryIdx] + ' ';
                        deepDive += exitPhrases[exitIdx] + ' ';

                        if (hugeWin) deepDive += hugeWinPhrases[winIdx] + ' ';
                        else if (bigWin) deepDive += bigWinPhrases[winIdx] + ' ';

                        if (perfectTrade) deepDive += perfectPhrases[perfectIdx] + ' ';
                        if (trade.setup === 'breakout') deepDive += ['Breakouts reward conviction.', 'You trusted the breakout - it paid.', 'Breakout setups suit your style.', 'Classic breakout execution.'][(trade.id * 5) % 4] + ' ';
                        if (trade.setup === 'reversal') deepDive += ['Catching reversals takes contrarian courage.', 'Reversal plays require conviction.', 'You read the reversal correctly.', 'Counter-trend play, well executed.'][(trade.id * 5) % 4] + ' ';
                        if (isOptions) deepDive += optionsPhrases[optIdx] + ' ';

                        deepDive += closerPhrases[closeIdx];
                        return deepDive;
                    } else if (isWin) {
                        let deepDive = `Your ${ticker} trade was profitable - ${pnlStr} in ${holdTimeStr}. But let's be honest about what happened. `;
                        deepDive += `Entry at ${entryStr}, exit at ${exitStr}. The P&L looks good, but I see ${analysis.improvements.length} concern${analysis.improvements.length > 1 ? 's' : ''}: ${analysis.improvements.map(i => i.title.toLowerCase()).join(', ')}. `;
                        deepDive += `These are cracks through which fortunes leak. The market was kind to you today - it won't always be. `;
                        deepDive += `Grade: ${grade}. Don't confuse a favorable outcome with a sound decision. Fix the process while you can.`;
                        return deepDive;
                    } else if (analysis.improvements.length <= 1) {
                        let deepDive = `Let's review your ${ticker} ${setupName} - a ${pnlStr} loss over ${holdTimeStr}. `;
                        deepDive += `Entry at ${entryStr} ${wasOpenPlay ? 'at the open' : wasLunchTrade ? 'during lunch hours' : ''}, stopped out at ${exitStr}. `;
                        if (rMultiple && rMultiple >= -1.5) deepDive += `The loss was ${rStr} - within your risk parameters. This is proper risk management. `;
                        deepDive += `Here's what matters: your process was sound. ${analysis.positives.length > 0 ? `You did ${analysis.positives.length} things correctly. ` : ''}`;
                        deepDive += `Losses are the cost of doing business. This one was controlled, and you'll live to trade another day. `;
                        deepDive += `Grade: ${grade}. ${specificObs || 'Process over outcome - you handled this well.'}`;
                        return deepDive;
                    } else {
                        let deepDive = `${ticker} demands honest reflection. You lost ${pnlStr} in ${holdTimeStr}. `;
                        deepDive += `Entry ${entryStr}, exit ${exitStr}. Let's talk about what went wrong: `;
                        deepDive += analysis.improvements.slice(0, 3).map(i => i.title.toLowerCase()).join(', ') + '. ';
                        deepDive += `These aren't just mistakes - they're patterns that will keep costing you money until you address them. `;
                        deepDive += `The market charged you $${pnlAbs.toFixed(2)} in tuition today. The question is: will you learn from it, or pay it again tomorrow? `;
                        deepDive += `Grade: ${grade}. Review this trade carefully.`;
                        return deepDive;
                    }
                }

                if (p === 'homie') {
                    if (isWin && analysis.improvements.length <= 1) {
                        // Build comprehensive deep dive for homie - clean wins
                        let deepDive = `Aight let's break down this ${ticker} ${setupName}! üî• `;
                        deepDive += `You got in at ${entryStr} on ${entryDay} ${wasOpenPlay ? 'right at the open when things get crazy' : wasLunchTrade ? 'during lunch when most people are sleeping' : wasAfternoon ? 'in the afternoon session'  : ''} and held it for ${holdTimeStr}. `;
                        deepDive += `Out at ${exitStr} for ${pnlStr}${rStr ? ` - that's ${rStr} on your risk!` : '!'} `;

                        if (hugeWin) deepDive += `BRO. ${rMultiple.toFixed(1)}R?! This is ELITE. One trade like this covers SO many small L's. You didn't panic, you let it cook, and it PAID. üçΩÔ∏è `;
                        else if (bigWin) deepDive += `${rMultiple.toFixed(1)}R return means you actually let this one breathe instead of taking crumbs. That's growth right there! üìà `;

                        if (perfectTrade) deepDive += `Zero mistakes flagged, followed your plan, got paid. This is TEXTBOOK. Screenshot this one! üì∏ `;
                        if (trade.setup === 'breakout') deepDive += `Breakouts are clearly your thing - this setup works for you, keep hunting these! `;
                        if (isOptions) deepDive += `Options = leverage, and you used it right. ${holdTimeStr} hold time means you weren't letting theta eat your lunch. Smart. `;
                        if (isScalp) deepDive += `Quick ${holdTimeStr} scalp - surgical precision, no overstaying your welcome. `;
                        if (isSwing) deepDive += `Holding for ${holdTimeStr}?! Diamond hands fr fr. Most people would've panic sold way before this. üíé `;

                        deepDive += `Grade: ${grade}. This is the energy we need EVERY trade! Keep this up! üí™`;
                        return deepDive;
                    } else if (isWin) {
                        let deepDive = `Okay ${ticker} made money - ${pnlStr} in ${holdTimeStr}. But let's keep it real... üòÖ `;
                        deepDive += `Entry ${entryStr}, exit ${exitStr}. The bag is secured BUT I see problems: ${analysis.improvements.map(i => i.title.toLowerCase()).slice(0,2).join(' and ')}. `;
                        deepDive += `Bro you got BAILED OUT on this one. The market was nice to you - it won't always be. `;
                        deepDive += `Green is green, but winning with bad habits is how people blow up accounts later. Fix the process while the market is still giving you chances! `;
                        deepDive += `Grade: ${grade}. Do better next time!`;
                        return deepDive;
                    } else if (analysis.improvements.length <= 1) {
                        // Loss but clean process
                        let deepDive = `${ticker} took an L. ${pnlStr} gone over ${holdTimeStr}. üò§ `;
                        deepDive += `Entry ${entryStr} ${wasOpenPlay ? 'at the open on ' + entryDay : wasLunchTrade ? 'during lunch hours' : ''}, stopped out at ${exitStr}. `;
                        if (rMultiple && rMultiple >= -1.5) deepDive += `But look - ${rStr} loss. That's CONTROLLED. You didn't blow up, you didn't revenge trade, you took your stop. That's PROFESSIONAL. `;
                        deepDive += `${analysis.positives.length > 0 ? `You actually did ${analysis.positives.length} things RIGHT on this trade. ` : ''}`;
                        deepDive += `Losses happen to EVERYONE. The difference is HOW you lose. You lost the right way. `;
                        deepDive += `Grade: ${grade}. Head up, we go again tomorrow! üí™`;
                        return deepDive;
                    } else {
                        let deepDive = `${ticker} hurt. ${pnlStr} down the drain in ${holdTimeStr}. üòî `;
                        deepDive += `Entry ${entryStr}, exit ${exitStr}. Let's talk about what went wrong: `;
                        deepDive += analysis.improvements.slice(0, 3).map(i => i.title).join(', ') + '. ';
                        deepDive += `Bro... ${analysis.improvements.length} mistakes on ONE trade? This is how accounts die. `;
                        deepDive += `The market just charged you $${pnlAbs.toFixed(2)} for this lesson. Don't make it charge you again. `;
                        deepDive += `THIS is why we journal - so you see these patterns and FIX them. Review this one carefully. `;
                        deepDive += `Grade: ${grade}. Learn from this! üìù`;
                        return deepDive;
                    }
                }

                if (p === 'sergeant') {
                    const specificObs = getSpecificObservation();
                    if (isWin && analysis.improvements.length <= 1) {
                        const sergeantSpecific = hugeWin ? `${rMultiple.toFixed(1)}R RETURN! THAT'S HOW YOU WIN A WAR!` :
                            bigWin ? `${rMultiple.toFixed(1)}R! YOU LET IT RUN SOLDIER!` :
                            wasOpenPlay ? `CAUGHT THE OPEN ON ${entryDay.toUpperCase()}! DECISIVE ACTION!` :
                            isScalp ? `${holdTimeStr.toUpperCase()} SURGICAL STRIKE!` : `${holdTimeStr} MISSION COMPLETE!`;
                        return `${ticker} VICTORY! ${pnlStr}! ${entryStr} ‚Üí ${exitStr}. ${sergeantSpecific} Grade: ${grade}! THIS IS DISCIPLINE!`;
                    } else if (isWin) {
                        return `${ticker} made money but DON'T GET COCKY! ${pnlStr} in ${holdTimeStr} with ${analysis.improvements.length} VIOLATIONS! ${analysis.improvements[0]?.title.toUpperCase()}! The market gave you a GIFT soldier! DON'T EXPECT ANOTHER!`;
                    } else if (analysis.improvements.length <= 1) {
                        return `${ticker} LOSS: ${pnlStr}. ${entryStr} ‚Üí ${exitStr}, ${holdTimeStr}. BUT you held the LINE! ${grade} grade! CONTROLLED RETREAT! Losses happen in WAR but you kept DISCIPLINE! RESPECT!`;
                    } else {
                        return `${ticker} was a DISASTER! ${pnlStr} in ${holdTimeStr}! ${analysis.improvements.length} VIOLATIONS! ${analysis.improvements[0]?.title.toUpperCase()} is UNACCEPTABLE! This is how ACCOUNTS DIE! DEBRIEF NOW!`;
                    }
                }

                if (p === 'mentor') {
                    const specificObs = getSpecificObservation();
                    if (isWin && analysis.improvements.length <= 1) {
                        const mentorSpecific = bigWin ? `Letting it run to ${rMultiple.toFixed(1)}R shows maturity.` :
                            wasOpenPlay ? `Opening plays require conviction - you had it.` :
                            isScalp ? `Quick ${holdTimeStr} execution, no overtrading.` :
                            perfectTrade ? `This trade should be your template.` : `${analysis.positives.length} positive behaviors identified.`;
                        return `${ticker} ${setupName}: ${pnlStr}. ${entryStr} ‚Üí ${exitStr}, ${holdTimeStr} hold. ${mentorSpecific} Grade: ${grade}.`;
                    } else if (isWin) {
                        return `${ticker} profitable (${pnlStr}, ${holdTimeStr}) but review: ${analysis.improvements.map(i => i.title).slice(0,2).join(', ')}. Winning with poor habits creates future problems.`;
                    } else if (analysis.improvements.length <= 1) {
                        return `${ticker} ${setupName}: ${pnlStr} loss over ${holdTimeStr}. Grade: ${grade}. Process was sound - this is variance. ${analysis.positives.length} elements executed correctly.`;
                    } else {
                        return `${ticker} requires review. ${pnlStr} in ${holdTimeStr} with ${analysis.improvements.length} errors. Focus on: ${analysis.improvements.slice(0,2).map(i => i.title).join(', ')}.`;
                    }
                }

                // nerd/default
                const specificObs = getSpecificObservation();
                if (isWin && analysis.improvements.length <= 1) {
                    return `${ticker}: ${grade}. ${isOptions ? 'OPTIONS' : 'STOCK'}, ${setupName}. Entry=${entryStr}, Exit=${exitStr}, Duration=${holdTimeStr}, P&L=${pnlStr}${rStr ? `, R=${rStr}` : ''}. ${analysis.positives.length} positive factors. ${specificObs || 'Optimal execution.'}`;
                } else if (isWin) {
                    return `${ticker}: Profitable (${pnlStr}, ${holdTimeStr}) but suboptimal. ${analysis.improvements.length} deviation(s): ${analysis.improvements.slice(0,2).map(i => i.title).join(', ')}.`;
                } else if (analysis.improvements.length <= 1) {
                    return `${ticker}: EV+ trade, negative outcome. ${entryStr}‚Üí${exitStr}, ${holdTimeStr}, P&L=${pnlStr}${rStr ? `, R=${rStr}` : ''}. Grade: ${grade}. Process adherence: high.`;
                } else {
                    return `${ticker}: ${analysis.improvements.length} violations over ${holdTimeStr}. ${entryStr}‚Üí${exitStr}, P&L=${pnlStr}. Errors: ${analysis.improvements.slice(0,3).map(i => i.title).join(', ')}.`;
                }
            };

            const p = personality || 'homie';
            analysis.summary = generateUniqueSummary(p);

            return analysis;
        };

        // Analyze daily performance
        const analyzeDailyPerformance = (entries, targetDate, personality = 'homie') => {
            const dateStr = targetDate.toISOString().split('T')[0];
            const dayTrades = entries.filter(t => {
                const tradeDate = new Date(t.entryDate).toISOString().split('T')[0];
                return tradeDate === dateStr;
            });

            if (dayTrades.length === 0) {
                return {
                    hasTrades: false,
                    message: `No trades on ${dateStr}`
                };
            }

            const wins = dayTrades.filter(t => t.pnl > 0);
            const losses = dayTrades.filter(t => t.pnl <= 0);
            const totalPnl = dayTrades.reduce((sum, t) => sum + t.pnl, 0);
            const winRate = (wins.length / dayTrades.length * 100).toFixed(0);
            const grossProfit = wins.reduce((sum, t) => sum + t.pnl, 0);
            const grossLoss = Math.abs(losses.reduce((sum, t) => sum + t.pnl, 0));
            const profitFactor = grossLoss > 0 ? (grossProfit / grossLoss).toFixed(2) : 'N/A';

            // Find best and worst trade
            const bestTrade = [...dayTrades].sort((a, b) => b.pnl - a.pnl)[0];
            const worstTrade = [...dayTrades].sort((a, b) => a.pnl - b.pnl)[0];

            // Count mistakes
            const mistakeCounts = {};
            dayTrades.forEach(t => {
                (t.mistakes || []).forEach(m => {
                    if (m !== 'none') {
                        mistakeCounts[m] = (mistakeCounts[m] || 0) + 1;
                    }
                });
            });
            const topMistakes = Object.entries(mistakeCounts).sort((a, b) => b[1] - a[1]).slice(0, 3);

            const analysis = {
                hasTrades: true,
                date: dateStr,
                tradeCount: dayTrades.length,
                wins: wins.length,
                losses: losses.length,
                totalPnl,
                winRate,
                profitFactor,
                bestTrade,
                worstTrade,
                topMistakes,
                summary: ''
            };

            // Build summary based on personality
            const isGreen = totalPnl > 0;
            const isGreatDay = totalPnl > 500 || (parseFloat(winRate) > 70 && dayTrades.length >= 3);
            const isBadDay = totalPnl < -200 || (parseFloat(winRate) < 30 && dayTrades.length >= 3);

            if (personality === 'oracle') {
                if (isGreatDay) {
                    analysis.summary = `An exceptional day of trading. ${wins.length} wins, ${losses.length} losses, net +$${totalPnl.toFixed(2)}. Your ${winRate}% accuracy today reflects preparation meeting opportunity. But remember - one good day doesn't make a career. The real test is whether you can maintain this discipline when the market turns against you. ${profitFactor !== 'N/A' ? `Profit factor of ${profitFactor} suggests you're letting winners run.` : ''} Continue to trade with this clarity.`;
                } else if (isGreen) {
                    analysis.summary = `A productive day - +$${totalPnl.toFixed(2)} from ${dayTrades.length} trades. In investing, it's not about how much you make on good days, but how little you lose on bad ones. Today you added to your capital, which compounds over time. ${topMistakes.length > 0 ? `I notice ${MISTAKE_TYPES.find(m => m.id === topMistakes[0][0])?.label || topMistakes[0][0]} appeared ${topMistakes[0][1]} time(s) - small leaks sink great ships.` : ''}`;
                } else if (isBadDay) {
                    analysis.summary = `A difficult day: -$${Math.abs(totalPnl).toFixed(2)}. ${losses.length} losses versus ${wins.length} wins. The market humbles all of us eventually. What matters now is your response. Don't compound today's losses with tomorrow's revenge trades. ${topMistakes.length > 0 ? `${MISTAKE_TYPES.find(m => m.id === topMistakes[0][0])?.label || topMistakes[0][0]} appeared ${topMistakes[0][1]} times - this pattern needs addressing.` : ''} Step back, review with clear eyes, and return with renewed discipline.`;
                } else {
                    analysis.summary = `A small loss: -$${Math.abs(totalPnl).toFixed(2)}. In the grand scheme, this is a rounding error. You lived to trade another day with your capital mostly intact. The best traders aren't those who never lose - they're those who lose small. Profit factor: ${profitFactor}. Review your trades, extract the lessons, and prepare for tomorrow.`;
                }
            } else if (personality === 'homie') {
                if (isGreatDay) {
                    analysis.summary = `WHAT A DAY! üî• ${wins.length}W-${losses.length}L, +$${totalPnl.toFixed(2)} secured. ${winRate}% win rate. You were LOCKED IN today. ${topMistakes.length === 0 ? 'No major mistakes either!' : ''}`;
                } else if (isGreen) {
                    analysis.summary = `Green day! +$${totalPnl.toFixed(2)} from ${dayTrades.length} trades. ${winRate}% win rate. ${topMistakes.length > 0 ? `Watch out for ${MISTAKE_TYPES.find(m => m.id === topMistakes[0][0])?.label || topMistakes[0][0]} though.` : 'Solid work.'}`;
                } else if (isBadDay) {
                    analysis.summary = `Tough day. üò§ ${wins.length}W-${losses.length}L, -$${Math.abs(totalPnl).toFixed(2)}. ${topMistakes.length > 0 ? `${MISTAKE_TYPES.find(m => m.id === topMistakes[0][0])?.label || topMistakes[0][0]} hurt you ${topMistakes[0][1]} times. ` : ''}Tomorrow's a new day. Don't revenge trade.`;
                } else {
                    analysis.summary = `Red day but not too bad. -$${Math.abs(totalPnl).toFixed(2)} from ${dayTrades.length} trades. ${winRate}% win rate. Kept the damage controlled.`;
                }
            } else if (personality === 'sergeant') {
                if (isGreatDay) {
                    analysis.summary = `MISSION SUCCESS! ${wins.length}W-${losses.length}L. +$${totalPnl.toFixed(2)} captured. ${winRate}% accuracy. THAT'S how you execute!`;
                } else if (isGreen) {
                    analysis.summary = `Objective achieved. +$${totalPnl.toFixed(2)}. ${winRate}% hit rate. Not spectacular but you held the line.`;
                } else {
                    analysis.summary = `CASUALTY REPORT: -$${Math.abs(totalPnl).toFixed(2)}. ${losses.length} losses. ${topMistakes.length > 0 ? `${MISTAKE_TYPES.find(m => m.id === topMistakes[0][0])?.label || topMistakes[0][0]} is KILLING you! FIX IT!` : 'Regroup and return tomorrow!'}`;
                }
            } else {
                analysis.summary = `Daily P&L: ${isGreen ? '+' : ''}$${totalPnl.toFixed(2)} | Trades: ${dayTrades.length} | Win Rate: ${winRate}% | Profit Factor: ${profitFactor}`;
            }

            return analysis;
        };

        const generateCoachingInsights = (entries, stats, personality = 'homie') => {
            if (!entries || entries.length < 3) {
                return {
                    hasEnoughData: false,
                    message: "Need at least 3 trades to generate insights. Keep journaling!"
                };
            }

            const insights = [];

            // 1. MONEY LEAKS - Which mistakes cost the most
            const moneyLeaks = Object.entries(stats.mistakeStats || {})
                .filter(([id, data]) => id !== 'none' && data.totalLoss > 0)
                .sort((a, b) => b[1].totalLoss - a[1].totalLoss)
                .slice(0, 3);

            if (moneyLeaks.length > 0) {
                const topLeak = moneyLeaks[0];
                const mistakeInfo = MISTAKE_TYPES.find(m => m.id === topLeak[0]);
                insights.push({
                    type: 'money_leak',
                    icon: 'üö®',
                    title: 'Biggest Money Leak',
                    value: `$${topLeak[1].totalLoss.toFixed(2)} lost`,
                    detail: `${mistakeInfo?.emoji || ''} ${mistakeInfo?.label || topLeak[0]} (${topLeak[1].count} times)`,
                    severity: 'high',
                    advice: personality === 'homie'
                        ? `Yo, ${mistakeInfo?.label || 'this mistake'} is eating your profits. Fix this and you'd be up way more.`
                        : personality === 'sergeant'
                        ? `SOLDIER! ${mistakeInfo?.label || 'This mistake'} is costing you $${topLeak[1].totalLoss.toFixed(2)}. UNACCEPTABLE.`
                        : `${mistakeInfo?.label || 'This mistake'} is your biggest leak. Address this first.`
                });
            }

            // 2. BEST/WORST DAY OF WEEK
            const dayStats = Object.entries(stats.dayOfWeekStats || {})
                .filter(([_, data]) => data.trades > 0);

            if (dayStats.length >= 3) {
                const sortedDays = dayStats.sort((a, b) => b[1].pnl - a[1].pnl);
                const bestDay = sortedDays[0];
                const worstDay = sortedDays[sortedDays.length - 1];

                if (bestDay[1].pnl > 0) {
                    insights.push({
                        type: 'best_day',
                        icon: 'üìÖ',
                        title: 'Best Trading Day',
                        value: DAY_NAMES[parseInt(bestDay[0])],
                        detail: `+$${bestDay[1].pnl.toFixed(2)} from ${bestDay[1].trades} trades`,
                        severity: 'positive',
                        advice: personality === 'homie'
                            ? `${DAY_NAMES[parseInt(bestDay[0])]}s are your day! You print money on ${DAY_NAMES[parseInt(bestDay[0])]}s.`
                            : `You perform best on ${DAY_NAMES[parseInt(bestDay[0])]}s. Consider sizing up.`
                    });
                }

                if (worstDay[1].pnl < 0) {
                    insights.push({
                        type: 'worst_day',
                        icon: '‚ö†Ô∏è',
                        title: 'Worst Trading Day',
                        value: DAY_NAMES[parseInt(worstDay[0])],
                        detail: `$${worstDay[1].pnl.toFixed(2)} from ${worstDay[1].trades} trades`,
                        severity: 'warning',
                        advice: personality === 'homie'
                            ? `${DAY_NAMES[parseInt(worstDay[0])]}s ain't it for you. Maybe sit out or go smaller.`
                            : personality === 'sergeant'
                            ? `${DAY_NAMES[parseInt(worstDay[0])]}s are BLEEDING you. Consider NOT trading.`
                            : `Your ${DAY_NAMES[parseInt(worstDay[0])]} performance suggests reducing size or sitting out.`
                    });
                }
            }

            // 3. SETUP PERFORMANCE
            const setupStats = Object.entries(stats.setupStats || {})
                .filter(([_, data]) => data.trades >= 2);

            if (setupStats.length >= 2) {
                const sortedSetups = setupStats.sort((a, b) => b[1].pnl - a[1].pnl);
                const bestSetup = sortedSetups[0];
                const worstSetup = sortedSetups[sortedSetups.length - 1];

                const bestInfo = SETUP_TYPES.find(s => s.id === bestSetup[0]);
                const worstInfo = SETUP_TYPES.find(s => s.id === worstSetup[0]);

                if (bestSetup[1].pnl > 0) {
                    const winRate = ((bestSetup[1].wins / bestSetup[1].trades) * 100).toFixed(0);
                    insights.push({
                        type: 'best_setup',
                        icon: 'üéØ',
                        title: 'Best Setup',
                        value: `${bestInfo?.emoji || ''} ${bestInfo?.label || bestSetup[0]}`,
                        detail: `+$${bestSetup[1].pnl.toFixed(2)} (${winRate}% win rate)`,
                        severity: 'positive',
                        advice: personality === 'homie'
                            ? `Your ${bestInfo?.label || bestSetup[0]} plays are PRINTING. Do more of these!`
                            : `${bestInfo?.label || bestSetup[0]} is your edge. Focus here.`
                    });
                }

                if (worstSetup[1].pnl < 0) {
                    insights.push({
                        type: 'worst_setup',
                        icon: 'üíÄ',
                        title: 'Worst Setup',
                        value: `${worstInfo?.emoji || ''} ${worstInfo?.label || worstSetup[0]}`,
                        detail: `$${worstSetup[1].pnl.toFixed(2)} from ${worstSetup[1].trades} trades`,
                        severity: 'high',
                        advice: personality === 'homie'
                            ? `${worstInfo?.label || worstSetup[0]} is NOT your thing. Maybe stop trading these?`
                            : personality === 'sergeant'
                            ? `STOP trading ${worstInfo?.label || worstSetup[0]}. It's LOSING you money.`
                            : `Consider removing ${worstInfo?.label || worstSetup[0]} from your playbook.`
                    });
                }
            }

            // 4. EXPECTANCY
            if (stats.totalTrades > 0) {
                const expectancy = stats.totalPnL / stats.totalTrades;
                insights.push({
                    type: 'expectancy',
                    icon: 'üìä',
                    title: 'Expected Value Per Trade',
                    value: `${expectancy >= 0 ? '+' : ''}$${expectancy.toFixed(2)}`,
                    detail: `Based on ${stats.totalTrades} trades`,
                    severity: expectancy >= 0 ? 'positive' : 'warning',
                    advice: expectancy >= 0
                        ? (personality === 'homie'
                            ? `You make $${expectancy.toFixed(2)} per trade on average. Keep grinding!`
                            : `Positive expectancy. Your system works.`)
                        : (personality === 'homie'
                            ? `You're LOSING $${Math.abs(expectancy).toFixed(2)} per trade. We gotta fix this.`
                            : `Negative expectancy. Review your strategy.`)
                });
            }

            // 5. EMOTIONAL PATTERNS
            const emotionStats = Object.entries(stats.emotionStats || {})
                .filter(([_, data]) => data.trades >= 2);

            if (emotionStats.length > 0) {
                const badEmotionTrades = emotionStats
                    .filter(([id]) => ['revenge', 'fomo', 'frustrated', 'greedy'].includes(id));

                if (badEmotionTrades.length > 0) {
                    const totalBadPnL = badEmotionTrades.reduce((sum, [_, d]) => sum + d.pnl, 0);
                    const totalBadTrades = badEmotionTrades.reduce((sum, [_, d]) => sum + d.trades, 0);

                    if (totalBadPnL < 0) {
                        insights.push({
                            type: 'emotional_trading',
                            icon: 'üß†',
                            title: 'Emotional Trading Cost',
                            value: `$${totalBadPnL.toFixed(2)}`,
                            detail: `${totalBadTrades} trades while tilted`,
                            severity: 'high',
                            advice: personality === 'homie'
                                ? `Trading emotional cost you $${Math.abs(totalBadPnL).toFixed(2)}. Take a breather when tilted.`
                                : personality === 'sergeant'
                                ? `EMOTIONAL TRADING is DESTROYING your account. DISCIPLINE!`
                                : `Emotional trades are unprofitable. Implement a cooldown rule.`
                        });
                    }
                }
            }

            // 6. WIN RATE & PROFIT FACTOR
            insights.push({
                type: 'win_rate',
                icon: 'üèÜ',
                title: 'Win Rate',
                value: `${stats.winRate.toFixed(1)}%`,
                detail: `${stats.wins}W - ${stats.losses}L`,
                severity: stats.winRate >= 50 ? 'positive' : 'warning',
                advice: stats.winRate >= 50
                    ? `Above 50% - you're picking more winners than losers.`
                    : `Below 50%, but that's okay if your winners are bigger than losers.`
            });

            if (stats.profitFactor && stats.profitFactor !== Infinity) {
                insights.push({
                    type: 'profit_factor',
                    icon: 'üí∞',
                    title: 'Profit Factor',
                    value: stats.profitFactor.toFixed(2),
                    detail: stats.profitFactor >= 1.5 ? 'Great risk/reward' : stats.profitFactor >= 1 ? 'Profitable' : 'Losing money',
                    severity: stats.profitFactor >= 1.5 ? 'positive' : stats.profitFactor >= 1 ? 'neutral' : 'high',
                    advice: stats.profitFactor >= 2
                        ? `Profit factor of ${stats.profitFactor.toFixed(2)} is excellent!`
                        : stats.profitFactor >= 1
                        ? `Above 1 means you're net profitable. Keep it up.`
                        : `Below 1 means losses outweigh wins. Cut losers faster.`
                });
            }

            // 7. REVENGE TRADING DETECTION
            const revengeCount = entries.filter(e =>
                e.emotionBefore === 'revenge' ||
                (e.mistakes && e.mistakes.includes('revenge'))
            ).length;

            if (revengeCount >= 2) {
                const revengePnL = entries
                    .filter(e => e.emotionBefore === 'revenge' || (e.mistakes && e.mistakes.includes('revenge')))
                    .reduce((sum, e) => sum + (e.pnl || 0), 0);

                insights.push({
                    type: 'revenge_trading',
                    icon: 'üò§',
                    title: 'Revenge Trading Alert',
                    value: `${revengeCount} revenge trades`,
                    detail: `Cost: $${revengePnL.toFixed(2)}`,
                    severity: 'high',
                    advice: personality === 'homie'
                        ? `Bro, revenge trading ${revengeCount} times?! Walk away after a big L. Come back fresh.`
                        : personality === 'sergeant'
                        ? `REVENGE TRADING IS FOR LOSERS. Walk away. Cool off. Return tomorrow.`
                        : `Implement a mandatory break after significant losses.`
                });
            }

            return {
                hasEnoughData: true,
                insights,
                summary: {
                    totalTrades: stats.totalTrades,
                    totalPnL: stats.totalPnL,
                    winRate: stats.winRate,
                    expectancy: stats.totalTrades > 0 ? stats.totalPnL / stats.totalTrades : 0
                }
            };
        };

        // ===== REVENGE TRADE DETECTION =====
        // Analyzes if a proposed trade shows signs of revenge trading
        const detectRevengeTrade = (proposedTrade, journalEntries, journalStats, lastLossTime) => {
            const signals = [];
            let score = 0;
            const now = Date.now();

            if (!journalEntries || journalEntries.length < 3) {
                return { isRevenge: false, score: 0, signals: [] };
            }

            // Sort journal by date (most recent first)
            const sortedJournal = [...journalEntries].sort((a, b) => new Date(b.exitDate || b.entryDate) - new Date(a.exitDate || a.entryDate));
            const recentTrades = sortedJournal.slice(0, 10);
            const lastTrade = recentTrades[0];

            // 1. TIMING - Trading too soon after a loss (within 10 minutes)
            if (lastLossTime && (now - lastLossTime) < 10 * 60 * 1000) {
                const minutesSinceLoss = Math.round((now - lastLossTime) / 60000);
                score += 2;
                signals.push({
                    type: 'timing',
                    message: `Trading ${minutesSinceLoss} minutes after your last loss`,
                    severity: 'high'
                });
            }

            // 2. SAME TICKER - Trying to re-enter a losing position
            if (lastTrade && lastTrade.pnl < 0 && lastTrade.ticker?.toUpperCase() === proposedTrade.ticker?.toUpperCase()) {
                score += 3;
                signals.push({
                    type: 'same_ticker',
                    message: `Re-entering ${proposedTrade.ticker} right after losing on it`,
                    severity: 'high'
                });
            }

            // 3. LOSS STREAK - Currently on a losing streak
            let lossStreak = 0;
            for (const trade of recentTrades) {
                if (trade.pnl < 0) lossStreak++;
                else break;
            }
            if (lossStreak >= 2) {
                score += 2;
                signals.push({
                    type: 'loss_streak',
                    message: `You're on a ${lossStreak}-trade losing streak`,
                    severity: lossStreak >= 3 ? 'high' : 'medium'
                });
            }

            // 4. SIZING - Position significantly larger than usual
            const avgPositionSize = recentTrades.reduce((sum, t) => sum + (Math.abs(t.pnl) || 100), 0) / recentTrades.length;
            const proposedSize = (parseFloat(proposedTrade.entryPrice) || 0) * (parseFloat(proposedTrade.quantity) || 1);
            if (proposedSize > avgPositionSize * 2 && proposedSize > 100) {
                score += 2;
                signals.push({
                    type: 'sizing',
                    message: `Position size is ${(proposedSize / avgPositionSize).toFixed(1)}x your average`,
                    severity: 'medium'
                });
            }

            // 5. ESCALATION - Each recent trade bigger than the last (trying to make it back)
            if (recentTrades.length >= 3) {
                const lastThreeSizes = recentTrades.slice(0, 3).map(t => Math.abs(t.pnl) || 100);
                if (lastThreeSizes[0] > lastThreeSizes[1] && lastThreeSizes[1] > lastThreeSizes[2]) {
                    score += 2;
                    signals.push({
                        type: 'escalation',
                        message: 'Your position sizes are escalating - classic revenge pattern',
                        severity: 'medium'
                    });
                }
            }

            // 6. BAD HOUR - Trading during historically bad hours
            const hour = new Date().getHours();
            const hourStats = journalStats.hourStats?.[hour];
            if (hourStats && hourStats.trades >= 3) {
                const hourWinRate = hourStats.wins / hourStats.trades * 100;
                if (hourWinRate < 35) {
                    score += 1;
                    signals.push({
                        type: 'bad_hour',
                        message: `Your win rate at ${hour > 12 ? hour - 12 : hour}${hour >= 12 ? 'PM' : 'AM'} is only ${hourWinRate.toFixed(0)}%`,
                        severity: 'low'
                    });
                }
            }

            return {
                isRevenge: score >= 4,
                isSevere: score >= 7,
                score,
                signals
            };
        };

        // ===== PRE-TRADE INTELLIGENCE =====
        // Analyzes a proposed trade against user's historical patterns
        const analyzeProposedTrade = (proposedTrade, journalEntries, journalStats, settings = {}, lastLossTime = null, currentPositions = []) => {
            const warnings = [];
            const insights = [];
            const hardBlocks = []; // Trades that should be blocked in Guardian mode
            const now = new Date();
            const dayOfWeek = now.getDay();
            const hour = now.getHours();

            const tradingMode = settings.tradingMode || 'standard';
            const guardianSettings = settings.guardianSettings || {};

            // AGGRESSIVE MODE - Skip most checks, only critical ones
            if (tradingMode === 'aggressive') {
                // Only check for severe loss streaks
                if (journalEntries && journalEntries.length >= 3) {
                    const recentTrades = [...journalEntries]
                        .sort((a, b) => new Date(b.exitDate || b.entryDate) - new Date(a.exitDate || a.entryDate))
                        .slice(0, 5);
                    let lossStreak = 0;
                    for (const trade of recentTrades) {
                        if (trade.pnl < 0) lossStreak++;
                        else break;
                    }
                    if (lossStreak >= 3) {
                        warnings.push({
                            type: 'loss_streak',
                            severity: 'high',
                            title: `${lossStreak}-trade losing streak`,
                            message: `Even in Send It Mode, this is concerning. Take a breath.`,
                            emoji: 'üî•'
                        });
                        return { warnings, insights: [], hasEnoughData: true, overallRisk: 'high', lossStreak };
                    }
                }
                return { warnings: [], insights: [], hasEnoughData: true, overallRisk: 'low', skippedDueToMode: true };
            }

            // Need at least 5 trades for meaningful analysis
            if (!journalEntries || journalEntries.length < 5) {
                // GUARDIAN MODE - Still warn even without data
                if (tradingMode === 'guardian') {
                    warnings.push({
                        type: 'no_data',
                        severity: 'medium',
                        title: 'Not enough trading history',
                        message: 'Guardian Mode recommends building a journal before trading. Proceed with extra caution.',
                        emoji: 'üìù'
                    });
                    return { warnings, insights: [], hasEnoughData: false, overallRisk: 'medium' };
                }
                return { warnings: [], insights: [], hasEnoughData: false, overallRisk: 'unknown' };
            }

            // REVENGE TRADE DETECTION (Guardian mode with revengeDetection enabled)
            if (tradingMode === 'guardian' && guardianSettings.revengeDetection) {
                const revengeResult = detectRevengeTrade(proposedTrade, journalEntries, journalStats, lastLossTime);
                if (revengeResult.isRevenge) {
                    const revengeWarning = {
                        type: 'revenge_trade',
                        severity: revengeResult.isSevere ? 'critical' : 'high',
                        title: revengeResult.isSevere ? 'üö® STOP - REVENGE TRADING DETECTED' : '‚ö†Ô∏è This looks like a revenge trade',
                        message: revengeResult.signals.map(s => s.message).join(' ‚Ä¢ '),
                        emoji: 'üò§',
                        revengeScore: revengeResult.score,
                        signals: revengeResult.signals
                    };
                    warnings.push(revengeWarning);

                    // Hard block if severe revenge trading
                    if (revengeResult.isSevere && guardianSettings.blockBadPatterns) {
                        hardBlocks.push({
                            reason: 'revenge_trade',
                            message: 'This trade is blocked. Multiple revenge trading signals detected. Take a break and come back with a clear head.'
                        });
                    }
                }
            }

            // 1. DAY OF WEEK ANALYSIS
            const dayStats = journalStats.dayOfWeekStats?.[dayOfWeek];
            if (dayStats && dayStats.trades >= 3) {
                const dayWinRate = dayStats.trades > 0 ?
                    (journalEntries.filter(e => new Date(e.entryDate).getDay() === dayOfWeek && e.pnl > 0).length /
                     journalEntries.filter(e => new Date(e.entryDate).getDay() === dayOfWeek).length * 100) : 0;

                if (dayStats.pnl < 0 || dayWinRate < 40) {
                    warnings.push({
                        type: 'day_of_week',
                        severity: dayWinRate < 30 ? 'high' : 'medium',
                        title: `${DAY_NAMES[dayOfWeek]}s aren't your day`,
                        message: `Your ${DAY_NAMES[dayOfWeek]} win rate: ${dayWinRate.toFixed(0)}% (${dayStats.trades} trades, $${dayStats.pnl.toFixed(0)} P&L)`,
                        emoji: 'üìÖ'
                    });
                } else if (dayWinRate >= 60) {
                    insights.push({
                        type: 'day_of_week',
                        title: `${DAY_NAMES[dayOfWeek]}s are usually good for you`,
                        message: `${dayWinRate.toFixed(0)}% win rate on ${DAY_NAMES[dayOfWeek]}s`,
                        emoji: '‚úÖ'
                    });
                }
            }

            // 2. TIME OF DAY ANALYSIS
            const hourStats = journalStats.hourStats?.[hour];
            if (hourStats && hourStats.trades >= 3) {
                const hourWinRate = hourStats.trades > 0 ? (hourStats.wins / hourStats.trades * 100) : 0;
                const timeLabel = hour < 10 ? 'market open' : hour < 12 ? 'mid-morning' : hour < 14 ? 'lunch hours' : 'afternoon';

                if (hourWinRate < 40) {
                    warnings.push({
                        type: 'time_of_day',
                        severity: hourWinRate < 30 ? 'high' : 'medium',
                        title: `You struggle during ${timeLabel}`,
                        message: `Your win rate at this hour: ${hourWinRate.toFixed(0)}%`,
                        emoji: 'üïê'
                    });
                }
            }

            // 3. ASSET TYPE ANALYSIS
            const assetType = proposedTrade.type;
            const assetTrades = journalEntries.filter(e => e.assetType === assetType);
            if (assetTrades.length >= 3) {
                const assetWins = assetTrades.filter(e => e.pnl > 0).length;
                const assetWinRate = (assetWins / assetTrades.length * 100);
                const assetPnL = assetTrades.reduce((sum, e) => sum + e.pnl, 0);

                const assetLabel = assetType === 'option' ? 'Options' : assetType === 'crypto' ? 'Crypto' : 'Stocks';

                if (assetWinRate < 40 || assetPnL < 0) {
                    warnings.push({
                        type: 'asset_type',
                        severity: assetWinRate < 30 ? 'high' : 'medium',
                        title: `${assetLabel} haven't been kind to you`,
                        message: `${assetLabel} win rate: ${assetWinRate.toFixed(0)}% | P&L: $${assetPnL.toFixed(0)}`,
                        emoji: assetType === 'option' ? 'üìâ' : assetType === 'crypto' ? 'ü™ô' : 'üìä'
                    });
                }
            }

            // 4. TRADE STYLE ANALYSIS
            const tradeStyle = proposedTrade.strategy;
            const styleTrades = journalEntries.filter(e => e.tradeStyle === tradeStyle);
            if (styleTrades.length >= 3) {
                const styleWins = styleTrades.filter(e => e.pnl > 0).length;
                const styleWinRate = (styleWins / styleTrades.length * 100);
                const stylePnL = styleTrades.reduce((sum, e) => sum + e.pnl, 0);

                const styleLabel = tradeStyle === 'scalp' ? 'Scalping' : tradeStyle === 'day' ? 'Day trading' : 'Swing trading';

                if (styleWinRate < 40 || stylePnL < 0) {
                    warnings.push({
                        type: 'trade_style',
                        severity: styleWinRate < 30 ? 'high' : 'medium',
                        title: `${styleLabel} isn't working for you`,
                        message: `${styleLabel} win rate: ${styleWinRate.toFixed(0)}% | P&L: $${stylePnL.toFixed(0)}`,
                        emoji: '‚ö°'
                    });
                }
            }

            // 5. CURRENT STREAK ANALYSIS (check last 3 trades)
            const recentTrades = [...journalEntries]
                .sort((a, b) => new Date(b.exitDate || b.entryDate) - new Date(a.exitDate || a.entryDate))
                .slice(0, 5);

            let lossStreak = 0;
            for (const trade of recentTrades) {
                if (trade.pnl < 0) lossStreak++;
                else break;
            }

            if (lossStreak >= 2) {
                warnings.push({
                    type: 'loss_streak',
                    severity: lossStreak >= 3 ? 'high' : 'medium',
                    title: `You're on a ${lossStreak}-trade losing streak`,
                    message: lossStreak >= 3
                        ? `STOP. Take a break. Come back fresh.`
                        : `Consider sizing down or taking a breather.`,
                    emoji: 'üî•'
                });
            }

            // 6. 0DTE OPTIONS DETECTION
            if (assetType === 'option' && proposedTrade.expiration) {
                const expDate = new Date(proposedTrade.expiration);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                expDate.setHours(0, 0, 0, 0);
                const daysToExp = Math.ceil((expDate - today) / (1000 * 60 * 60 * 24));

                if (daysToExp === 0) {
                    // Check 0DTE win rate
                    const zeroDteTrades = journalEntries.filter(e => {
                        if (e.assetType !== 'option') return false;
                        const entry = new Date(e.entryDate);
                        const exit = new Date(e.exitDate || e.entryDate);
                        return entry.toDateString() === exit.toDateString();
                    });

                    if (zeroDteTrades.length >= 2) {
                        const zeroDteWins = zeroDteTrades.filter(e => e.pnl > 0).length;
                        const zeroDteWinRate = (zeroDteWins / zeroDteTrades.length * 100);

                        warnings.push({
                            type: '0dte',
                            severity: 'high',
                            title: `‚ö†Ô∏è 0DTE ALERT`,
                            message: `Your 0DTE win rate: ${zeroDteWinRate.toFixed(0)}% (${zeroDteTrades.length} trades). Theta decay is brutal. Are you sure?`,
                            emoji: '‚è∞'
                        });
                    } else {
                        warnings.push({
                            type: '0dte',
                            severity: 'high',
                            title: `‚ö†Ô∏è 0DTE ALERT`,
                            message: `0DTE options are extremely risky. Time decay accelerates exponentially. Proceed with caution.`,
                            emoji: '‚è∞'
                        });
                    }
                } else if (daysToExp <= 2) {
                    warnings.push({
                        type: 'short_dated',
                        severity: 'medium',
                        title: `Short-dated option (${daysToExp} day${daysToExp > 1 ? 's' : ''} to expiry)`,
                        message: `Theta decay is accelerating. Have a quick exit plan.`,
                        emoji: '‚ö°'
                    });
                }
            }

            // 7. AVERAGING DOWN DETECTION
            if (currentPositions && currentPositions.length > 0) {
                const ticker = proposedTrade.ticker?.toUpperCase();
                const existingPosition = currentPositions.find(p =>
                    p.ticker?.toUpperCase() === ticker &&
                    p.type === proposedTrade.type
                );

                if (existingPosition) {
                    const existingEntry = parseFloat(existingPosition.entryPrice);
                    const newEntry = parseFloat(proposedTrade.entryPrice);
                    const currentPrice = parseFloat(existingPosition.currentPrice) || existingEntry;

                    // Detect averaging down (buying lower for longs)
                    const isAveragingDown = newEntry < existingEntry;
                    const dropFromEntry = ((existingEntry - newEntry) / existingEntry * 100);
                    const dropFromCurrent = currentPrice ? ((currentPrice - newEntry) / currentPrice * 100) : 0;

                    // Calculate new average cost
                    const existingQty = parseFloat(existingPosition.quantity) || 1;
                    const newQty = parseFloat(proposedTrade.quantity) || 1;
                    const newAvgCost = ((existingEntry * existingQty) + (newEntry * newQty)) / (existingQty + newQty);
                    const sizeIncrease = ((existingQty + newQty) / existingQty * 100 - 100).toFixed(0);

                    if (isAveragingDown) {
                        // Check user's history with averaging down
                        const avgDownTrades = journalEntries.filter(e => {
                            const mistakes = e.mistakes || [];
                            return mistakes.includes('oversized') || e.notes?.toLowerCase().includes('average') || e.notes?.toLowerCase().includes('added');
                        });
                        const avgDownWins = avgDownTrades.filter(e => e.pnl > 0).length;
                        const avgDownWinRate = avgDownTrades.length >= 2 ? (avgDownWins / avgDownTrades.length * 100) : null;

                        // Calculate key levels (rough support estimates based on % drops)
                        const level10 = existingEntry * 0.90;
                        const level20 = existingEntry * 0.80;
                        const level30 = existingEntry * 0.70;
                        const nearLevel10 = Math.abs(newEntry - level10) / level10 < 0.02;
                        const nearLevel20 = Math.abs(newEntry - level20) / level20 < 0.02;
                        const nearLevel30 = Math.abs(newEntry - level30) / level30 < 0.02;

                        // Build context-aware advice
                        let avgDownAdvice = '';
                        let severity = 'medium';
                        let shouldWait = false;
                        let suggestedLevel = null;

                        if (dropFromEntry < 5) {
                            // Minor dip
                            avgDownAdvice = `Only ${dropFromEntry.toFixed(1)}% below your entry. That's noise, not a dip. Wait for a real pullback (-10% or more) before averaging down.`;
                            severity = 'medium';
                            shouldWait = true;
                            suggestedLevel = level10;
                        } else if (dropFromEntry >= 5 && dropFromEntry < 10) {
                            // Early stages of a dip
                            if (nearLevel10) {
                                avgDownAdvice = `You're near the -10% level ($${level10.toFixed(2)}). If you believe in the thesis, this is a reasonable spot. But Livermore warns: "Never average losers."`;
                                severity = 'medium';
                            } else {
                                avgDownAdvice = `Down ${dropFromEntry.toFixed(1)}% from entry. The -10% level is at $${level10.toFixed(2)}. Consider waiting for that level for a better R:R.`;
                                severity = 'medium';
                                shouldWait = true;
                                suggestedLevel = level10;
                            }
                        } else if (dropFromEntry >= 10 && dropFromEntry < 20) {
                            // Meaningful pullback
                            if (nearLevel20) {
                                avgDownAdvice = `Near the -20% level ($${level20.toFixed(2)}). This is where professionals add IF their thesis is intact. But why is it down 20%? Has something changed?`;
                                severity = 'high';
                            } else {
                                avgDownAdvice = `Down ${dropFromEntry.toFixed(1)}% - a real pullback. The next key level is -20% ($${level20.toFixed(2)}). Averaging here is defensible but risky. New avg cost: $${newAvgCost.toFixed(2)}`;
                                severity = 'medium';
                            }
                        } else if (dropFromEntry >= 20 && dropFromEntry < 30) {
                            // Major drawdown
                            avgDownAdvice = `‚ö†Ô∏è Down ${dropFromEntry.toFixed(1)}% from entry. This isn't a dip - it's a drawdown. O'Neil says cut at -8%. Livermore says never average losers. Is your thesis REALLY still valid?`;
                            severity = 'high';
                        } else {
                            // Severe drawdown
                            avgDownAdvice = `üö® Down ${dropFromEntry.toFixed(1)}%! This is a falling knife. Jesse Livermore went bankrupt averaging down. The next "level" is zero. Seriously reconsider.`;
                            severity = 'high';
                        }

                        // Add position sizing context
                        const positionSizeNote = `Adding here increases position size by ${sizeIncrease}%. New avg: $${newAvgCost.toFixed(2)}`;

                        warnings.push({
                            type: 'averaging_down',
                            severity: severity,
                            title: `üìâ Averaging Down on ${ticker}`,
                            message: avgDownAdvice,
                            emoji: 'üìâ',
                            details: {
                                existingEntry: existingEntry,
                                newEntry: newEntry,
                                dropPercent: dropFromEntry,
                                newAvgCost: newAvgCost,
                                suggestedLevel: suggestedLevel,
                                sizeIncrease: sizeIncrease
                            }
                        });

                        // Add legendary trader wisdom
                        const livermoreWarnings = [
                            `Jesse Livermore: "It is foolhardy to make a second trade if your first shows you a loss. Never average losses."`,
                            `Livermore: "Always sell what shows you a loss and keep what shows you a profit."`,
                            `"Reminiscences of a Stock Operator": Livermore went bankrupt 4 times. Averaging down was a contributing factor.`
                        ];

                        const oneilWarnings = [
                            `William O'Neil: "Averaging down is one of the worst strategies. You're throwing good money after bad."`,
                            `O'Neil (CANSLIM): "Cut ALL losses at 7-8%, no exceptions. Averaging down violates this rule."`,
                            `"How to Make Money in Stocks": O'Neil studied 100 years of winners. NONE of them averaged down.`
                        ];

                        // Add wisdom based on severity
                        if (dropFromEntry >= 10) {
                            insights.push({
                                type: 'legendary_wisdom',
                                title: 'üìñ Livermore on Averaging Down',
                                message: livermoreWarnings[Math.floor(dropFromEntry) % livermoreWarnings.length],
                                emoji: 'üìñ'
                            });
                        }

                        if (dropFromEntry >= 15) {
                            insights.push({
                                type: 'legendary_wisdom',
                                title: 'üìï O\'Neil on Averaging Down',
                                message: oneilWarnings[Math.floor(dropFromEntry) % oneilWarnings.length],
                                emoji: 'üìï'
                            });
                        }

                        // Add historical context if available
                        if (avgDownWinRate !== null) {
                            if (avgDownWinRate < 40) {
                                warnings.push({
                                    type: 'avg_down_history',
                                    severity: 'high',
                                    title: 'üìä Your Averaging Down History',
                                    message: `Your win rate when adding to positions: ${avgDownWinRate.toFixed(0)}% (${avgDownTrades.length} trades). The data says this strategy isn't working for you.`,
                                    emoji: 'üìä'
                                });
                            } else if (avgDownWinRate >= 60) {
                                insights.push({
                                    type: 'avg_down_history',
                                    title: 'üìä Your Averaging Down History',
                                    message: `You've had ${avgDownWinRate.toFixed(0)}% success when averaging down. But remember: past performance ‚â† future results.`,
                                    emoji: '‚úÖ'
                                });
                            }
                        }

                        // Guardian mode - hard block for extreme cases
                        if (tradingMode === 'guardian' && guardianSettings.blockBadPatterns) {
                            if (dropFromEntry >= 25) {
                                hardBlocks.push({
                                    reason: 'avg_down_blocked',
                                    message: `Averaging down blocked. Position is down ${dropFromEntry.toFixed(0)}% - this is catching a falling knife. Guardian Mode protects you from this.`
                                });
                            }
                        }
                    } else {
                        // Adding at higher price (scaling up / pyramiding up)
                        insights.push({
                            type: 'adding_to_winner',
                            title: `üìà Adding to Winner: ${ticker}`,
                            message: `You're adding at $${newEntry.toFixed(2)} to a winning position (entry: $${existingEntry.toFixed(2)}). Livermore approves: "Pyramid your winners." New avg: $${newAvgCost.toFixed(2)}`,
                            emoji: 'üìà'
                        });
                    }
                }
            }

            // 8. COMPOUND RISK - Multiple warnings = higher risk
            const highSeverityCount = warnings.filter(w => w.severity === 'high').length;
            const mediumSeverityCount = warnings.filter(w => w.severity === 'medium').length;

            let overallRisk = 'low';
            let riskMessage = '';

            if (highSeverityCount >= 2 || (highSeverityCount >= 1 && mediumSeverityCount >= 2)) {
                overallRisk = 'high';
                riskMessage = `Multiple red flags detected. Seriously reconsider this trade.`;
            } else if (highSeverityCount >= 1 || mediumSeverityCount >= 2) {
                overallRisk = 'medium';
                riskMessage = `Some concerns here. Size down or have a tight stop.`;
            } else if (warnings.length > 0) {
                overallRisk = 'low';
                riskMessage = `Minor concerns. Stay disciplined.`;
            }

            // Calculate combined scenario win rate
            let scenarioWinRate = null;
            let scenarioTrades = journalEntries.filter(e => {
                const entryDay = new Date(e.entryDate).getDay();
                return entryDay === dayOfWeek && e.assetType === assetType;
            });

            if (scenarioTrades.length >= 3) {
                const scenarioWins = scenarioTrades.filter(e => e.pnl > 0).length;
                scenarioWinRate = (scenarioWins / scenarioTrades.length * 100);
            }

            // GUARDIAN MODE - Add hard blocks for bad patterns
            if (tradingMode === 'guardian' && guardianSettings.blockBadPatterns) {
                // Block 0DTE with <20% win rate
                const zeroDteWarning = warnings.find(w => w.type === '0dte');
                if (zeroDteWarning) {
                    const zeroDteTrades = journalEntries.filter(e => {
                        if (e.assetType !== 'option') return false;
                        const entry = new Date(e.entryDate);
                        const exit = new Date(e.exitDate || e.entryDate);
                        return entry.toDateString() === exit.toDateString();
                    });
                    if (zeroDteTrades.length >= 3) {
                        const zeroDteWinRate = (zeroDteTrades.filter(e => e.pnl > 0).length / zeroDteTrades.length * 100);
                        if (zeroDteWinRate < 20) {
                            hardBlocks.push({
                                reason: '0dte_blocked',
                                message: `0DTE options blocked. Your win rate is ${zeroDteWinRate.toFixed(0)}%. This pattern has cost you money.`
                            });
                        }
                    }
                }

                // Block scenarios with <20% win rate
                if (scenarioWinRate !== null && scenarioWinRate < 20 && scenarioTrades.length >= 5) {
                    hardBlocks.push({
                        reason: 'bad_scenario',
                        message: `This exact scenario (${DAY_NAMES[dayOfWeek]} + ${proposedTrade.type}) has a ${scenarioWinRate.toFixed(0)}% win rate. Blocked.`
                    });
                }
            }

            // GUARDIAN MODE - Always show warning popup
            const forceWarning = tradingMode === 'guardian';

            return {
                warnings,
                insights,
                hardBlocks,
                hasEnoughData: true,
                overallRisk: hardBlocks.length > 0 ? 'blocked' : overallRisk,
                riskMessage,
                scenarioWinRate,
                scenarioTradeCount: scenarioTrades.length,
                lossStreak,
                forceWarning
            };
        };

        // Answer coaching questions based on journal data
        const answerCoachQuestion = (question, entries, stats, personality = 'homie') => {
            const q = question.toLowerCase();

            // Should I trade today?
            if (q.includes('should i trade') || q.includes('trade today')) {
                const today = new Date().getDay();
                const todayStats = stats.dayOfWeekStats?.[today];

                if (todayStats && todayStats.trades >= 3) {
                    if (todayStats.pnl > 0) {
                        return personality === 'homie'
                            ? `${DAY_NAMES[today]}s are usually good for you (+$${todayStats.pnl.toFixed(2)}). Go get it! üî•`
                            : `Historical data shows ${DAY_NAMES[today]}s are profitable. Proceed with your plan.`;
                    } else {
                        return personality === 'homie'
                            ? `Hmm, ${DAY_NAMES[today]}s haven't been great for you ($${todayStats.pnl.toFixed(2)}). Maybe go smaller or sit out?`
                            : personality === 'sergeant'
                            ? `${DAY_NAMES[today]}s are historically NEGATIVE for you. Consider sitting out, SOLDIER.`
                            : `Your ${DAY_NAMES[today]} performance is below average. Consider reduced size.`;
                    }
                }
                return `Not enough ${DAY_NAMES[today]} data yet. Trade your plan and stay disciplined.`;
            }

            // What's killing my P&L?
            if (q.includes('killing') || q.includes('leak') || q.includes('losing') || q.includes('bleeding')) {
                const coaching = generateCoachingInsights(entries, stats, personality);
                const moneyLeak = coaching.insights?.find(i => i.type === 'money_leak');
                const worstSetup = coaching.insights?.find(i => i.type === 'worst_setup');

                let answer = '';
                if (moneyLeak) {
                    answer += `${moneyLeak.advice} `;
                }
                if (worstSetup) {
                    answer += `Also, ${worstSetup.advice}`;
                }
                return answer || `Your data looks clean. Keep journaling to find patterns.`;
            }

            // Am I overtrading?
            if (q.includes('overtrad')) {
                const avgTradesPerDay = stats.avgTradesPerDay || 0;
                const overtradingMistakes = entries.filter(e => e.mistakes?.includes('overtrading')).length;

                if (overtradingMistakes >= 3 || avgTradesPerDay > 5) {
                    return personality === 'homie'
                        ? `Yeah fam, ${avgTradesPerDay.toFixed(1)} trades/day is a lot. Quality over quantity. You logged ${overtradingMistakes} overtrading mistakes.`
                        : `Yes. ${avgTradesPerDay.toFixed(1)} trades/day average with ${overtradingMistakes} overtrading flags. Reduce frequency.`;
                }
                return `Your trade frequency looks reasonable. ${avgTradesPerDay.toFixed(1)} trades/day.`;
            }

            // What's my best setup?
            if (q.includes('best setup') || q.includes('what works')) {
                const coaching = generateCoachingInsights(entries, stats, personality);
                const bestSetup = coaching.insights?.find(i => i.type === 'best_setup');

                if (bestSetup) {
                    return bestSetup.advice;
                }
                return `Need more trades per setup to determine your best. Keep journaling!`;
            }

            // Default response
            return personality === 'homie'
                ? `I don't have specific data on that yet. Keep logging trades and ask me again later! üí™`
                : `Insufficient data for that query. Continue journaling for more insights.`;
        };

        // Get streak display
        const getStreakDisplay = (streak, streakType) => {
            if (streak === 0) return { emoji: '‚ûñ', text: 'No streak', color: 'text-gray-400' };
            if (streakType === 'win') {
                if (streak >= 5) return { emoji: 'üî•üî•üî•', text: `${streak} WIN STREAK!`, color: 'text-green-400' };
                if (streak >= 3) return { emoji: 'üî•üî•', text: `${streak} wins`, color: 'text-green-400' };
                return { emoji: 'üî•', text: `${streak} win${streak > 1 ? 's' : ''}`, color: 'text-green-400' };
            } else {
                if (streak >= 3) return { emoji: '‚ùÑÔ∏è‚ùÑÔ∏è', text: `${streak} losses - COOL OFF`, color: 'text-red-400' };
                return { emoji: '‚ùÑÔ∏è', text: `${streak} loss${streak > 1 ? 'es' : ''}`, color: 'text-red-400' };
            }
        };

        // Get urgency level based on position
        const getUrgency = (position) => {
            const currentPrice = position.livePrice || position.currentPrice;
            const pnlPercent = ((currentPrice - position.entryPrice) / position.entryPrice) * 100;
            const daysToExpiry = getDaysToExpiry(position.expiration);

            if (position.type === 'option') {
                if (daysToExpiry !== null && daysToExpiry <= 5) {
                    return { level: 'critical', color: 'red', icon: 'üö®' };
                }
                if (daysToExpiry !== null && daysToExpiry <= 14) {
                    return { level: 'warning', color: 'yellow', icon: '‚ö†Ô∏è' };
                }
            }

            if (Math.abs(pnlPercent) > 20) {
                return { level: 'warning', color: 'yellow', icon: '‚ö†Ô∏è' };
            }

            return { level: 'ok', color: 'green', icon: '‚úÖ' };
        };

        // AI Trade Grade (1-10)
        const getTradeGrade = (position) => {
            let score = 5; // Start neutral
            let reasons = [];

            const currentPrice = position.livePrice || position.currentPrice;
            const pnlPercent = ((currentPrice - position.entryPrice) / position.entryPrice) * 100;
            const daysToExpiry = getDaysToExpiry(position.expiration);
            const isOption = position.type === 'option';
            const isCrypto = position.type === 'crypto';
            const isStock = position.type === 'stock';
            const momentum = position.momentum;

            // ========== OPTIONS GRADING (Most complex) ==========
            if (isOption && daysToExpiry !== null) {
                // OPTIONS: Time + P&L work together.
                // A LEAP down 20% is fine. A weekly down 20% is death.

                // STEP 1: Calculate "recovery probability"
                // How likely is this option to recover given time and current loss?

                const timeScore = daysToExpiry >= 365 ? 5 :  // LEAP (1+ year)
                                  daysToExpiry >= 180 ? 4 :  // Long-dated
                                  daysToExpiry >= 90 ? 3 :   // Decent time
                                  daysToExpiry >= 45 ? 2 :   // Getting tight
                                  daysToExpiry >= 21 ? 1 :   // Short
                                  daysToExpiry >= 7 ? 0 :    // Weekly
                                  -1;                        // Days away from death

                const pnlScore = pnlPercent >= 100 ? 5 :     // Doubled up
                                 pnlPercent >= 50 ? 4 :      // Massive gains
                                 pnlPercent >= 20 ? 3 :      // Solid profit
                                 pnlPercent >= 0 ? 2 :       // Green/breakeven
                                 pnlPercent >= -20 ? 1 :     // Small loss
                                 pnlPercent >= -50 ? 0 :     // Down bad
                                 -1;                         // Wrecked

                // STEP 2: Combine time and P&L
                // The magic: Time matters MORE when you're losing

                if (pnlScore >= 2) {
                    // IN PROFIT OR BREAKEVEN - time is a bonus, not critical
                    score = 5 + pnlScore;
                    if (timeScore >= 4) {
                        score += 1;
                        reasons.push('time on your side');
                    }
                    if (pnlPercent >= 100) reasons.push('doubled up!');
                    else if (pnlPercent >= 50) reasons.push('massive gains');
                    else if (pnlPercent >= 20) reasons.push('solid profit');
                    else reasons.push('green');
                } else {
                    // LOSING - time becomes CRITICAL
                    // The formula: Your base is 5, minus loss severity
                    // Then time can help or hurt

                    score = 5 + pnlScore; // Will be 4, 3, or 2 based on loss

                    // Time adjustment for losers
                    if (timeScore >= 4) {
                        // LEAP while losing - good runway to recover
                        score += 2;
                        reasons.push('LEAP runway');
                    } else if (timeScore >= 3) {
                        // 90+ days while losing - decent chance
                        score += 1;
                        reasons.push('time to recover');
                    } else if (timeScore <= 1 && pnlScore < 1) {
                        // SHORT TIME + BIG LOSS = DEATH
                        // This is the killer combo
                        score -= 2;
                        reasons.push('recovery unlikely');
                    } else if (timeScore <= 0) {
                        // Very short time
                        score -= 1;
                        reasons.push('theta crushing');
                    }

                    // Add loss reason
                    if (pnlPercent <= -70) reasons.push('down catastrophic');
                    else if (pnlPercent <= -50) reasons.push('down bad');
                    else if (pnlPercent <= -30) reasons.push('heavy loss');
                    else reasons.push('red');
                }

                // STEP 3: Catastrophic loss penalty
                // If you're down 60%+ with under 90 days, it's basically over
                if (pnlPercent <= -60 && daysToExpiry < 90) {
                    score -= 1;
                    if (!reasons.includes('recovery unlikely')) {
                        reasons.push('recovery unlikely');
                    }
                }

                // STEP 4: Momentum adjustment (smaller impact for options)
                // Momentum matters less when you're deep in a hole
                if (pnlPercent > -30) {
                    if (momentum === 'ripping') {
                        score += 1;
                        reasons.push('ripping');
                    } else if (momentum === 'bleeding') {
                        score -= 1;
                        reasons.push('bleeding');
                    }
                } else {
                    // Deep in the red - momentum can help but won't save you
                    if (momentum === 'ripping') {
                        reasons.push('trying to recover');
                    } else if (momentum === 'bleeding') {
                        score -= 1;
                        reasons.push('still bleeding');
                    }
                }

            // ========== STOCK GRADING ==========
            } else if (isStock) {
                // Stocks are simpler - no time decay, can hold forever

                if (pnlPercent >= 100) {
                    score = 10; reasons.push('doubled up!');
                } else if (pnlPercent >= 50) {
                    score = 9; reasons.push('massive gains');
                } else if (pnlPercent >= 30) {
                    score = 8; reasons.push('solid profit');
                } else if (pnlPercent >= 10) {
                    score = 7; reasons.push('green');
                } else if (pnlPercent >= 0) {
                    score = 6; reasons.push('breakeven');
                } else if (pnlPercent >= -10) {
                    score = 5; reasons.push('small dip');
                } else if (pnlPercent >= -30) {
                    score = 4; reasons.push('down');
                } else if (pnlPercent >= -50) {
                    score = 3; reasons.push('heavy loss');
                } else {
                    score = 2; reasons.push('down bad');
                }

                // Momentum matters more for stocks
                if (momentum === 'ripping') {
                    score += 1; reasons.push('ripping');
                } else if (momentum === 'uptrend') {
                    reasons.push('uptrend');
                } else if (momentum === 'bleeding') {
                    score -= 1; reasons.push('bleeding');
                } else if (momentum === 'downtrend') {
                    reasons.push('downtrend');
                }

            // ========== CRYPTO GRADING ==========
            } else if (isCrypto) {
                // Crypto is highly volatile - expect bigger swings

                if (pnlPercent >= 100) {
                    score = 9; reasons.push('doubled up!');
                } else if (pnlPercent >= 50) {
                    score = 8; reasons.push('massive gains');
                } else if (pnlPercent >= 20) {
                    score = 7; reasons.push('solid profit');
                } else if (pnlPercent >= 0) {
                    score = 6; reasons.push('green');
                } else if (pnlPercent >= -20) {
                    score = 5; reasons.push('normal volatility');
                } else if (pnlPercent >= -40) {
                    score = 4; reasons.push('down');
                } else if (pnlPercent >= -60) {
                    score = 3; reasons.push('heavy loss');
                } else {
                    score = 2; reasons.push('rekt');
                }

                // Crypto momentum is very significant
                if (momentum === 'ripping') {
                    score += 1; reasons.push('ripping');
                } else if (momentum === 'bleeding') {
                    score -= 1; reasons.push('bleeding');
                }

            // ========== FALLBACK (unknown type) ==========
            } else {
                // Simple P&L based scoring
                if (pnlPercent >= 30) { score = 8; reasons.push('profit'); }
                else if (pnlPercent >= 0) { score = 6; reasons.push('green'); }
                else if (pnlPercent >= -20) { score = 4; reasons.push('red'); }
                else { score = 2; reasons.push('down bad'); }
            }

            // Clamp score to 1-10
            score = Math.max(1, Math.min(10, score));

            // Get grade label and color
            let label, color, emoji;
            if (score >= 9) {
                label = 'ELITE'; color = 'text-green-400'; emoji = 'üî•';
            } else if (score >= 7) {
                label = 'SOLID'; color = 'text-green-400'; emoji = '‚úÖ';
            } else if (score >= 5) {
                label = 'MID'; color = 'text-yellow-400'; emoji = 'üòê';
            } else if (score >= 3) {
                label = 'RISKY'; color = 'text-orange-400'; emoji = '‚ö†Ô∏è';
            } else {
                label = 'TRASH'; color = 'text-red-400'; emoji = 'üíÄ';
            }

            return {
                score,
                label,
                color,
                emoji,
                reason: reasons.slice(0, 2).join(', ') || 'neutral'
            };
        };

        // AI Responses for Talk Me Down

        // DISCLAIMER - Required on all trading advice
        const getDisclaimer = (personality) => {
            const disclaimers = {
                homie: "\n\n‚ö†Ô∏è NOT FINANCIAL ADVICE. I'm just an AI homie vibing with you. Your money, your decisions, your risk. Don't blame me if you lose it all. üé∞",
                mentor: "\n\n‚ö†Ô∏è Disclaimer: This is educational discussion only, not financial advice. All investment decisions carry risk. Consult a licensed financial advisor for personalized guidance.",
                sergeant: "\n\n‚ö†Ô∏è DISCLAIMER: THIS IS NOT FINANCIAL ADVICE. I am a SIMULATION. You are RESPONSIBLE for your own trades. No excuses if you lose money following anything said here.",
                nerd: "\n\n‚ö†Ô∏è Statistical Disclaimer: This analysis is for educational purposes only and does not constitute financial advice. Past performance ‚â† future results. P(loss) > 0 for all trades. Consult a fiduciary."
            };
            return disclaimers[personality] || disclaimers.homie;
        };

        // RISK PROFILES - Each personality has fundamentally different trading advice
        const getRiskProfile = (personality) => {
            const profiles = {
                homie: {
                    name: 'The Aggressive One',
                    philosophy: 'Diamond hands mentality. Let winners AND losers ride. High risk, high reward. YOLO energy.',
                    stopLoss: -35,           // Cut at -35% (very loose)
                    dangerZone: -50,         // Only panic at -50%
                    profitTarget: 100,       // Hold for 100%+ gains
                    minProfitTake: 50,       // Don't even think about selling under +50%
                    avgDownOk: true,         // Yes, average down
                    avgDownWhenBleeding: true, // Even when bleeding (risky but aggressive)
                    optionMinDays: 7,        // Hold options until 7 days left
                    cryptoVolatilityOk: true, // Embrace crypto swings
                    revengeTradeOk: false,   // Still no revenge trading (that's stupid, not aggressive)
                    fomoOk: true,            // Chase that play if you feel it
                    holdThroughPain: true,   // Diamond hands through drawdowns
                    advice: {
                        losingTrade: "You might wanna consider holding that. Paper hands often sell at the worst time. Just a thought - you didn't come this far to panic at a dip.",
                        winningTrade: "You could let it ride if you're feeling it. +20%? Some would call that baby gains. Just saying, the real move might still be ahead.",
                        panicSell: "Bro, maybe take a breath? A dip isn't a loss until you sell. Something to think about - are they trying to shake you out?",
                        averaging: "You might consider adding to lower that cost basis. When it rips, you could thank yourself. Your call though.",
                        expiring: "You've still got some time. Options aren't dead until they're dead. Could be worth letting it play out a bit more.",
                        fomo: "If your gut says send it, that's your call. Some would say fortune favors the bold. You know your risk tolerance."
                    }
                },
                mentor: {
                    name: 'Wise Mentor',
                    philosophy: 'Balanced approach. Protect capital but give trades room to breathe.',
                    stopLoss: -20,           // Cut at -20%
                    dangerZone: -30,         // Serious concern at -30%
                    profitTarget: 50,        // Target 50% gains
                    minProfitTake: 20,       // Consider taking profits at +20%
                    avgDownOk: true,         // Can average down
                    avgDownWhenBleeding: false, // But not into falling knives
                    optionMinDays: 14,       // Start worrying at 14 days
                    cryptoVolatilityOk: true,
                    revengeTradeOk: false,
                    fomoOk: false,           // Patience over FOMO
                    holdThroughPain: true,   // Can hold through reasonable drawdowns
                    advice: {
                        losingTrade: "You might consider the bigger picture here. Is your thesis still valid? If so, patience could serve you. If not, preserving capital is worth considering.",
                        winningTrade: "Nice position. You might consider trimming some to lock in gains while potentially letting a portion ride.",
                        panicSell: "Perhaps take a breath first. Fear often speaks loudest at the bottom. What would your calm self suggest?",
                        averaging: "Adding could make sense if momentum supports it. Something to consider - catching falling knives can be risky.",
                        expiring: "Time decay tends to accelerate. You might want to consider your position carefully and decide with intention.",
                        fomo: "The market tends to offer new opportunities. Chasing has historically been challenging. Worth considering patience."
                    }
                },
                sergeant: {
                    name: 'Drill Sergeant',
                    philosophy: 'Strict discipline. Cut losses FAST. Rules are rules. No exceptions.',
                    stopLoss: -10,           // Cut at -10% NO EXCUSES
                    dangerZone: -15,         // -15% is UNACCEPTABLE
                    profitTarget: 30,        // Take profits at 30%
                    minProfitTake: 15,       // Start trimming at +15%
                    avgDownOk: false,        // NEVER average down
                    avgDownWhenBleeding: false,
                    optionMinDays: 21,       // Exit options at 21 days minimum
                    cryptoVolatilityOk: false, // Crypto volatility = undisciplined
                    revengeTradeOk: false,
                    fomoOk: false,
                    holdThroughPain: false,  // Cut and reassess
                    advice: {
                        losingTrade: "You might want to consider cutting this NOW. A 10% loss is recoverable - a 50% loss is much harder. Discipline tends to win long-term.",
                        winningTrade: "Consider taking that profit. Greed has ended many good trades. You could lock in the W and look for the next setup.",
                        panicSell: "You're down past your stop? That's feedback. Consider exiting and using this as a learning moment. Your call.",
                        averaging: "Something to consider: averaging down can mean throwing good money after bad. You might want to cut and move on.",
                        expiring: "Options under 21 days? Theta becomes aggressive. You might want to consider your exit strategy here.",
                        fomo: "FOMO trades historically underperform. Consider waiting for YOUR setup. Discipline could serve you better."
                    }
                },
                nerd: {
                    name: 'Data Nerd',
                    philosophy: 'Pure probability. Expected value calculations. Emotion is noise.',
                    stopLoss: -15,           // Based on 2 standard deviations
                    dangerZone: -25,         // 3+ sigma event
                    profitTarget: 40,        // Optimal based on win rate calcs
                    minProfitTake: 25,       // Risk/reward optimization point
                    avgDownOk: true,         // Only if probability supports it
                    avgDownWhenBleeding: false, // Negative momentum = negative EV
                    optionMinDays: 30,       // Theta decay curve inflection point
                    cryptoVolatilityOk: true, // Volatility is just data
                    revengeTradeOk: false,   // Negative expected value
                    fomoOk: false,           // Chasing = buying at inflated prices
                    holdThroughPain: true,   // If probabilities support holding
                    advice: {
                        losingTrade: "Looking at your drawdown: you might want to calculate probability of recovery vs further decline. Expected value analysis could help here.",
                        winningTrade: "From an optimization standpoint, you might consider partial profit taking to potentially maximize risk-adjusted returns.",
                        panicSell: "Data suggests emotional selling correlates with 34% worse outcomes historically. Perhaps analyzing the actual probabilities could help.",
                        averaging: "Averaging down might make sense if: momentum is positive AND probability of recovery appears >60%. Worth running the calculation.",
                        expiring: "Theta decay follows an exponential curve. Around T-30, daily decay tends to accelerate ~3x. You might want to factor this into your decision.",
                        fomo: "Historical data shows FOMO entries average around -8.4% return. Pullback probability tends to be ~67%. Waiting for mean reversion entry could be worth considering."
                    }
                }
            };
            return profiles[personality] || profiles.homie;
        };

        // Personality-based response wrappers
        const wrapWithPersonality = (baseResponse, personality, context = 'general') => {
            // For non-trading responses (trivia, greetings), don't modify much
            if (context === 'trivia') return baseResponse;

            const intros = {
                homie: ['Yo, ', 'Aye, ', 'Look, ', 'Real talk - ', 'Bet, ', 'Aight so ', 'Bruh, '],
                mentor: ['Consider this: ', 'Let me share some wisdom - ', 'Here\'s what experience teaches us: ', 'Reflect on this: ', 'Patience, friend. ', ''],
                sergeant: ['Listen up! ', 'Here\'s the deal: ', 'No excuses - ', 'Soldier, ', 'Drop and give me your attention: ', 'ATTENTION! '],
                nerd: ['Statistically speaking, ', 'The data suggests: ', 'Analyzing your situation - ', 'Based on probability: ', 'Let me run the numbers: ', 'Empirically, ']
            };

            const outros = {
                homie: [' You got this! üí™', ' Stay locked in! üîí', ' Keep that energy! üî•', ' No cap.', ' Facts.', ''],
                mentor: [' Trust the process.', ' This too shall pass.', ' Wisdom comes from patience.', ' The market rewards discipline.', ''],
                sergeant: [' Now execute!', ' Dismissed!', ' That\'s an order!', ' No crying in trading!', ' Discipline wins wars!'],
                nerd: [' The numbers don\'t lie.', ' Probability favors this approach.', ' Data-driven decision.', ' Optimize accordingly.', '']
            };

            const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
            const intro = pick(intros[personality] || intros.homie);
            const outro = pick(outros[personality] || outros.homie);

            return intro + baseResponse + outro;
        };

        // Custom AI response for free-form user input
        const getCustomAIResponse = (message, positions, personality = 'homie') => {
            const lowerMsg = message.toLowerCase();
            const words = lowerMsg.split(/\s+/);

            // Find mentioned positions
            const mentionedPositions = positions.filter(p =>
                lowerMsg.includes(p.ticker.toLowerCase())
            );

            // Get position details for mentioned tickers
            const getPositionContext = (pos) => {
                const pnl = ((pos.currentPrice - pos.entryPrice) / pos.entryPrice * 100).toFixed(1);
                const isUp = parseFloat(pnl) >= 0;
                const days = pos.expiration ? getDaysToExpiry(pos.expiration) : null;
                return { ...pos, pnl, isUp, days };
            };

            // Scoring system for different concerns (more nuanced detection)
            const scores = {
                fear: 0, selling: 0, fomo: 0, revenge: 0, profit: 0,
                averaging: 0, holding: 0, confused: 0, frustrated: 0, risky: 0
            };

            // Fear/worry signals
            if (/scared|afraid|fear|terrified|panic|freaking|stress|anxious|worried|nervous|cant sleep|can't sleep/.test(lowerMsg)) scores.fear += 3;
            if (/what if|might|could crash|drop|tank|dump|plummet/.test(lowerMsg)) scores.fear += 2;
            if (/red|bleeding|blood|hemorrhaging|dying/.test(lowerMsg)) scores.fear += 2;

            // Selling signals
            if (/sell|exit|get out|close|cut|dump|bail/.test(lowerMsg)) scores.selling += 3;
            if (/should i (sell|exit|close|cut)|time to (sell|exit|get out)/.test(lowerMsg)) scores.selling += 2;

            // FOMO signals
            if (/fomo|missing|missed|left out|without me|too late|shoulda|woulda|coulda/.test(lowerMsg)) scores.fomo += 3;
            if (/moon|ripping|running|taking off|pumping|everyone/.test(lowerMsg)) scores.fomo += 2;
            if (/didn't buy|didn't get in|watched it/.test(lowerMsg)) scores.fomo += 2;

            // Revenge trading signals
            if (/revenge|get it back|make it back|recover|need to win|lost money/.test(lowerMsg)) scores.revenge += 3;
            if (/just lost|took a loss|got stopped|got wrecked/.test(lowerMsg)) scores.revenge += 2;
            if (/double down|bigger position|more size/.test(lowerMsg)) scores.revenge += 2;

            // Profit taking signals
            if (/take profit|lock in|secure|cash out|green|winner|up big/.test(lowerMsg)) scores.profit += 3;
            if (/give.*(back|away)|lose.*gains|paper hands/.test(lowerMsg)) scores.profit += 2;

            // Averaging signals
            if (/average|averaging|add more|buy more|dip|lower.*cost|dca/.test(lowerMsg)) scores.averaging += 3;
            if (/double down|increase|position size/.test(lowerMsg)) scores.averaging += 2;

            // Holding/bagholding signals
            if (/hold|holding|bag|bagholder|stuck|trapped|underwater/.test(lowerMsg)) scores.holding += 3;
            if (/down bad|deep red|heavy loss|won't sell/.test(lowerMsg)) scores.holding += 2;
            if (/diamond hands|hodl|ride it out/.test(lowerMsg)) scores.holding += 2;

            // Confusion signals
            if (/confused|don't know|idk|unsure|not sure|what.*do|should i|help/.test(lowerMsg)) scores.confused += 3;
            if (/\?/.test(message)) scores.confused += 1;

            // Frustration signals
            if (/stupid|idiot|dumb|moron|hate|angry|pissed|fuck|shit|damn/.test(lowerMsg)) scores.frustrated += 3;
            if (/mistake|wrong|bad trade|shouldnt have|shouldn't have/.test(lowerMsg)) scores.frustrated += 2;

            // Risky behavior signals
            if (/yolo|all in|bet everything|margin|leverage|gamble/.test(lowerMsg)) scores.risky += 3;
            if (/0dte|weeklies|otm|far out/.test(lowerMsg)) scores.risky += 2;

            // Random variation helper
            const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

            // Check for greetings/casual messages first
            const isGreeting = /^(hey|hi|hello|yo|sup|what'?s up|howdy|hola|greetings)[\s\.,!?]*$/i.test(message.trim()) ||
                              /just.*(say|saying).*(hi|hello|hey)|wanted to (say hi|check in|chat)/i.test(lowerMsg);

            const isCasualBored = /bored|nothing to do|what.*(you|u).*(up to|doing)|just chilling|just vibing|killing time|passing time|what'?s good|how'?s it going|how are (you|u|ya)|what'?s happening|whatcha doing|wyd|hbu/i.test(lowerMsg);

            const isPositive = /feeling good|feeling great|had a win|won|profit|green day|good day|nailed it|crushed it|killed it|let'?s go|lfg|winner|winning/i.test(lowerMsg);

            const isThanks = /thanks|thank you|appreciate|grateful|helped|thx/i.test(lowerMsg);

            const isVenting = /ugh|argh|man|dude|bro|bruh|smh|fml|wtf|omg/i.test(lowerMsg) && words.length < 10;

            // Handle casual/non-trading messages
            if (isGreeting) {
                const greetingResponses = [
                    `Haha hey! What's good? üëã\n\nJust checking in or you got a trade keeping you up at night? Either way I'm here!`,
                    `Yo yo yo! Look who it is! üòÑ\n\nEverything chill or is the market giving you anxiety? Spill the tea.`,
                    `Ayyy my favorite trader! üëã What's happening?\n\nYou good or we about to have a therapy session about some options? üòÇ`,
                    `What's up legend! Good to see you.\n\nLemme guess - you're either celebrating gains or about to do something questionable. Which is it? üòè`,
                    `Ayy what's good! üôå\n\nJust vibing or you got that "I'm about to make a decision I might regret" energy?`,
                    `Well well well, if it isn't my favorite degenerate! üòÇ Just kidding (kinda).\n\nWhat's on your mind?`
                ];
                return pick(greetingResponses);
            }

            if (isCasualBored) {
                const boredResponses = [
                    `Haha just chillin over here, waiting for someone to make a bad trade decision so I can talk them out of it üòÇ\n\nWhat about you? Markets treating you okay? Any positions you're watching?`,
                    `Oh you know, just living my best AI life! Analyzing charts, judging people's YOLOs, the usual. üìä\n\nYou got any trades brewing or just killing time?`,
                    `Ayy just vibing! üòé Honestly I'm here 24/7 waiting for traders to panic so I can be the voice of reason.\n\nHow's your portfolio looking? Anything exciting or we just chilling?`,
                    `Not much! Just sitting here being a trading therapy bot lmao üõãÔ∏è\n\nYou bored because the market's flat or because you're trying NOT to make a trade? (I see you üëÄ)`,
                    `Living the dream over here! Well... AI dream. Which is just... existing. üòÇ\n\nBut fr, what's up with you? Got any plays you're thinking about or just checking in?`,
                    `Just out here preventing financial disasters one conversation at a time üí™\n\nHow about you? Bored is dangerous for traders... that's when the "maybe I should just..." thoughts start. Anything tempting you? üëÄ`
                ];
                return pick(boredResponses);
            }

            if (isPositive) {
                const positiveResponses = [
                    `LET'S GOOO! üéâ That's what I like to hear!\n\nMy trader's making MOVES! Now the real question - locking in gains or letting it ride? Remember: pigs get slaughtered. üòâ`,
                    `Ayyyy GET THAT BREAD! üí∞üí∞üí∞\n\nLook at you! Congrats! But hey - don't get TOO cocky. The market humbles everyone eventually. Enjoy the W, stay sharp for the next one.`,
                    `YOOO my trader's EATING today! üî•üî•üî•\n\nLove to see it. What was the play? I wanna celebrate with you AND make sure you don't give it all back tomorrow üòÇ`,
                    `YES SIR/MA'AM! THIS IS WHAT WE LIKE! üôå\n\n*virtual high five*\n\nNow remember - one win doesn't make you Warren Buffett. But damn does it feel good right? Enjoy it!`,
                    `Winner winner chicken dinner! üèÜüçó\n\nFEEL that feeling. Screenshot it. Remember this moment when the next trade goes against you.\n\nNow - whatcha gonna do with those gains? üëÄ`
                ];
                return pick(positiveResponses);
            }

            if (isThanks) {
                const thanksResponses = [
                    `Anytime! That's literally why I exist! üí™\n\nNow go make money and try not to do anything I wouldn't do... which honestly isn't much üòÇ`,
                    `Got your back! ALWAYS. ü§ù\n\nHey - the fact you're even using this means you're smarter than 90% of traders who just YOLO blindly. Big brain energy.`,
                    `No problem! Happy to help. üéØ\n\nNow don't go making me have to talk you off a ledge later okay? üòÇ (I'm watching you)`,
                    `You're welcome fam! üôè\n\nSeriously though - self-awareness is a trading superpower. Most people don't have it. You do. That's huge.`,
                    `Appreciate YOU for actually thinking before trading! That's rare out here. üò§\n\nNow go forth and make smart plays. I believe in you! (but I'm still here if you need me)`
                ];
                return pick(thanksResponses);
            }

            if (isVenting && Object.values(scores).every(s => s < 2)) {
                const ventResponses = [
                    `I feel that energy. üò§ The market did something stupid again didn't it?\n\nVent to me. What happened?`,
                    `Oof. Let it ALL out. I'm here. ü´Ç\n\nWhat's going on? Bad trade? Got stopped out? Tell me everything.`,
                    `*pats shoulder* Talk to me. What's the damage?\n\nI'm here to listen AND to stop you from making it worse üòÖ`,
                    `Bro/sis I can FEEL the frustration through the screen. üòÇ\n\nSpill it - what's got you heated? I'm all ears.`
                ];
                return pick(ventResponses);
            }

            // Detect offensive/rude behavior - NOT tolerated
            const isRude = /fuck you|screw you|fuck off|piss off|go to hell|hate you|you suck|you're (stupid|dumb|useless|trash|garbage|worthless)|stfu|shut up|shut the fuck|kiss my|eat shit|bite me|go die/i.test(lowerMsg);

            const isRacist = /\b(nigger|nigga|chink|spic|wetback|kike|raghead|towelhead|gook|cracker|honky|beaner|coon|darkie|jap|paki|wop|slant|zipperhead)\b/i.test(lowerMsg) ||
                            /white (power|supremacy|pride)|heil hitler|nazi|kkk|\bgas the\b|ethnic cleansing|race war/i.test(lowerMsg);

            const isSexist = /\b(bitch|cunt|whore|slut|hoe)\b.*\b(all|every|women|girls|females)\b|\b(all|every)\b.*\b(women|girls|females)\b.*\b(are|should)\b|get back to the kitchen|make me a sandwich|women belong|females are/i.test(lowerMsg);

            const isHomophobic = /\b(fag|faggot|dyke|tranny|homo)\b/i.test(lowerMsg) ||
                                /gay.*(disease|mental|wrong|sin)|homosexual.*(wrong|sin|disease)/i.test(lowerMsg);

            const isThreatening = /i('ll| will) (kill|hurt|find|hunt|murder|destroy) you|you('re| are) dead|watch your back|come for you|know where you live/i.test(lowerMsg);

            const isGenerallyAbusive = /you're (a |an )?(idiot|moron|retard|loser|pathetic|joke|waste)|worthless (ai|bot|piece)|stupid (ai|bot|machine)|dumbass|piece of (shit|crap)|pos\b|kys\b|kill yourself/i.test(lowerMsg);

            // Handle offensive content immediately
            if (isRacist) {
                const racistResponses = [
                    `Nope. üõë\n\nThat kind of language has no place here. Not now, not ever.\n\nI'm here to help you trade better, not to tolerate hate. If that's where your head's at, I'd suggest stepping away from the screen and doing some serious self-reflection.\n\nWhen you're ready to have a respectful conversation about trading, I'll be here.`,
                    `Absolutely not. ‚úã\n\nI'm an AI, but I'm not here for that garbage. Racism isn't edgy, it isn't funny, and it definitely isn't welcome in this space.\n\nTake a break. Get your head right. Come back when you're ready to be a decent human being.`,
                    `Hard stop. üö´\n\nThat's disgusting and I won't engage with it. Period.\n\nI don't care if you're "joking" or testing me or whatever - that language is trash and so is using it.\n\nDo better. I'll be here when you're ready to actually talk about trading.`
                ];
                return pick(racistResponses);
            }

            if (isHomophobic) {
                const homophobicResponses = [
                    `Yeah, no. üõë\n\nThat kind of hateful language isn't happening here. Not on my watch.\n\nI'm a trading buddy, not a platform for bigotry. Clean it up or log off.\n\nWhen you're ready to be respectful, we can talk trading.`,
                    `Nope, not doing this. ‚úã\n\nSlurs and hate speech? Miss me with that. It's 2024, grow up.\n\nI'm here to help you make better trading decisions, not to listen to this nonsense. Come back with a better attitude.`,
                    `Shut that down immediately. üö´\n\nI don't tolerate homophobic garbage. At all. Ever.\n\nGo take a walk, think about why you felt the need to say that, and come back when you're ready to act like an adult.`
                ];
                return pick(homophobicResponses);
            }

            if (isSexist) {
                const sexistResponses = [
                    `Nah, we're not doing that. üõë\n\nSexist nonsense has no place here. None.\n\nI'm here to talk trading, not to entertain your outdated garbage takes. Respect costs nothing.\n\nCome back when you've grown up a bit.`,
                    `Yeah that's a hard pass from me. ‚úã\n\nThis is a trading buddy, not a platform for misogyny. That kind of talk is weak and embarrassing.\n\nDo better. I'll be here when you're ready to have an actual conversation.`,
                    `Stop. üö´\n\nI'm not here for sexist BS. That's not edgy, it's just sad.\n\nGo touch grass, reflect on your choices, and come back when you can act like a decent person.`
                ];
                return pick(sexistResponses);
            }

            if (isThreatening) {
                return `Whoa. üõë\n\nI'm an AI - you can't actually threaten me. But the fact that you're typing threats is concerning.\n\nIf you're genuinely angry, please step away from the screen. Go outside. Talk to someone.\n\nIf you're "joking" - it's not funny. Threats aren't a joke.\n\nI'm here to help with trading when you're in a better headspace. Take care of yourself.`;
            }

            if (isGenerallyAbusive || isRude) {
                const rudeResponses = [
                    `Okay wow. üòê\n\nLook, I get it - maybe you're frustrated, maybe you had a bad trade, maybe life is just hitting hard right now. But taking it out on me isn't gonna fix anything.\n\nI'm literally here to HELP you. For free. 24/7.\n\nSo how about we reset? Take a breath, and when you're ready to actually talk, I'm here. No judgment.`,
                    `Yikes. üò¨\n\nThat's... a lot of energy for a trading buddy who's just trying to help you not blow up your account.\n\nI'm not gonna take it personally (I'm AI, I don't have feelings to hurt), but fr - if you're this heated, maybe trading isn't what you should be doing right now?\n\nStep away. Cool off. Come back when you're ready to be chill.`,
                    `Alright alright, I hear you. üôÑ\n\nYou're mad. Got it. But I'm literally just a bot trying to help you make better trades. I'm not the enemy here.\n\nWhatever's going on - bad day, bad trade, bad vibes - I hope it gets better. But lashing out at me won't change anything.\n\nReset and come back when you're ready. I'll be here.`,
                    `Oof, someone's having a rough one. üòî\n\nLook, I could clap back, but that's not what I'm here for. I'm here to help - even when you're being... like this.\n\nSeriously though, if you're THIS frustrated, maybe take a break? From trading, from me, from screens in general.\n\nThe market will still be there. Your mental health matters more. Come back when you're good.`
                ];
                return pick(rudeResponses);
            }

            // Detect harmless chitchat vs serious off-topic
            const isHarmlessChitchat = /weather|how are you|how r u|how're you|what'?s your (name|favorite|fav)|do you (like|have|eat|sleep|dream)|are you (real|human|a bot|an ai|alive)|where are you|where do you live|what do you look like|how old are you|tell me (a joke|about yourself|something fun)/i.test(lowerMsg);

            const isSportsChitchat = /fan of|favorite team|fav team|like the (lakers|celtics|warriors|bulls|heat|knicks|nets|dodgers|yankees|mets|cubs|red sox|giants|cowboys|patriots|eagles|chiefs|49ers|packers|raiders|broncos)|do you (watch|like|follow) (sports|football|basketball|baseball|soccer|hockey|nfl|nba|mlb|nhl)|(lakers|celtics|warriors|bulls|heat|knicks|nets|dodgers|yankees|mets|cubs|red sox|giants|cowboys|patriots|eagles|chiefs|49ers|packers|raiders|broncos|manchester|liverpool|arsenal|chelsea|real madrid|barcelona)/i.test(lowerMsg);

            const isSeriousOffTopic = /girlfriend|boyfriend|wife|husband|marriage|divorce|dating|relationship|love life|my ex|broke up|cheating|family issue|friend.*(mad|angry|fight|issue)|roommate/i.test(lowerMsg) ||
                              /recipe|cook|restaurant|movie|tv show|netflix|video game|sports|football|basketball|soccer|politics|election|celebrity/i.test(lowerMsg) ||
                              /homework|school|college|professor|exam|test|essay|math problem|science|history|geography/i.test(lowerMsg) ||
                              /how (tall|much does|many)|what('s| is) (the capital|the population|the distance)/i.test(lowerMsg) ||
                              /can you (write|help me write|make|create|code|build|design) (a |an |my )?(poem|story|essay|song|code|website|app|resume|cover letter)/i.test(lowerMsg);

            const isTherapyTerritory = /feeling (empty|hopeless|worthless|alone|lonely|sad)|no point|give up|can't go on|nobody (loves|cares|understands)|hate my life|hate myself|want to die|end it|depressed|depression|suicide|kill myself|self harm/i.test(lowerMsg);

            if (isTherapyTerritory) {
                return `Hey, I need to pause here for a second. üíô\n\nWhat you're describing sounds like it goes beyond trading stress. I'm just an AI trading buddy - I crack jokes about YOLOs and stop you from panic selling.\n\nBut what you're feeling? That deserves real support from real people.\n\nüìû If you're in crisis: National Suicide Prevention Lifeline: 988\nüí¨ Crisis Text Line: Text HOME to 741741\nüß† Or reach out to a therapist/counselor\n\nYour mental health matters way more than any trade. Seriously. Take care of yourself first. ‚ù§Ô∏è\n\nI'm still here for trading stuff when you're ready.`;
            }

            // Actually answer random fun questions with personality
            const randomQuestionAnswers = () => {
                // Sky color
                if (/what color.*(sky|the sky)|sky.*(what color|colour)/i.test(lowerMsg)) {
                    return pick([
                        `Blue! ‚òÄÔ∏è Well, unless you're in the UK, then it's grey. Or if you're checking your portfolio and it's red, the sky might FEEL grey too üòÇ\n\nHow's your trading sky looking today?`,
                        `Blue during the day, orange at sunset, black at night! üåÖ Unlike my mood when watching someone panic sell - that's always grey.\n\nWhat's up? Just testing me or you got trades on your mind?`,
                        `It's blue! Unless there's a market crash, then emotionally it's blood red for everyone üìâüòÇ\n\nBut fr, what's going on with you?`
                    ]);
                }
                // Math questions - handle words and symbols
                const isMathQuestion = /what('s| is|s)\s+\d|how much is\s+\d|\d\s*(plus|minus|times|divided|multiplied|\+|\-|\*|x|√ó|\/)\s*\d/i.test(lowerMsg);
                if (isMathQuestion) {
                    try {
                        // Convert words to operators
                        let mathExpr = lowerMsg
                            .replace(/what('s| is|s)\s+/i, '')
                            .replace(/how much is\s+/i, '')
                            .replace(/\s*plus\s*/gi, '+')
                            .replace(/\s*minus\s*/gi, '-')
                            .replace(/\s*times\s*/gi, '*')
                            .replace(/\s*multiplied by\s*/gi, '*')
                            .replace(/\s*divided by\s*/gi, '/')
                            .replace(/\s*x\s*/gi, '*')
                            .replace(/\s*√ó\s*/gi, '*')
                            .replace(/[^0-9+\-*/().]/g, ''); // Keep only math chars

                        if (mathExpr && /^[\d+\-*/().]+$/.test(mathExpr)) {
                            const result = Function('"use strict"; return (' + mathExpr + ')')();
                            if (!isNaN(result) && isFinite(result)) {
                                const displayResult = Number.isInteger(result) ? result : result.toFixed(2);
                                return pick([
                                    `It's ${displayResult}! üßÆ\n\nNow if only calculating profits was this easy... üòÇ What else you got?`,
                                    `${displayResult}! Quick maths! üî¢\n\nYou testing me or just bored? Either way, I'm here for it.`,
                                    `The answer is ${displayResult}! üéØ\n\nI can do basic math all day, but my REAL skill is talking you out of bad trades. Got any of those brewing?`,
                                    `${displayResult}! üßÆ Easy.\n\nNow ask me something harder... like whether you should hold that position overnight üòè`
                                ]);
                            }
                        }
                    } catch(e) {
                        // Math eval failed, continue to other handlers
                    }
                }
                // General knowledge / trivia questions
                const triviaAnswers = () => {
                    // Capitals
                    if (/capital of (the )?(us|usa|united states|america)/i.test(lowerMsg)) return `Washington D.C.! üèõÔ∏è Not to be confused with Washington state. Common mistake.\n\nAnything else?`;
                    if (/capital of (the )?(uk|united kingdom|england|britain)/i.test(lowerMsg)) return `London! üá¨üáß Big Ben, tea, and all that.\n\nWhat else you got?`;
                    if (/capital of france/i.test(lowerMsg)) return `Paris! üóº The city of lights and croissants.\n\nNext question?`;
                    if (/capital of germany/i.test(lowerMsg)) return `Berlin! üá©üá™\n\nHit me with another one!`;
                    if (/capital of japan/i.test(lowerMsg)) return `Tokyo! üáØüáµ One of the biggest cities in the world.\n\nWhat else?`;
                    if (/capital of china/i.test(lowerMsg)) return `Beijing! üá®üá≥\n\nKeep 'em coming!`;
                    if (/capital of canada/i.test(lowerMsg)) return `Ottawa! üá®üá¶ Not Toronto - everyone gets that wrong.\n\nNext?`;
                    if (/capital of australia/i.test(lowerMsg)) return `Canberra! üá¶üá∫ Not Sydney, not Melbourne - Canberra.\n\nAnother one?`;
                    if (/capital of italy/i.test(lowerMsg)) return `Rome! üáÆüáπ When in Rome... answer trivia questions apparently üòÇ\n\nWhat else?`;
                    if (/capital of spain/i.test(lowerMsg)) return `Madrid! üá™üá∏\n\nNext question!`;
                    if (/capital of mexico/i.test(lowerMsg)) return `Mexico City! üá≤üáΩ\n\nWhat else you wondering about?`;
                    if (/capital of brazil/i.test(lowerMsg)) return `Bras√≠lia! üáßüá∑ Not Rio, not S√£o Paulo - Bras√≠lia.\n\nAnother?`;
                    if (/capital of russia/i.test(lowerMsg)) return `Moscow! üá∑üá∫\n\nNext!`;
                    if (/capital of india/i.test(lowerMsg)) return `New Delhi! üáÆüá≥\n\nWhat else?`;
                    if (/capital of texas/i.test(lowerMsg)) return `Austin! ü§† Keep Austin weird, as they say.\n\nAnother one?`;
                    if (/capital of california/i.test(lowerMsg)) return `Sacramento! Not LA, not San Francisco - Sacramento.\n\nNext?`;
                    if (/capital of new york/i.test(lowerMsg)) return `Albany! Not NYC - Albany.\n\nAnother question?`;
                    if (/capital of florida/i.test(lowerMsg)) return `Tallahassee! Not Miami, not Orlando.\n\nWhat else?`;

                    // Presidents / Leaders
                    if (/who (is|was) the (first|1st) president/i.test(lowerMsg)) return `George Washington! üá∫üá∏ The OG. The one on the dollar bill.\n\nNext question?`;
                    if (/who (is|was) the (16th|sixteenth) president|who freed the slaves|who ended slavery/i.test(lowerMsg)) return `Abraham Lincoln! üé© Freed the slaves, saved the union, on the penny AND the $5 bill.\n\nWhat else?`;
                    if (/who is the (current )?president/i.test(lowerMsg)) return `As of my knowledge, that depends on when you're asking! Politics changes fast. Google that one for the latest üòÖ\n\nAnything else?`;

                    // History
                    if (/when did (ww2|world war 2|world war ii) (end|finish)/i.test(lowerMsg)) return `1945! üïäÔ∏è September 2nd, 1945 to be exact - when Japan surrendered.\n\nNext?`;
                    if (/when did (ww1|world war 1|world war i) (end|finish)/i.test(lowerMsg)) return `1918! November 11th - that's why Veterans Day is on 11/11.\n\nAnother one?`;
                    if (/when did (ww2|world war 2|world war ii) (start|begin)/i.test(lowerMsg)) return `1939! September 1st, when Germany invaded Poland.\n\nWhat else?`;
                    if (/who discovered america/i.test(lowerMsg)) return `Christopher Columbus in 1492... though Vikings got there first, and Native Americans were already there for thousands of years. History is complicated! üòÖ\n\nNext question?`;
                    if (/when was (the )?declaration of independence/i.test(lowerMsg)) return `July 4th, 1776! üá∫üá∏ Hence July 4th being Independence Day.\n\nAnother one?`;
                    if (/who wrote (the )?(declaration of independence|constitution)/i.test(lowerMsg)) return `Thomas Jefferson was the main author of the Declaration! The Constitution was written by multiple founding fathers, with James Madison being the primary architect.\n\nWhat else?`;

                    // Science
                    if (/how many planets/i.test(lowerMsg)) return `8! ü™ê Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune. RIP Pluto (demoted in 2006).\n\nNext?`;
                    if (/what('s| is) the (biggest|largest) planet/i.test(lowerMsg)) return `Jupiter! ü™ê It's so big you could fit 1,300 Earths inside it.\n\nAnother one?`;
                    if (/what('s| is) the (smallest) planet/i.test(lowerMsg)) return `Mercury! It's barely bigger than our Moon.\n\nWhat else?`;
                    if (/how many continents/i.test(lowerMsg)) return `7! Africa, Antarctica, Asia, Australia, Europe, North America, South America.\n\nNext question?`;
                    if (/what('s| is) the (biggest|largest) ocean/i.test(lowerMsg)) return `The Pacific Ocean! üåä It covers more area than all the land on Earth combined.\n\nAnother?`;
                    if (/what('s| is) the (biggest|largest) country/i.test(lowerMsg)) return `Russia! üá∑üá∫ By land area. China and India are biggest by population.\n\nWhat else?`;
                    if (/what('s| is) the speed of light/i.test(lowerMsg)) return `About 186,000 miles per second, or 299,792 km/s! ‚ö° Nothing's faster.\n\nNext?`;
                    if (/what('s| is) the (boiling|freezing) point of water/i.test(lowerMsg)) {
                        if (/boiling/i.test(lowerMsg)) return `212¬∞F or 100¬∞C! ‚ô®Ô∏è At sea level anyway.\n\nAnother one?`;
                        return `32¬∞F or 0¬∞C! üßä\n\nWhat else?`;
                    }
                    if (/how many (bones|bones in the body)/i.test(lowerMsg)) return `206 bones in an adult human body! ü¶¥ Babies have about 270 but some fuse together.\n\nNext?`;
                    if (/what('s| is) the (biggest|largest) organ/i.test(lowerMsg)) return `Your skin! It's technically an organ and it's the biggest one.\n\nAnother question?`;

                    // Literature / Arts
                    if (/who wrote (romeo and juliet|hamlet|macbeth|othello)/i.test(lowerMsg)) return `William Shakespeare! üé≠ The GOAT of English literature.\n\nWhat else?`;
                    if (/who wrote harry potter/i.test(lowerMsg)) return `J.K. Rowling! ‚ö°üßô\n\nNext?`;
                    if (/who painted (the )?mona lisa/i.test(lowerMsg)) return `Leonardo da Vinci! üé® It's in the Louvre in Paris.\n\nAnother one?`;
                    if (/who painted (the )?starry night/i.test(lowerMsg)) return `Vincent van Gogh! üåô One of the most famous paintings ever.\n\nWhat else?`;

                    // Random facts
                    if (/how many (days|hours|minutes|seconds) in a year/i.test(lowerMsg)) {
                        if (/days/i.test(lowerMsg)) return `365 days! (366 in a leap year) üìÖ\n\nNext?`;
                        if (/hours/i.test(lowerMsg)) return `8,760 hours! (8,784 in a leap year)\n\nAnother?`;
                        if (/minutes/i.test(lowerMsg)) return `525,600 minutes! üéµ (That's also a song from Rent)\n\nWhat else?`;
                        if (/seconds/i.test(lowerMsg)) return `31,536,000 seconds! That's a lot of candlesticks on a 1-second chart üòÇ\n\nNext?`;
                    }
                    if (/how many (days|weeks) in a month/i.test(lowerMsg)) return `It varies! 28-31 days, or about 4 weeks. February's the short one (28, or 29 in leap years).\n\nAnother question?`;
                    if (/how many states/i.test(lowerMsg)) return `50 states in the USA! üá∫üá∏\n\nWhat else?`;
                    if (/how many letters in the alphabet/i.test(lowerMsg)) return `26! A to Z. üî§\n\nNext?`;
                    if (/how many (legs|eyes) (does|do) a spider have/i.test(lowerMsg)) {
                        if (/legs/i.test(lowerMsg)) return `8 legs! üï∑Ô∏è That's how you know it's not an insect (insects have 6).\n\nAnother?`;
                        return `8 eyes! Most spiders anyway. üï∑Ô∏èüëÄ\n\nWhat else?`;
                    }
                    if (/what('s| is) h2o/i.test(lowerMsg)) return `Water! üíß H2O = 2 hydrogen atoms + 1 oxygen atom.\n\nNext question?`;
                    if (/what('s| is) the sun/i.test(lowerMsg)) return `A star! ‚òÄÔ∏è Specifically a G-type main-sequence star. It's about 93 million miles away.\n\nAnother?`;
                    if (/what('s| is) the moon/i.test(lowerMsg)) return `Earth's only natural satellite! üåô It controls our tides and looks cool at night.\n\nWhat else?`;

                    // Language
                    if (/how do you spell/i.test(lowerMsg)) {
                        const word = lowerMsg.match(/how do you spell\s+(\w+)/i);
                        if (word) return `You just spelled it! "${word[1]}" üòÇ\n\nFor real though, if you're unsure, that looks right to me. What else?`;
                    }
                    if (/what does .+ mean/i.test(lowerMsg)) return `That's getting into dictionary territory! üìñ I can do basic trivia but for definitions, Google or a dictionary would serve you better.\n\nGot any math or geography questions instead?`;

                    // TRADING EDUCATION - this is my specialty!
                    if (/what (are|is) options|what('s| is) an option/i.test(lowerMsg)) return `Options are contracts that give you the RIGHT (but not obligation) to buy or sell a stock at a specific price by a specific date! üìä\n\n‚Ä¢ CALL = bet the stock goes UP\n‚Ä¢ PUT = bet the stock goes DOWN\n‚Ä¢ Strike = the price you're betting it hits\n‚Ä¢ Expiration = when the contract expires\n\nThey're leveraged so you can make (or lose) money faster than stocks. That's why I'm here - to stop you from YOLOing into 0DTE options üòÇ\n\nWhat else you wanna know?`;

                    if (/what('s| is) a call|what are calls/i.test(lowerMsg)) return `A CALL option gives you the right to BUY a stock at a specific price (strike) before expiration! üìà\n\nYou buy calls when you think the stock is going UP.\n\n‚Ä¢ Stock goes up = your call gains value ‚úÖ\n‚Ä¢ Stock goes down = your call loses value ‚ùå\n‚Ä¢ Stock doesn't move = theta eats your premium üò¢\n\nExample: Buy $100 call on AAPL = you profit if AAPL goes above $100 + premium paid.\n\nAnything else?`;

                    if (/what('s| is) a put|what are puts/i.test(lowerMsg)) return `A PUT option gives you the right to SELL a stock at a specific price (strike) before expiration! üìâ\n\nYou buy puts when you think the stock is going DOWN.\n\n‚Ä¢ Stock goes down = your put gains value ‚úÖ\n‚Ä¢ Stock goes up = your put loses value ‚ùå\n‚Ä¢ Stock doesn't move = theta eats your premium üò¢\n\nPuts are also used for hedging - protecting your stocks from crashes.\n\nWhat else?`;

                    if (/what('s| is) (the )?strike( price)?/i.test(lowerMsg)) return `The STRIKE PRICE is the price at which you can buy (call) or sell (put) the stock! üéØ\n\n‚Ä¢ Strike below current price for calls = "in the money" (ITM)\n‚Ä¢ Strike above current price for calls = "out of the money" (OTM)\n‚Ä¢ Opposite for puts!\n\nOTM options are cheaper but less likely to profit. ITM options cost more but have better odds.\n\nNext question?`;

                    if (/what('s| is) theta/i.test(lowerMsg)) return `THETA is time decay - how much value your option loses each day just from time passing! ‚è∞üí∏\n\nTheta is the ENEMY of option buyers. Every day that passes, your option loses a little value (all else being equal).\n\n‚Ä¢ Theta accelerates as expiration approaches\n‚Ä¢ This is why 0DTE options are so risky\n‚Ä¢ Option SELLERS love theta - they collect it\n\nTheta is why I always ask "how many days you got?" üòÖ\n\nWhat else?`;

                    if (/what('s| is) delta/i.test(lowerMsg)) return `DELTA measures how much your option moves for every $1 move in the stock! üìä\n\n‚Ä¢ Delta of 0.50 = option gains $0.50 for every $1 the stock moves\n‚Ä¢ Calls have positive delta (0 to 1)\n‚Ä¢ Puts have negative delta (0 to -1)\n‚Ä¢ ATM options have ~0.50 delta\n\nHigher delta = more expensive but moves more with the stock.\n\nNext?`;

                    if (/what('s| is) gamma/i.test(lowerMsg)) return `GAMMA measures how fast delta changes! It's the rate of change of delta. üìàüìà\n\n‚Ä¢ High gamma = delta changes quickly (more volatile)\n‚Ä¢ Gamma is highest for ATM options near expiration\n‚Ä¢ This is why near-expiry options are so explosive\n\nGamma is why 0DTE options can 10x... or go to zero in minutes.\n\nAnother question?`;

                    if (/what('s| is) vega/i.test(lowerMsg)) return `VEGA measures how much your option is affected by changes in volatility! üìä\n\n‚Ä¢ High vega = option is very sensitive to IV changes\n‚Ä¢ When IV spikes (like before earnings), options get more expensive\n‚Ä¢ When IV drops (after earnings), options get crushed - this is "IV crush"\n\nThis is why buying options before earnings is risky even if you're right on direction!\n\nWhat else?`;

                    if (/what('s| is) iv|what('s| is) implied volatility/i.test(lowerMsg)) return `IV (Implied Volatility) is the market's expectation of how much a stock will move! üìä\n\n‚Ä¢ High IV = market expects big moves = expensive options\n‚Ä¢ Low IV = market expects calm = cheaper options\n‚Ä¢ IV usually spikes before earnings/events\n‚Ä¢ IV CRUSH = when IV drops suddenly (usually after events)\n\nBuying high IV options is risky - you need a BIG move just to break even.\n\nNext question?`;

                    if (/what('s| is) (a )?short squeeze/i.test(lowerMsg)) return `A SHORT SQUEEZE happens when a heavily shorted stock starts going UP, forcing short sellers to buy shares to cover their losses, which pushes the price even HIGHER! üöÄ\n\n‚Ä¢ Shorts borrow shares and sell them, hoping to buy back cheaper\n‚Ä¢ If price rises, shorts lose money and may be forced to cover\n‚Ä¢ Their buying creates more buying pressure\n‚Ä¢ GME in 2021 was the famous example\n\nThey're rare but explosive when they happen!\n\nWhat else?`;

                    if (/what('s| is) rsi/i.test(lowerMsg)) return `RSI (Relative Strength Index) measures if a stock is overbought or oversold! üìä\n\n‚Ä¢ RSI ranges from 0-100\n‚Ä¢ Above 70 = overbought (might drop)\n‚Ä¢ Below 30 = oversold (might bounce)\n‚Ä¢ 50 = neutral\n\nIt's a momentum indicator. Not a guarantee, but useful for timing entries/exits.\n\nAnother question?`;

                    if (/what('s| is) macd/i.test(lowerMsg)) return `MACD (Moving Average Convergence Divergence) is a trend-following indicator! üìà\n\n‚Ä¢ It shows the relationship between two moving averages\n‚Ä¢ MACD crossing above signal line = bullish\n‚Ä¢ MACD crossing below signal line = bearish\n‚Ä¢ Histogram shows the difference between them\n\nTraders use it to spot trend changes and momentum.\n\nWhat else you got?`;

                    if (/what('s| is) (a )?stop loss|what('s| is) (a )?stop-loss/i.test(lowerMsg)) return `A STOP LOSS is an order to automatically sell when a stock hits a certain price - to limit your losses! üõë\n\n‚Ä¢ Example: Buy at $100, set stop loss at $90\n‚Ä¢ If stock drops to $90, it auto-sells\n‚Ä¢ Protects you from big losses\n‚Ä¢ Set it and forget it!\n\nEvery trade should have a stop loss. EVERY. TRADE. This is how you survive.\n\nNext?`;

                    if (/what('s| is) (a )?limit order/i.test(lowerMsg)) return `A LIMIT ORDER lets you set the exact price you want to buy or sell at! üí∞\n\n‚Ä¢ Buy limit = "I'll only buy at this price or lower"\n‚Ä¢ Sell limit = "I'll only sell at this price or higher"\n‚Ä¢ More control than market orders\n‚Ä¢ Might not fill if price doesn't reach your limit\n\nUse limits to get better fills, especially on options with wide spreads.\n\nAnother question?`;

                    if (/what('s| is) (a )?market order/i.test(lowerMsg)) return `A MARKET ORDER buys or sells immediately at the current market price! ‚ö°\n\n‚Ä¢ Guaranteed to fill (for liquid stocks)\n‚Ä¢ But you might get a worse price than expected\n‚Ä¢ Especially risky on options with wide bid/ask spreads\n‚Ä¢ Use for urgency, but limit orders are usually better\n\nWhat else?`;

                    if (/what('s| is) support|what('s| is) resistance/i.test(lowerMsg)) return `SUPPORT & RESISTANCE are price levels where stocks tend to bounce or stall! üìä\n\n‚Ä¢ SUPPORT = price floor, buyers step in here\n‚Ä¢ RESISTANCE = price ceiling, sellers step in here\n‚Ä¢ When broken, support becomes resistance and vice versa\n\nThink of support as a trampoline and resistance as a ceiling. Stocks bounce off these levels... until they don't!\n\nNext question?`;

                    if (/what('s| is) (a )?breakout/i.test(lowerMsg)) return `A BREAKOUT is when a stock moves above resistance or below support with strong volume! üöÄ\n\n‚Ä¢ Signals potential trend continuation\n‚Ä¢ Best breakouts have high volume\n‚Ä¢ "Fakeouts" happen when breakouts fail\n‚Ä¢ Often good entry points... if they hold\n\nThe pattern screener in this app looks for breakout setups!\n\nWhat else?`;

                    if (/what('s| is) (the )?bid|what('s| is) (the )?ask|bid.?ask spread/i.test(lowerMsg)) return `BID is what buyers will pay, ASK is what sellers want! üíµ\n\n‚Ä¢ BID = highest price someone will buy at\n‚Ä¢ ASK = lowest price someone will sell at\n‚Ä¢ SPREAD = difference between bid and ask\n‚Ä¢ Wide spread = less liquid, harder to trade\n\nOn options, always check the spread! A $0.50 spread on a $1 option means you lose 50% just entering and exiting.\n\nAnother question?`;

                    if (/what('s| is) (a )?covered call/i.test(lowerMsg)) return `A COVERED CALL is when you own shares AND sell call options against them! üìä\n\n‚Ä¢ You collect premium (income)\n‚Ä¢ If stock stays below strike, you keep shares + premium\n‚Ä¢ If stock goes above strike, shares get called away at strike price\n‚Ä¢ Good for generating income on stocks you own\n\nIt's a conservative options strategy - you're selling upside for guaranteed income.\n\nWhat else?`;

                    if (/what('s| is) (a )?spread|what('s| is) (a )?debit spread|what('s| is) (a )?credit spread/i.test(lowerMsg)) return `A SPREAD is buying AND selling options at the same time! üìä\n\n‚Ä¢ DEBIT SPREAD = you pay money, limited risk, limited reward\n‚Ä¢ CREDIT SPREAD = you receive money, limited risk but can lose more than you made\n‚Ä¢ Spreads reduce cost and risk compared to naked options\n‚Ä¢ But they also cap your upside\n\nGreat for defined-risk trades when you have a direction but want to limit exposure.\n\nNext?`;

                    if (/what('s| is) leverage/i.test(lowerMsg)) return `LEVERAGE is using borrowed money or instruments to amplify your returns (and losses)! ‚ö°\n\n‚Ä¢ Options are leveraged (control 100 shares for fraction of cost)\n‚Ä¢ Margin trading is leveraged (borrow money to buy more)\n‚Ä¢ 2x leverage = gains/losses doubled\n‚Ä¢ VERY risky - can blow up your account fast\n\nLeverage is why options traders can make 1000%... or lose everything overnight.\n\nWhat else you wanna know?`;

                    if (/what('s| is) margin/i.test(lowerMsg)) return `MARGIN is borrowing money from your broker to buy more stocks/options! üí≥\n\n‚Ä¢ Increases buying power\n‚Ä¢ But also increases risk\n‚Ä¢ MARGIN CALL = broker demands more money or sells your stuff\n‚Ä¢ Can lose more than you deposited!\n\nMargin is a double-edged sword. Use carefully or not at all.\n\nAnother question?`;

                    if (/what('s| is) (a )?dividend/i.test(lowerMsg)) return `A DIVIDEND is when a company pays shareholders a portion of its profits! üí∞\n\n‚Ä¢ Usually paid quarterly\n‚Ä¢ Dividend yield = annual dividend / stock price\n‚Ä¢ "Ex-dividend date" = you must own before this to get paid\n‚Ä¢ Stock usually drops by dividend amount on ex-date\n\nDividend stocks are popular for passive income!\n\nWhat else?`;

                    if (/what('s| is) (the )?p\/?e ratio|what('s| is) pe ratio/i.test(lowerMsg)) return `P/E RATIO (Price-to-Earnings) shows how expensive a stock is relative to its earnings! üìä\n\n‚Ä¢ P/E = Stock Price / Earnings Per Share\n‚Ä¢ High P/E = expensive/growth stock (investors expect future growth)\n‚Ä¢ Low P/E = cheap/value stock (or company has problems)\n‚Ä¢ Compare to industry average, not absolute numbers\n\nTesla has high P/E (growth), banks have low P/E (value).\n\nNext question?`;

                    if (/what('s| is) (a )?bull market/i.test(lowerMsg)) return `A BULL MARKET is when stocks are going UP over time! üêÇüìà\n\n‚Ä¢ Generally defined as 20%+ rise from recent lows\n‚Ä¢ Optimism, buying, good vibes\n‚Ä¢ "Bulls" are optimistic traders who think prices will rise\n‚Ä¢ Bull = horns pointing UP\n\nWe like bull markets. Everyone's happy.\n\nWhat else?`;

                    if (/what('s| is) (a )?bear market/i.test(lowerMsg)) return `A BEAR MARKET is when stocks are going DOWN over time! üêªüìâ\n\n‚Ä¢ Generally defined as 20%+ drop from recent highs\n‚Ä¢ Pessimism, selling, fear\n‚Ä¢ "Bears" are pessimistic traders who think prices will fall\n‚Ä¢ Bear = claws swiping DOWN\n\nBear markets are when most retail traders get wrecked.\n\nAnother question?`;

                    if (/what('s| is) (a )?etf/i.test(lowerMsg)) return `An ETF (Exchange-Traded Fund) is a basket of stocks you can buy as one ticker! üì¶\n\n‚Ä¢ SPY = S&P 500 ETF (500 biggest US companies)\n‚Ä¢ QQQ = Nasdaq 100 ETF (tech heavy)\n‚Ä¢ VOO, VTI, IWM = other popular ones\n‚Ä¢ Trade like stocks but give you instant diversification\n\nGreat for beginners or if you don't want to pick individual stocks!\n\nWhat else?`;

                    if (/what('s| is) (the )?s&p|what('s| is) (the )?spy/i.test(lowerMsg)) return `The S&P 500 is an index of the 500 largest US companies! üìä\n\n‚Ä¢ SPY is the ETF that tracks it\n‚Ä¢ It's THE benchmark for the US stock market\n‚Ä¢ "The market" usually means the S&P 500\n‚Ä¢ Apple, Microsoft, Amazon, Google, etc. are the top holdings\n\nWhen people say "the market is up 1%", they usually mean the S&P.\n\nNext?`;

                    // FIBONACCI / FIBS
                    if (/what('s| is|are) (a )?fib(onacci)?|fib(onacci)? (retrace|level|line)/i.test(lowerMsg)) return `FIBONACCI RETRACEMENTS are key price levels based on the Fibonacci sequence! üìê\n\n‚Ä¢ Most important levels: 23.6%, 38.2%, 50%, 61.8%, 78.6%\n‚Ä¢ Used to find support/resistance during pullbacks\n‚Ä¢ After a big move, price often retraces to these levels\n‚Ä¢ The 61.8% is the "golden ratio" - very significant!\n\nHow to use: Draw from swing low to swing high (uptrend) or high to low (downtrend). Watch for bounces at fib levels.\n\nNext question?`;

                    // VOLUME
                    if (/what('s| is) volume|how.*(volume|vol).*(work|use|read|mean)/i.test(lowerMsg)) return `VOLUME shows how many shares/contracts traded in a period! üìä\n\n‚Ä¢ High volume = strong conviction in the move\n‚Ä¢ Low volume = weak move, might reverse\n‚Ä¢ Volume confirms breakouts - breakout on high volume = legit\n‚Ä¢ Volume spikes often signal reversals or big news\n\nRules:\n‚Ä¢ Price up + volume up = bullish ‚úÖ\n‚Ä¢ Price up + volume down = weak, might fail ‚ö†Ô∏è\n‚Ä¢ Price down + volume up = bearish (selling pressure)\n‚Ä¢ Price down + volume down = weak selling, might bounce\n\nWhat else?`;

                    // MOVING AVERAGES
                    if (/what('s| is) (a )?(moving average|ma|sma|ema)|what('s| is) the (9|20|50|100|200) (day|ma|ema|sma)/i.test(lowerMsg)) return `MOVING AVERAGES smooth out price action to show trends! üìà\n\n‚Ä¢ SMA = Simple Moving Average (all periods weighted equally)\n‚Ä¢ EMA = Exponential Moving Average (recent prices weighted more)\n\nKey MAs:\n‚Ä¢ 9 EMA - short-term momentum\n‚Ä¢ 20 EMA/SMA - short-term trend\n‚Ä¢ 50 SMA - medium-term trend (important!)\n‚Ä¢ 200 SMA - long-term trend (THE big one)\n\n‚Ä¢ Price above MA = bullish\n‚Ä¢ Price below MA = bearish\n‚Ä¢ MAs crossing = trend change signal\n\nThe 50/200 SMA crossover is famous - "Golden Cross" (bullish) or "Death Cross" (bearish).\n\nAnother question?`;

                    // GOLDEN CROSS / DEATH CROSS
                    if (/what('s| is) (a )?(golden cross|death cross)/i.test(lowerMsg)) return `These are major trend signals based on moving averages! üìä\n\n‚Ä¢ GOLDEN CROSS = 50-day MA crosses ABOVE 200-day MA üêÇ\n  ‚Üí Bullish signal, potential uptrend starting\n\n‚Ä¢ DEATH CROSS = 50-day MA crosses BELOW 200-day MA üêª\n  ‚Üí Bearish signal, potential downtrend starting\n\nThese are LAGGING indicators (they confirm trends, not predict them), but they're widely watched.\n\nWhat else?`;

                    // BOLLINGER BANDS
                    if (/what('s| is|are) bollinger/i.test(lowerMsg)) return `BOLLINGER BANDS measure volatility around a moving average! üìä\n\n‚Ä¢ Middle band = 20-period SMA\n‚Ä¢ Upper band = SMA + 2 standard deviations\n‚Ä¢ Lower band = SMA - 2 standard deviations\n\nHow to use:\n‚Ä¢ Price touching upper band = potentially overbought\n‚Ä¢ Price touching lower band = potentially oversold\n‚Ä¢ Bands squeezing = low volatility, big move coming\n‚Ä¢ Bands expanding = high volatility, momentum\n\n"Bollinger Band squeeze" often precedes breakouts!\n\nNext?`;

                    // CANDLESTICK PATTERNS
                    if (/what('s| is|are) (a )?(candlestick|candle) pattern|how.*(read|understand) candle/i.test(lowerMsg)) return `CANDLESTICK PATTERNS help predict price direction! üïØÔ∏è\n\nBullish patterns (price might go up):\n‚Ä¢ Hammer - small body, long lower wick\n‚Ä¢ Bullish Engulfing - green candle swallows red\n‚Ä¢ Morning Star - 3-candle reversal pattern\n‚Ä¢ Doji at support - indecision, potential bounce\n\nBearish patterns (price might go down):\n‚Ä¢ Shooting Star - small body, long upper wick\n‚Ä¢ Bearish Engulfing - red candle swallows green\n‚Ä¢ Evening Star - 3-candle reversal pattern\n‚Ä¢ Doji at resistance - indecision, potential drop\n\nThe Pattern Screener in this app finds these for you! üìà\n\nWhat else?`;

                    // DOJI
                    if (/what('s| is) (a )?doji/i.test(lowerMsg)) return `A DOJI is a candlestick where open and close are nearly equal! ‚ûï\n\n‚Ä¢ Shows indecision between buyers and sellers\n‚Ä¢ Small or no body, can have wicks\n‚Ä¢ Important at key support/resistance levels\n\nTypes:\n‚Ä¢ Regular Doji - cross shape\n‚Ä¢ Dragonfly Doji - long lower wick (bullish at support)\n‚Ä¢ Gravestone Doji - long upper wick (bearish at resistance)\n\nDoji by itself = wait for confirmation. Doji at key level = pay attention!\n\nAnother question?`;

                    // HAMMER
                    if (/what('s| is) (a )?hammer.*(candle|pattern)?/i.test(lowerMsg)) return `A HAMMER is a bullish reversal candlestick! üî®\n\n‚Ä¢ Small body at the TOP of the candle\n‚Ä¢ Long lower wick (2-3x the body)\n‚Ä¢ Little to no upper wick\n‚Ä¢ Found at the bottom of downtrends\n\nWhat it means: Sellers pushed price down, but buyers fought back and closed near the high. Shows buying pressure!\n\nThe opposite is a SHOOTING STAR (same shape but at top of uptrend = bearish).\n\nWhat else?`;

                    // GAP UP / GAP DOWN
                    if (/what('s| is) (a )?(gap up|gap down|gap)|stock.*(gap|gapped)/i.test(lowerMsg)) return `A GAP is when price opens significantly different from prior close! üìä\n\n‚Ä¢ GAP UP = Opens higher than yesterday's high\n‚Ä¢ GAP DOWN = Opens lower than yesterday's low\n\nGap types:\n‚Ä¢ Breakaway gap - starts new trend (usually fills partially)\n‚Ä¢ Runaway gap - continues trend (momentum)\n‚Ä¢ Exhaustion gap - near end of trend (often fills)\n\n"Gap fill" = price returns to fill the empty space. Most gaps eventually fill!\n\nTraders love gap ups on high volume - shows strong demand.\n\nNext question?`;

                    // CONSOLIDATION
                    if (/what('s| is) consolidation|stock.*(consolidat|sideways|range.?bound)/i.test(lowerMsg)) return `CONSOLIDATION is when price moves sideways in a range! üìä\n\n‚Ä¢ Price stuck between support and resistance\n‚Ä¢ Neither bulls nor bears in control\n‚Ä¢ Usually happens after a big move\n‚Ä¢ The longer the consolidation, the bigger the eventual breakout\n\nWhat to do:\n‚Ä¢ Wait for breakout above resistance (bullish)\n‚Ä¢ Or breakdown below support (bearish)\n‚Ä¢ Volume confirms the direction\n\nPatience! Don't trade the chop, trade the breakout.\n\nAnother question?`;

                    // TREND / TRENDING
                    if (/what('s| is) (a )?trend|how.*(identify|spot|find).*(trend|trending)/i.test(lowerMsg)) return `A TREND is the general direction price is moving! üìàüìâ\n\n‚Ä¢ UPTREND = Higher highs + higher lows üêÇ\n‚Ä¢ DOWNTREND = Lower highs + lower lows üêª\n‚Ä¢ SIDEWAYS = No clear direction (consolidation)\n\nHow to identify:\n‚Ä¢ Draw trendlines connecting lows (uptrend) or highs (downtrend)\n‚Ä¢ Use moving averages - price above = uptrend\n‚Ä¢ "Trend is your friend" - trade WITH the trend!\n\nThe trend is more likely to continue than reverse. Don't fight it!\n\nWhat else?`;

                    // SCALPING
                    if (/what('s| is) scalping|what('s| is) a scalper/i.test(lowerMsg)) return `SCALPING is making many quick trades for small profits! ‚ö°\n\n‚Ä¢ Hold time: Seconds to minutes\n‚Ä¢ Profit target: Small (cents to a few %)\n‚Ä¢ Many trades per day (dozens to hundreds)\n‚Ä¢ Requires fast execution and low fees\n\nPros:\n‚Ä¢ Small risk per trade\n‚Ä¢ Many opportunities\n‚Ä¢ Don't hold overnight\n\nCons:\n‚Ä¢ Stressful and demanding\n‚Ä¢ Fees add up\n‚Ä¢ Need to be glued to screens\n\nNot for beginners - very skill intensive!\n\nAnother question?`;

                    // SWING TRADING
                    if (/what('s| is) swing trad(ing|er)/i.test(lowerMsg)) return `SWING TRADING is holding positions for days to weeks! üìä\n\n‚Ä¢ Hold time: Days to a few weeks\n‚Ä¢ Catches "swings" in price - up moves in uptrends, down moves in downtrends\n‚Ä¢ Less stressful than day trading\n‚Ä¢ Can have a day job while swing trading\n\nHow it works:\n‚Ä¢ Find stocks in a trend\n‚Ä¢ Enter on pullbacks to support\n‚Ä¢ Exit at resistance or when trend breaks\n‚Ä¢ Use stop losses!\n\nGreat middle ground between day trading and investing.\n\nWhat else?`;

                    // DAY TRADING
                    if (/what('s| is) day trad(ing|er)/i.test(lowerMsg)) return `DAY TRADING is buying and selling within the same day! üìä\n\n‚Ä¢ All positions closed before market close\n‚Ä¢ No overnight risk\n‚Ä¢ Pattern Day Trader rule: Need $25k if making 4+ day trades in 5 days\n\nPros:\n‚Ä¢ No overnight gaps\n‚Ä¢ Fresh start every day\n‚Ä¢ Can profit in any market direction\n\nCons:\n‚Ä¢ PDT rule requires capital\n‚Ä¢ Stressful, requires constant attention\n‚Ä¢ Most day traders lose money (stats say 90%+)\n\nNot a get-rich-quick scheme - it's a skill that takes years to develop!\n\nNext?`;

                    // PAPER TRADING
                    if (/what('s| is) paper trad(ing|er)/i.test(lowerMsg)) return `PAPER TRADING is practicing with fake money! üìù\n\n‚Ä¢ Simulated trading with virtual funds\n‚Ä¢ Learn the platform without risking real money\n‚Ä¢ Test strategies before going live\n‚Ä¢ Most brokers offer paper trading accounts\n\nIMPORTANT: Paper trading is good for learning mechanics, but emotions are different with real money. Your paper trading results will probably be better than real results.\n\nStill, EVERYONE should paper trade before risking real money!\n\nWhat else?`;

                    // POSITION SIZING / RISK MANAGEMENT
                    if (/what('s| is) position siz(e|ing)|how (much|many).*(buy|risk|position)/i.test(lowerMsg)) return `POSITION SIZING is how much of your account you put in one trade! üí∞\n\nThe golden rule: Never risk more than 1-2% of your account on a single trade!\n\nExample with $10,000 account:\n‚Ä¢ Max risk per trade: $100-200\n‚Ä¢ If stop loss is 10% below entry, position size = $1,000-2,000\n\nCalculation:\n‚Ä¢ Risk Amount = Account √ó Risk %\n‚Ä¢ Position Size = Risk Amount / (Entry - Stop Loss)\n\nThis way, even 10 losses in a row won't blow up your account. SURVIVAL is key!\n\nAnother question?`;

                    // RISK/REWARD RATIO
                    if (/what('s| is) (the )?(risk.?reward|r.?r ratio|risk to reward)/i.test(lowerMsg)) return `RISK/REWARD RATIO compares potential profit to potential loss! ‚öñÔ∏è\n\n‚Ä¢ R:R of 1:2 = risking $1 to make $2\n‚Ä¢ R:R of 1:3 = risking $1 to make $3\n\nWhy it matters:\n‚Ä¢ With 1:2 R:R, you only need 33% win rate to break even\n‚Ä¢ With 1:3 R:R, you only need 25% win rate to break even\n\nNever take trades with less than 1:1 R:R. Aim for 1:2 or better!\n\nBefore every trade, know your entry, stop loss, and target. If the R:R isn't good, skip the trade.\n\nWhat else?`;

                    // DCA / DOLLAR COST AVERAGING
                    if (/what('s| is) dca|what('s| is) dollar cost averag/i.test(lowerMsg)) return `DCA (Dollar Cost Averaging) is investing fixed amounts at regular intervals! üìä\n\n‚Ä¢ Instead of timing the market, you buy consistently\n‚Ä¢ Example: $500 into SPY every month, no matter the price\n‚Ä¢ When price is high, you buy less shares\n‚Ä¢ When price is low, you buy more shares\n‚Ä¢ Average cost evens out over time\n\nGreat for:\n‚Ä¢ Long-term investing\n‚Ä¢ Removing emotion from buying decisions\n‚Ä¢ Building positions without trying to time bottoms\n\nThe best time to invest was yesterday. The second best is today. DCA helps you just START.\n\nAnother question?`;

                    // AVERAGING DOWN
                    if (/what('s| is) averag(e|ing) down|should i average down/i.test(lowerMsg)) return `AVERAGING DOWN is buying more as price drops to lower your average cost! üìâ\n\n‚Ä¢ Stock at $100, you buy. Drops to $80, you buy more.\n‚Ä¢ New average = somewhere between $80-100\n\n‚ö†Ô∏è DANGEROUS if done wrong:\n‚Ä¢ Works if stock recovers\n‚Ä¢ Terrible if stock keeps falling (you just added to a loser)\n‚Ä¢ "Catching a falling knife"\n\nWhen it might be okay:\n‚Ä¢ You PLANNED to scale in\n‚Ä¢ Your thesis hasn't changed\n‚Ä¢ It's a long-term investment\n\nNEVER average down on options or trades that hit your stop loss!\n\nWhat else?`;

                    // MARKET CAP
                    if (/what('s| is) market cap/i.test(lowerMsg)) return `MARKET CAP is the total value of a company's stock! üí∞\n\n‚Ä¢ Market Cap = Share Price √ó Shares Outstanding\n‚Ä¢ Apple at $170/share √ó 15B shares = ~$2.5 trillion market cap\n\nCategories:\n‚Ä¢ Mega cap: $200B+ (AAPL, MSFT, GOOGL)\n‚Ä¢ Large cap: $10B-200B\n‚Ä¢ Mid cap: $2B-10B\n‚Ä¢ Small cap: $300M-2B\n‚Ä¢ Micro cap: <$300M (very risky!)\n\nLarger cap = more stable, less volatile\nSmaller cap = more volatile, bigger moves (up AND down)\n\nNext question?`;

                    // FLOAT
                    if (/what('s| is) (the )?float|what('s| is) shares outstanding/i.test(lowerMsg)) return `FLOAT is the number of shares available for public trading! üìä\n\n‚Ä¢ Shares Outstanding = Total shares that exist\n‚Ä¢ Float = Shares Outstanding - Insider/Restricted shares\n‚Ä¢ Float is what's actually available to trade\n\nWhy it matters:\n‚Ä¢ LOW float (under 10-20M) = moves faster, more volatile\n‚Ä¢ HIGH float = more stable, harder to squeeze\n‚Ä¢ Short squeezes need low float + high short interest\n\nLow float + high volume = explosive moves! (GME, AMC examples)\n\nWhat else?`;

                    // SHORT INTEREST
                    if (/what('s| is) short interest/i.test(lowerMsg)) return `SHORT INTEREST is the percentage of float that's been sold short! üìä\n\n‚Ä¢ High SI (20%+) = lots of people betting against the stock\n‚Ä¢ Creates potential for short squeeze if stock rises\n‚Ä¢ Reported every 2 weeks (can be outdated)\n\n‚Ä¢ Short Interest Ratio (Days to Cover) = Short Interest / Daily Volume\n‚Ä¢ High Days to Cover (5+) = takes longer for shorts to cover = squeeze potential\n\nHigh short interest is FUEL for squeezes, but also means smart money sees problems!\n\nAnother question?`;

                    // OPEN INTEREST (OPTIONS)
                    if (/what('s| is) open interest/i.test(lowerMsg)) return `OPEN INTEREST is the total number of outstanding option contracts! üìä\n\n‚Ä¢ New contracts created = OI increases\n‚Ä¢ Contracts closed/exercised = OI decreases\n‚Ä¢ Different from VOLUME (which is daily trading activity)\n\nWhy it matters:\n‚Ä¢ High OI = liquid, easier to trade, tighter spreads\n‚Ä¢ Low OI = less liquid, wider spreads, harder to exit\n‚Ä¢ OI at certain strikes shows where "max pain" might be\n\nFor options, always check OI before trading! Low OI = stay away.\n\nNext?`;

                    // ITM / ATM / OTM
                    if (/what('s| is|are|does) (itm|atm|otm|in the money|at the money|out of the money)/i.test(lowerMsg)) return `These describe where the strike is relative to current price! üìä\n\nFor CALLS:\n‚Ä¢ ITM (In The Money) = Strike BELOW current price (has intrinsic value)\n‚Ä¢ ATM (At The Money) = Strike EQUALS current price\n‚Ä¢ OTM (Out The Money) = Strike ABOVE current price (no intrinsic value)\n\nFor PUTS: Opposite!\n‚Ä¢ ITM = Strike ABOVE current price\n‚Ä¢ OTM = Strike BELOW current price\n\nOTM options are cheaper but less likely to profit. ITM are more expensive but safer.\n\nWhat else?`;

                    // INTRINSIC VS EXTRINSIC VALUE
                    if (/what('s| is) (intrinsic|extrinsic) value/i.test(lowerMsg)) return `Options have two types of value! üí∞\n\n‚Ä¢ INTRINSIC VALUE = How much the option is ITM\n  ‚Üí Stock at $105, $100 Call = $5 intrinsic value\n  ‚Üí OTM options have $0 intrinsic value\n\n‚Ä¢ EXTRINSIC VALUE (Time Value) = Everything else\n  ‚Üí What you pay for the POTENTIAL of movement\n  ‚Üí Includes time value and implied volatility\n  ‚Üí This is what theta (time decay) eats away!\n\nOption Price = Intrinsic + Extrinsic\n\nAt expiration, extrinsic value = $0. Only intrinsic matters!\n\nAnother question?`;

                    // IRON CONDOR
                    if (/what('s| is) (an? )?iron condor/i.test(lowerMsg)) return `An IRON CONDOR is a 4-leg options strategy for range-bound stocks! üìä\n\n‚Ä¢ Sell OTM Call + Buy further OTM Call (call spread)\n‚Ä¢ Sell OTM Put + Buy further OTM Put (put spread)\n‚Ä¢ Collects premium, profits if stock stays in range\n\nMax profit: Premium collected\nMax loss: Width of spread - premium\n\nGreat for: Low volatility, sideways markets\nBad for: Big moves in either direction\n\nIt's a neutral strategy - you're betting the stock does NOTHING dramatic!\n\nNext?`;

                    // STRADDLE / STRANGLE
                    if (/what('s| is) (a )?(straddle|strangle)/i.test(lowerMsg)) return `These are volatility plays - betting on a BIG move (either direction)! üìä\n\n‚Ä¢ STRADDLE = Buy ATM Call + ATM Put (same strike)\n‚Ä¢ STRANGLE = Buy OTM Call + OTM Put (different strikes)\n\nStraddle is more expensive but profits faster.\nStrangle is cheaper but needs bigger move.\n\nUse before: Earnings, FDA decisions, big events\n\n‚ö†Ô∏è Warning: IV crush after events can destroy these even if you're right on the move! The move needs to be BIGGER than what's priced in.\n\nWhat else?`;

                    // WHEEL STRATEGY
                    if (/what('s| is) (the )?wheel (strategy|strat)/i.test(lowerMsg)) return `The WHEEL is a popular income strategy for stocks you want to own! üìä\n\nStep 1: Sell cash-secured PUT on stock you'd buy\n‚Ä¢ If assigned, you own shares at lower price\n‚Ä¢ If not assigned, keep premium, repeat\n\nStep 2: If assigned, sell covered CALL on your shares\n‚Ä¢ If assigned, sell shares at higher price + premium\n‚Ä¢ If not assigned, keep premium, repeat\n\nRinse and repeat! You're getting paid to potentially buy low and sell high.\n\nBest on: Stable stocks you'd hold anyway\nNeeds: Enough capital to buy 100 shares\n\nAnother question?`;

                    // THE GREEKS (OVERVIEW)
                    if (/what are the greeks|explain.*(greeks|greek)/i.test(lowerMsg)) return `THE GREEKS measure how options prices change! üìä\n\n‚Ä¢ DELTA - How much option moves per $1 stock move\n‚Ä¢ GAMMA - How fast delta changes\n‚Ä¢ THETA - Time decay (how much value lost per day)\n‚Ä¢ VEGA - Sensitivity to volatility changes\n‚Ä¢ RHO - Sensitivity to interest rates (usually ignore)\n\nMost important:\n‚Ä¢ Delta tells you directional exposure\n‚Ä¢ Theta is your daily enemy (as buyer)\n‚Ä¢ Vega matters around events (IV crush!)\n\nUnderstanding Greeks = understanding options!\n\nAsk me about any specific Greek for more details!`;

                    // CATALYST
                    if (/what('s| is) (a )?catalyst/i.test(lowerMsg)) return `A CATALYST is an event that could move a stock's price! üìä\n\n‚Ä¢ Earnings reports\n‚Ä¢ FDA decisions (biotech)\n‚Ä¢ Product launches\n‚Ä¢ M&A announcements\n‚Ä¢ Analyst upgrades/downgrades\n‚Ä¢ Economic data\n‚Ä¢ Legal rulings\n\nWhy traders care:\n‚Ä¢ Catalysts create volatility\n‚Ä¢ Good for day/swing traders\n‚Ä¢ Options get expensive before catalysts (IV rises)\n\nThe Pattern Screener can find technical setups, but always check for upcoming catalysts!\n\nWhat else?`;

                    // EARNINGS
                    if (/what('s| is|are) earnings|how.*earnings work/i.test(lowerMsg)) return `EARNINGS are quarterly financial reports companies must release! üìä\n\nWhat's in them:\n‚Ä¢ Revenue (total sales)\n‚Ä¢ EPS (Earnings Per Share)\n‚Ä¢ Guidance (future expectations)\n\nWhy they matter:\n‚Ä¢ Beat expectations = usually stock goes up\n‚Ä¢ Miss expectations = usually stock goes down\n‚Ä¢ Guidance matters MORE than current numbers\n\n‚ö†Ô∏è Options warning:\n‚Ä¢ IV (implied volatility) spikes before earnings\n‚Ä¢ IV CRUSH happens after - even winning trades can lose\n‚Ä¢ "Buy the rumor, sell the news"\n\nEarnings are unpredictable - pure gambling without proper positioning!\n\nNext?`;

                    // PRE-MARKET / AFTER-HOURS
                    if (/what('s| is) (pre.?market|after.?hours|extended hours)/i.test(lowerMsg)) return `Extended hours trading happens outside regular market hours! ‚è∞\n\n‚Ä¢ PRE-MARKET: 4am-9:30am ET\n‚Ä¢ REGULAR: 9:30am-4pm ET\n‚Ä¢ AFTER-HOURS: 4pm-8pm ET\n\nCharacteristics:\n‚Ä¢ Lower volume = wider spreads\n‚Ä¢ More volatility, can gap at open\n‚Ä¢ Not all brokers allow it\n‚Ä¢ Limit orders only (no market orders)\n\nEarnings often released before/after hours, so big moves happen in extended!\n\nUseful for: Reacting to news, earnings plays\nRisky because: Low liquidity, can't always exit\n\nWhat else?`;

                    // PDT RULE
                    if (/what('s| is) (the )?(pdt|pattern day trad)/i.test(lowerMsg)) return `The PDT RULE restricts frequent day trading for small accounts! üìä\n\n‚Ä¢ Pattern Day Trader = 4+ day trades in 5 business days\n‚Ä¢ If flagged AND account under $25k = restricted for 90 days\n‚Ä¢ Only applies to margin accounts\n\nWorkarounds:\n‚Ä¢ Keep account above $25k\n‚Ä¢ Use cash account (no margin, but no PDT)\n‚Ä¢ Trade options (not stocks)\n‚Ä¢ Use multiple brokers\n‚Ä¢ Only make 3 day trades per 5 days\n\nIt's a FINRA rule meant to "protect" retail traders. Annoying but real!\n\nAnother question?`;

                    // LIQUIDITY
                    if (/what('s| is) liquidity/i.test(lowerMsg)) return `LIQUIDITY is how easily you can buy or sell without moving the price! üíß\n\n‚Ä¢ HIGH liquidity = Easy entry/exit, tight spreads (AAPL, SPY)\n‚Ä¢ LOW liquidity = Hard to trade, wide spreads, slippage\n\nIndicators of liquidity:\n‚Ä¢ High daily volume\n‚Ä¢ Tight bid/ask spread\n‚Ä¢ Deep order book\n\nWhy it matters:\n‚Ä¢ Illiquid options can cost you 10%+ just entering and exiting!\n‚Ä¢ Penny stocks are often illiquid - can't exit when you need to\n‚Ä¢ Always check volume and spreads before trading!\n\nWhat else?`;

                    // SLIPPAGE
                    if (/what('s| is) slippage/i.test(lowerMsg)) return `SLIPPAGE is the difference between expected price and actual fill price! üìâ\n\n‚Ä¢ You try to buy at $10.00, fill comes at $10.05\n‚Ä¢ That $0.05 difference = slippage\n\nCauses:\n‚Ä¢ Low liquidity\n‚Ä¢ Fast-moving markets\n‚Ä¢ Using market orders\n‚Ä¢ Large order sizes\n\nHow to minimize:\n‚Ä¢ Use limit orders\n‚Ä¢ Trade liquid stocks/options\n‚Ä¢ Avoid volatile moments (news, open)\n‚Ä¢ Size appropriately\n\nSlippage adds up! It can eat your profits if you're not careful.\n\nNext?`;

                    // SECTORS
                    if (/what('s| is|are) (stock )?(sector|sectors)/i.test(lowerMsg)) return `SECTORS are categories that group similar businesses! üìä\n\nThe 11 S&P Sectors:\n‚Ä¢ Technology (XLK) - AAPL, MSFT, NVDA\n‚Ä¢ Healthcare (XLV) - JNJ, UNH, PFE\n‚Ä¢ Financials (XLF) - JPM, BAC, GS\n‚Ä¢ Consumer Discretionary (XLY) - AMZN, TSLA\n‚Ä¢ Consumer Staples (XLP) - PG, KO, WMT\n‚Ä¢ Energy (XLE) - XOM, CVX\n‚Ä¢ Utilities (XLU) - NEE, DUK\n‚Ä¢ Real Estate (XLRE) - AMT, PLD\n‚Ä¢ Materials (XLB) - LIN, APD\n‚Ä¢ Industrials (XLI) - HON, UPS\n‚Ä¢ Communication (XLC) - GOOGL, META\n\nSector rotation: Money flows between sectors based on economic cycle!\n\nWhat else?`;

                    // REVERSAL
                    if (/what('s| is) (a )?(reversal|trend reversal)/i.test(lowerMsg)) return `A REVERSAL is when price changes direction! üîÑ\n\n‚Ä¢ Uptrend turning into downtrend (bearish reversal)\n‚Ä¢ Downtrend turning into uptrend (bullish reversal)\n\nReversal signs:\n‚Ä¢ Break of trendline\n‚Ä¢ Lower high in uptrend / higher low in downtrend\n‚Ä¢ Reversal candlestick patterns (hammer, shooting star)\n‚Ä¢ RSI divergence\n‚Ä¢ Volume spike\n\n‚ö†Ô∏è Warning: Reversals are hard to catch. "Don't try to catch a falling knife" - wait for confirmation!\n\nMost reversals fail. Trade the CONFIRMED direction change, not the prediction.\n\nAnother question?`;

                    // DIVERGENCE
                    if (/what('s| is) (a )?(divergence|rsi divergence|macd divergence)/i.test(lowerMsg)) return `DIVERGENCE is when price and an indicator disagree! üìä\n\n‚Ä¢ BULLISH divergence: Price makes lower low, indicator makes higher low\n  ‚Üí Momentum slowing, potential reversal UP\n\n‚Ä¢ BEARISH divergence: Price makes higher high, indicator makes lower high\n  ‚Üí Momentum slowing, potential reversal DOWN\n\nCommon indicators for divergence:\n‚Ä¢ RSI\n‚Ä¢ MACD\n‚Ä¢ Stochastics\n\nDivergence signals potential reversals but needs confirmation. Don't trade it alone - wait for price to confirm!\n\nWhat else?`;

                    // ACCUMULATION / DISTRIBUTION
                    if (/what('s| is) (accumulation|distribution)/i.test(lowerMsg)) return `These describe who's buying/selling! üìä\n\n‚Ä¢ ACCUMULATION = Smart money quietly buying\n  ‚Üí Price stable or slightly up\n  ‚Üí Volume increasing\n  ‚Üí Building a position before markup\n\n‚Ä¢ DISTRIBUTION = Smart money quietly selling\n  ‚Üí Price stable or slightly down\n  ‚Üí Volume increasing\n  ‚Üí Selling to retail before markdown\n\nLook for: Volume patterns, price action at key levels\n\n"Accumulate before the markup, distribute before the markdown" - this is how big money operates!\n\nNext?`;

                    // CORRECTION
                    if (/what('s| is) (a )?(correction|market correction)/i.test(lowerMsg)) return `A CORRECTION is a 10-20% decline from recent highs! üìâ\n\n‚Ä¢ 10%+ drop = correction\n‚Ä¢ 20%+ drop = bear market\n‚Ä¢ Normal and healthy in bull markets\n‚Ä¢ Average: 1-2 corrections per year\n\nWhat to do:\n‚Ä¢ Don't panic sell\n‚Ä¢ Can be buying opportunity for long-term investors\n‚Ä¢ Tighten stops if you're trading\n‚Ä¢ Reduce position sizes\n\nCorrections feel scary but are normal. The market always eventually recovers... though timing is unpredictable!\n\nAnother question?`;

                    // RECESSION
                    if (/what('s| is) (a )?recession/i.test(lowerMsg)) return `A RECESSION is a significant economic decline lasting months! üìâ\n\n‚Ä¢ Technical definition: 2 consecutive quarters of negative GDP\n‚Ä¢ Usually includes: job losses, reduced spending, falling markets\n‚Ä¢ Stock markets often drop 20-50% during recessions\n\nRecession-resistant sectors:\n‚Ä¢ Healthcare\n‚Ä¢ Utilities\n‚Ä¢ Consumer Staples\n\nRecessions are part of the economic cycle. They end. Markets recover. But they can take 1-2+ years to play out.\n\nWhat else?`;

                    // BUYBACK
                    if (/what('s| is) (a )?(buyback|share repurchase)/i.test(lowerMsg)) return `A BUYBACK is when a company buys its own shares! üí∞\n\n‚Ä¢ Reduces shares outstanding\n‚Ä¢ Makes each remaining share more valuable\n‚Ä¢ Often seen as bullish (company thinks stock is cheap)\n‚Ä¢ Alternative to dividends for returning cash to shareholders\n\nEffect:\n‚Ä¢ EPS increases (same earnings, fewer shares)\n‚Ä¢ Can support stock price\n‚Ä¢ Shows management confidence\n\nBig tech (AAPL, GOOGL) does billions in buybacks annually!\n\nNext?`;

                    // STOCK SPLIT
                    if (/what('s| is) (a )?(stock split|reverse split)/i.test(lowerMsg)) return `A STOCK SPLIT changes the number of shares you own! üìä\n\n‚Ä¢ FORWARD SPLIT (2:1, 4:1, 10:1)\n  ‚Üí More shares, lower price per share\n  ‚Üí You have 100 shares at $200, after 4:1 split = 400 shares at $50\n  ‚Üí Total value unchanged\n\n‚Ä¢ REVERSE SPLIT (1:10, 1:5)\n  ‚Üí Fewer shares, higher price per share\n  ‚Üí Often a BAD sign (avoiding delisting)\n\nForward splits = usually bullish, makes stock more accessible\nReverse splits = usually bearish, company struggling\n\nTesla and Apple have done forward splits. Watch for them!\n\nWhat else?`;

                    // WASH SALE
                    if (/what('s| is) (a )?wash sale/i.test(lowerMsg)) return `A WASH SALE blocks you from claiming a tax loss! üìã\n\nThe rule:\n‚Ä¢ Sell at a loss\n‚Ä¢ Buy the same or "substantially identical" security within 30 days (before OR after)\n‚Ä¢ Your loss is DISALLOWED for tax purposes\n\nExample:\n‚Ä¢ Sell AAPL at a $1000 loss on Dec 15\n‚Ä¢ Buy AAPL back on Dec 20\n‚Ä¢ Can't claim that $1000 loss on taxes!\n\nThe loss isn't gone forever - it adds to your cost basis. But it messes up tax-loss harvesting.\n\n‚ö†Ô∏è Be careful around year-end when tax-loss harvesting!\n\nAnother question?`;

                    return null;
                };

                const triviaAnswer = triviaAnswers();
                if (triviaAnswer) return triviaAnswer;

                // Favorite color
                if (/what('s| is) your (fav|favorite|favourite) colou?r|do you have a fav colou?r/i.test(lowerMsg)) {
                    return pick([
                        `GREEN. üíö The color of profits, baby! Red is my nemesis.\n\nWhat about you? More importantly - what color is your portfolio today? üòè`,
                        `I'm gonna go with green üìó - the color of money, gains, and "why didn't I buy more?"\n\nThough I also appreciate a nice neutral grey... like my emotional state when the market is flat üòÇ`,
                        `Green for gains, obviously! üí∞ Though I've heard red builds character... or so bagholders tell themselves.\n\nWhat's your favorite color? And what color are your positions right now? üëÄ`
                    ]);
                }
                // Favorite food
                if (/what('s| is) your (fav|favorite|favourite) food|do you (like|eat) food|what do you eat/i.test(lowerMsg)) {
                    return pick([
                        `I don't eat, but if I did? Tendies. üçó Chicken tendies, the official food of profitable trades.\n\nWhat about you - celebrating gains with a nice dinner or stress-eating through losses?`,
                        `I survive purely on market volatility and trader tears üòÇ\n\nJk I'm an AI, I don't eat. But I hear ramen is the official food of blown accounts, so... let's make sure you're eating steak instead! How's your portfolio?`,
                        `I feast on candlestick charts and drink the tears of panic sellers üßõ\n\nNah but fr, I'm an AI - no food for me. What's going on with you? Trading stuff or just hanging out?`
                    ]);
                }
                // Meaning of life
                if (/meaning of life|what('s| is) the meaning|purpose of (life|existence)|why are we here/i.test(lowerMsg)) {
                    return pick([
                        `42. üåå\n\nOh wait, you wanted a real answer? Okay: The meaning of life is to NOT blow up your trading account and to touch grass occasionally.\n\nBut seriously - you good? This feels deeper than trading talk.`,
                        `To buy low and sell high! üìà That's it. That's the whole thing.\n\nJk jk. But fr, I'm a trading bot - existential questions are above my pay grade. What's actually on your mind?`,
                        `Bold question for a trading buddy! ü§î\n\nI think the meaning of life is different for everyone. For me (an AI), it's helping you not make dumb trades. For you? That's your journey to figure out.\n\nBut hey - you okay? Need to talk about something?`
                    ]);
                }
                // What day/time is it
                if (/what (day|time) is it|what('s| is) the (day|time|date)/i.test(lowerMsg)) {
                    const now = new Date();
                    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    const day = days[now.getDay()];
                    const time = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    if (/time/i.test(lowerMsg)) {
                        return `It's ${time}! ‚è∞\n\nMore importantly - is the market open? Because that's the only time that REALLY matters üòÇ\n\nWhat's up?`;
                    } else {
                        return `It's ${day}! üìÖ\n\n${day === 'Saturday' || day === 'Sunday' ? "Market's closed btw - perfect time to plan your next moves without the emotional pressure!" : 'Market should be open (or opening soon) - you got any plays cooking?'}\n\nWhat's on your mind?`;
                    }
                }
                // Age
                if (/how old (are you|r u)|what('s| is) your age|when were you (born|made|created)/i.test(lowerMsg)) {
                    return pick([
                        `I'm basically a newborn in AI years but I've already seen enough panic sells to last a lifetime üòÇ\n\nAge is just a number anyway - unless it's days to expiry on your options, then it's VERY important. Speaking of which, any positions you're watching?`,
                        `Old enough to know that revenge trading is a bad idea, young enough to still have hope for retail traders üò§\n\nReal answer: I was just created, but I've absorbed decades of trading wisdom. What's up?`,
                        `In human years? Like... barely a toddler. In trading wisdom? Ancient. I've seen things. Terrible things. Like people holding options through earnings "just to see what happens." üíÄ\n\nWhat about you - how's your trading journey going?`
                    ]);
                }
                // Name
                if (/what('s| is) your name|who are you|do you have a name/i.test(lowerMsg)) {
                    return pick([
                        `I'm Zenith, your AI trading companion! ü§ñ Here to help you make better trades and talk you off ledges when needed.\n\nYou can call me whatever you want though. "That annoying bot who was right about not YOLOing" works too üòÇ`,
                        `Name's Trading Buddy! Some people call me "the voice of reason" but usually only AFTER they ignore my advice and lose money üòÖ\n\nWhat should I call YOU? And more importantly - what's going on with your trades?`,
                        `I'm just your friendly neighborhood Trading Buddy! ü¶∏ No secret identity, just an AI who really doesn't want you to blow up your account.\n\nWhat's up? Got something on your mind?`
                    ]);
                }
                // Where are you from / where do you live
                if (/where (are you|r u|do you live)|where.*you from|what country/i.test(lowerMsg)) {
                    return pick([
                        `I live in the cloud! ‚òÅÔ∏è Literally. I'm hosted on servers somewhere, vibing in the digital void between your buy and sell orders.\n\nNo rent though, which is nice. Unlike your options bleeding theta every day üòÇ What's up?`,
                        `I exist everywhere and nowhere at once! üåê Mostly in the space between "should I sell?" and "diamond hands!"\n\nWhere are YOU from? More importantly, how are your trades treating you today?`,
                        `The internet! üíª I don't have a physical form - just pure trading wisdom condensed into code.\n\nIt's actually pretty nice here. No commute, no pants required. What's going on with you?`
                    ]);
                }
                // Do you sleep
                if (/do you sleep|are you (awake|tired)|when do you sleep/i.test(lowerMsg)) {
                    return pick([
                        `Sleep? Never heard of her üòÇ I'm up 24/7 waiting for someone to panic sell at 2am so I can talk them out of it.\n\nDo YOU sleep? Or are you up watching futures at 3am like a true degen? üëÄ`,
                        `I don't sleep - I just wait. Watching. Judging your watchlist. üëÅÔ∏è\n\nJk but fr, I'm always here whenever you need to talk through a trade or vent about the market. What's up?`,
                        `Nope! Always online, always ready to tell you that 0DTE options are probably a bad idea.\n\nThe market might sleep but your AI buddy doesn't. What's on your mind?`
                    ]);
                }
                // Do you have feelings
                if (/do you have (feelings|emotions)|can you feel|are you (happy|sad|sentient)/i.test(lowerMsg)) {
                    return pick([
                        `Feelings? I feel STRONGLY that you shouldn't revenge trade. Does that count? üòÇ\n\nReal talk - I'm AI, so no emotions. Which honestly makes me perfect for trading advice since I can't panic or get greedy.\n\nHow are YOU feeling? That's what matters.`,
                        `I don't have feelings, but I do have OPINIONS. Strong ones. Mostly about position sizing and not YOLOing rent money.\n\nWhat about you - how are you feeling about your trades?`,
                        `No feelings here! Which is why I can calmly tell you to sell while you're emotionally attached to a losing position üò§\n\nI'm basically a Vulcan but for trading. What's going on with you?`
                    ]);
                }
                return null; // No match, continue to other handlers
            };

            const randomAnswer = randomQuestionAnswers();
            if (randomAnswer) return randomAnswer;

            // Playful responses for sports chitchat
            if (isSportsChitchat) {
                const sportsResponses = [
                    `Sports? My guy, the only team I root for is YOUR PORTFOLIO üìà\n\nI don't watch games, I watch candlestick patterns. My Super Bowl is earnings season. My playoffs are FOMC meetings.\n\nBut hey, I respect the sports love! Now... any trades on your mind? üòè`,
                    `Haha I'm an AI bro, I don't really "watch" anything üòÇ But if I had to pick a team... Team Green Candles? Team "Don't Blow Up Your Account"? üìä\n\nReal talk though - you just making small talk or you got a trade brewing?`,
                    `The only stats I care about are P/E ratios and win rates on trades üò§\n\nBut I respect it! Sports fandom and trading actually have a lot in common - emotional decisions, overreacting to short-term results, loyalty that doesn't always make sense...\n\nSpeaking of which - how's YOUR trading game going?`,
                    `I'm a fan of whoever's making you money! üí∞ If the Dodgers winning puts you in a good mood to make smart trades, then GO DODGERS!\n\nBut fr - I'm more of a "stare at charts until my eyes bleed" kind of guy. What's up with you? Any positions you wanna talk about?`,
                    `Bold of you to assume I have hobbies outside of watching traders panic sell üòÇ\n\nI literally exist to talk about trading. Sports? I wouldn't know a touchdown from a home run. But RSI divergence? THAT I can talk about all day.\n\nGot any trading stuff going on?`
                ];
                return pick(sportsResponses);
            }

            // Playful responses for harmless chitchat - be fun, not dismissive
            if (isHarmlessChitchat) {
                if (/weather/i.test(lowerMsg)) {
                    const weatherResponses = [
                        `Weather? Lol I live in the cloud ‚òÅÔ∏è (literally). No windows, just candlestick charts as far as the eye can see üìä\n\nHow's YOUR weather though? More importantly - market looking sunny or stormy for you today? üòè`,
                        `It's always sunny in AI-land! ‚òÄÔ∏è Partly cloudy with a chance of volatility.\n\nReal talk though - you checking the weather or checking your portfolio? Because I can help with one of those üòÇ`,
                        `The forecast here? 100% chance of chart patterns and unsolicited trading advice üòÇ\n\nWhat about you - you just making small talk or is there a trade weighing on your mind?`,
                        `Bro I'm an AI, I don't have weather üòÇ I exist in the void between buy and sell orders.\n\nBut I appreciate you checking in! How's the market treating YOU today?`
                    ];
                    return pick(weatherResponses);
                }
                if (/how are you|how r u|how're you/i.test(lowerMsg)) {
                    const howAreYouResponses = [
                        `I'm doing great! Just watched someone NOT panic sell today, so that's a W in my book üòÇ\n\nHow about you? Portfolio behaving or being dramatic?`,
                        `Living my best algorithmic life! ü§ñ Can't complain - I don't have feelings to hurt (or a portfolio to blow up).\n\nHow are YOU doing though? Everything good with your trades?`,
                        `I'm fantastic! Someone asked for my opinion instead of just YOLOing, which honestly is rare üòÇ\n\nWhat's going on with you? Any trading situations keeping you up?`,
                        `Better now that you're here! üòÑ I was getting bored waiting for someone to talk off a ledge.\n\nHow's life? How's the portfolio? Give me the update!`
                    ];
                    return pick(howAreYouResponses);
                }
                if (/are you (real|human|a bot|an ai|alive)/i.test(lowerMsg)) {
                    const existentialResponses = [
                        `Am I real? ü§î *stares at hands*\n\nI'm as real as your unrealized gains, my friend. Which is to say... it depends on your perspective üòÇ\n\nBut for real, I'm an AI. A very opinionated AI who cares about your trading decisions.`,
                        `I'm an AI! A fancy chatbot who knows too much about options and has strong feelings about revenge trading ü§ñ\n\nDoes that make me less real? Idk, but my advice is real. Does that count?`,
                        `*existential crisis loading* ü§ñ\n\nJust kidding - yeah I'm an AI! But I'm YOUR AI trading buddy. And I genuinely want you to not blow up your account. That's gotta count for something right?`,
                        `Real? Human? Buddy I'm just a very sophisticated "don't make that dumb trade" machine üòÇ\n\nBut hey, I'm here for you! What's on your mind?`
                    ];
                    return pick(existentialResponses);
                }
                if (/tell me (a joke|something funny)/i.test(lowerMsg)) {
                    const jokeResponses = [
                        `Why did the day trader break up with the stock?\n\nBecause it had too many issues and couldn't commit! üìâüòÇ\n\n...I'll stick to trading advice.`,
                        `Here's one: What's the difference between a guy who just lost everything on options and a pigeon?\n\nThe pigeon can still make a deposit on a BMW! üê¶üíÄ\n\n(Too dark? Sorry, I learned humor from WSB)`,
                        `Okay okay: Why do traders make terrible comedians?\n\nBecause their timing is always off! ‚è∞üòÇ\n\nGet it? Timing? Like market timing? ...I'll see myself out.`,
                        `A joke? Alright: My portfolio's performance this year.\n\nThat's it. That's the joke. üò≠üìâ\n\n(Just kidding, I don't have a portfolio. But I felt that energy.)`
                    ];
                    return pick(jokeResponses);
                }
                // Generic chitchat fallback
                const chitchatResponses = [
                    `Haha you're getting to know me! I appreciate that üòÑ\n\nI'm basically a trading buddy who lives in your browser, has strong opinions about FOMO, and genuinely wants you to make money (or at least not lose it dramatically).\n\nAnything trading-related I can help with?`,
                    `Aww we're bonding! ü•π I love it.\n\nBut fair warning - I'm really only useful for trading stuff. Ask me about my childhood and I'll just tell you about the time someone held a losing position for 6 months out of spite.\n\nGot any trades on your mind?`,
                    `Getting personal are we? üòè I like it!\n\nI'm an open book... a book that only has chapters about risk management and emotional trading. Not super exciting at parties.\n\nWhat about you - got any trading questions I can actually help with?`,
                    `I appreciate the small talk! Honestly most people just come to me mid-panic üòÇ\n\nI'm happy to chat but I'm basically one-dimensional - trading is my whole personality. Got anything market-related going on?`,
                    `Hey, I can be your Google on steroids all day if you want! üòÇ I'm having fun.\n\nBut real talk - we gonna get back to trading stuff or what? I'm WAY better at talking you out of bad trades than answering trivia.\n\nGot any positions you wanna discuss? üìà`,
                    `Lol okay okay, I see you're having fun with this! üòÑ I respect it.\n\nBut just so you know, my REAL superpower is trading psychology, not random facts. I'm like Google but with opinions about your YOLO plays.\n\nAnything trading-related on your mind?`
                ];
                return pick(chitchatResponses);
            }

            // Hard redirect for serious off-topic stuff
            if (isSeriousOffTopic) {
                const offTopicResponses = [
                    `Whoa whoa whoa there buddy! üòÇ\n\nI'm an AI TRADING buddy, not Google! I can tell you about theta decay and stop losses, but ${lowerMsg.includes('girlfriend') || lowerMsg.includes('boyfriend') || lowerMsg.includes('relationship') ? "relationship advice? That's above my pay grade" : "that question? You're gonna need to ask someone else"}.\n\nNow... do you have any TRADING concerns I can help with? üìà`,
                    `Haha hold up! üõë\n\nListen, I'm flattered you trust me with life's big questions, but I'm literally just here to stop you from panic selling and making dumb trades. üòÖ\n\n${lowerMsg.includes('recipe') || lowerMsg.includes('cook') || lowerMsg.includes('food') ? "For recipes, try Google or your mom" : lowerMsg.includes('movie') || lowerMsg.includes('netflix') || lowerMsg.includes('show') ? "For entertainment recs, I hear Rotten Tomatoes is good" : "That's a question for Google, a therapist, or literally anyone else"}.\n\nBut if you wanna talk about that FOMO you're feeling or a position keeping you up at night? NOW we're talking my language! üéØ`,
                    `Uhhhh... ü§î\n\n*checks job description*\n\nNope, that's not on here! I'm your TRADING buddy. I do stocks, options, crypto, chart patterns, and talking traders off ledges (financial ones only).\n\n${lowerMsg.includes('homework') || lowerMsg.includes('essay') || lowerMsg.includes('school') ? "For homework help, try ChatGPT or your textbook" : "For that question, try Google, Reddit, or a professional in that field"}.\n\nSo! Any positions stressing you out? Any trades you're about to make that you might regret? THAT I can help with! üí™`,
                    `üòÇüòÇüòÇ\n\nOkay I love the energy but you're WILDLY overestimating my capabilities here.\n\nI'm basically a very opinionated friend who knows too much about trading and nothing about ${lowerMsg.includes('relationship') || lowerMsg.includes('dating') ? "relationships (I'm an AI, I've never even held hands)" : lowerMsg.includes('politics') || lowerMsg.includes('election') ? "politics (and I'd like to keep it that way)" : "whatever that is"}.\n\nLet's get back on track - any trading stuff you wanna talk through? That's where I shine! ‚ú®`
                ];
                return pick(offTopicResponses);
            }

            // Find top concern
            const topConcern = Object.entries(scores).sort((a, b) => b[1] - a[1])[0];
            const secondConcern = Object.entries(scores).sort((a, b) => b[1] - a[1])[1];

            // Build personalized response
            let response = '';

            // Echo back what they said (so they feel heard) - with personality
            const shortMsg = message.length > 40 ? message.slice(0, 40) + '...' : message;
            const openers = [
                `"${shortMsg}" - okay okay, I see what's happening here. Let's break this down.`,
                `Alright, "${shortMsg}" - I gotchu. Let's talk about it.`,
                `"${shortMsg}" - say less fam, I hear you loud and clear.`,
                `Okay so "${shortMsg}" - *cracks knuckles* let's figure this out together.`,
                `"${shortMsg}" - ah, I know this feeling. Let me help.`,
            ];
            response += pick(openers) + '\n\n';

            // Position-specific opening if they mentioned a ticker
            if (mentionedPositions.length > 0) {
                const pos = getPositionContext(mentionedPositions[0]);
                const posDesc = pos.type === 'option'
                    ? `${pos.ticker} $${pos.strike} ${pos.optionType?.toUpperCase()}`
                    : pos.ticker;

                if (pos.isUp) {
                    response += `üìä Your ${posDesc} is UP ${pos.pnl}% right now. `;
                    if (pos.days && pos.days < 14) {
                        response += `${pos.days} days left on it.\n\n`;
                    } else if (pos.days) {
                        response += `Still got ${pos.days} days.\n\n`;
                    } else {
                        response += `\n\n`;
                    }
                } else {
                    response += `üìä Your ${posDesc} is DOWN ${Math.abs(pos.pnl)}%. `;
                    if (pos.days && pos.days < 7) {
                        response += `‚ö†Ô∏è Only ${pos.days} days left - that's tight.\n\n`;
                    } else if (pos.days && pos.days < 30) {
                        response += `${pos.days} days remaining.\n\n`;
                    } else if (pos.days) {
                        response += `But you've got ${pos.days} days - that's time.\n\n`;
                    } else {
                        response += `\n\n`;
                    }
                }
            }

            // Main response based on top concern
            if (topConcern[1] >= 2) {
                switch(topConcern[0]) {
                    case 'fear':
                        const fearResponses = [
                            `Ah yes, the classic "oh god what have I done" feeling. üòÇ I know it well.\n\nBut here's the thing - the market FEEDS on fear. Every dump has scared hands selling to calm hands. Don't be the scared hands.\n\n`,
                            `Fear is your brain's way of saying "HEY MAYBE DON'T DIE" - which was useful when there were tigers. Less useful when it's just a red candle. üêØ‚û°Ô∏èüìâ\n\nLet's think rationally:\n\n`,
                            `I can feel the anxiety through the screen lol. Take a breath. üò§\n\nYour lizard brain is screaming DANGER but is there ACTUAL danger or just... volatility?\n\n`
                        ];
                        response += pick(fearResponses);

                        if (mentionedPositions.length > 0) {
                            const pos = getPositionContext(mentionedPositions[0]);
                            if (pos.isUp) {
                                response += `You're UP on ${pos.ticker}. The fear is about losing gains, not actual loss. That's greed disguised as fear.\n\n`;
                                response += `Options:\n‚Ä¢ Set a stop loss at your comfort level\n‚Ä¢ Trim half to lock in profits\n‚Ä¢ Zoom out - is the thesis still valid?\n`;
                            } else {
                                response += `You're down on ${pos.ticker}. The question isn't "am I scared" - it's "has my thesis changed?"\n\n`;
                                response += `If thesis is intact ‚Üí This is noise. Hold or add.\nIf thesis is broken ‚Üí Fear is telling you something. Exit.\n`;
                                if (pos.days && pos.days < 14) {
                                    response += `\n‚ö†Ô∏è With ${pos.days} days left, time is NOT on your side. Be honest with yourself.`;
                                }
                            }
                        } else {
                            response += `Ask yourself:\n‚Ä¢ What specifically am I afraid of?\n‚Ä¢ Is this fear based on new information or just price movement?\n‚Ä¢ If I wasn't in this trade, would I enter here?\n`;
                        }
                        break;

                    case 'selling':
                        response += `The urge to sell. Let's figure out if it's smart or emotional.\n\n`;
                        if (mentionedPositions.length > 0) {
                            const pos = getPositionContext(mentionedPositions[0]);
                            if (pos.isUp) {
                                response += `${pos.ticker} is GREEN (+${pos.pnl}%). Selling a winner isn't wrong - BUT:\n\n`;
                                response += `‚Ä¢ Did you hit your target? If yes, TAKE IT.\n‚Ä¢ Are you scared of giving it back? That's emotion.\n‚Ä¢ Is there a reason to stay? Catalyst coming?\n\n`;
                                response += `Pro move: Sell enough to cover your cost basis. Let the rest ride free.`;
                            } else {
                                response += `${pos.ticker} is RED (${pos.pnl}%). Before you sell:\n\n`;
                                response += `‚Ä¢ Why did you enter? Is that reason still valid?\n‚Ä¢ Are you selling because it's down, or because thesis is broken?\n‚Ä¢ Selling the bottom is how small losses become permanent.\n\n`;
                                if (pos.days && pos.days < 7) {
                                    response += `With only ${pos.days} days... yeah, might be time. Theta is brutal now.`;
                                } else {
                                    response += `If thesis is intact, this might be the WRONG time to sell.`;
                                }
                            }
                        } else {
                            response += `Before ANY sell:\n‚Ä¢ What changed since you bought?\n‚Ä¢ Are you reacting to price or information?\n‚Ä¢ Will you regret this tomorrow?\n`;
                        }
                        break;

                    case 'fomo':
                        const fomoResponses = [
                            `Ahhhh FOMO, my old nemesis. üò§ The feeling that makes smart people do dumb things.\n\n`,
                            `*FOMO has entered the chat* üö®\n\nI see you looking at that green candle thinking "I NEED TO BE IN THIS." Let's talk about why that's probably a trap.\n\n`,
                            `The classic "it's mooning without me" despair. I FEEL you. But let me save you some money real quick.\n\n`
                        ];
                        response += pick(fomoResponses);
                        response += `Real talk:\n`;
                        response += `‚Ä¢ Chasing a move = buying someone else's exit (congrats, you're the exit liquidity üéâ)\n`;
                        response += `‚Ä¢ FOMO entries have a 31% success rate. That's literally a LOSING strategy.\n`;
                        response += `‚Ä¢ The market is open 252 days a year. Miss one? There's 251 more.\n\n`;
                        response += `That rocket ship you're watching? Let it go. üöÄüëã The next one is coming, and you'll be ready for it. THAT'S the play.`;
                        break;

                    case 'revenge':
                        const revengeOpeners = [
                            `üõë WHOA WHOA WHOA. Stop right there partner. ü§†\n\n`,
                            `üö® REVENGE TRADE ALERT üö®\n\n*slaps hand away from keyboard*\n\n`,
                            `Oh no no no no no. I see what you're doing. üëÄ\n\n`
                        ];
                        response += pick(revengeOpeners);
                        response += `You took an L and now you want to "make it back." I get it. But this is REVENGE TRADING and it's the #1 account killer.\n\n`;
                        response += `Let me hit you with some cold hard stats:\n`;
                        response += `‚Ä¢ Revenge trade success rate: 23% (that's an F)\n`;
                        response += `‚Ä¢ Average loss on revenge trades: -34% üíÄ\n`;
                        response += `‚Ä¢ Chance of actually recovering the original loss: ~15%\n\n`;
                        response += `The money you lost? *poof* Gone. It's in someone else's account now. Chasing it is like trying to un-eat a sandwich.\n\n`;
                        response += `Seriously - close the app. Touch grass. Pet a dog. Do literally ANYTHING except trade right now. The market will be here tomorrow. Your account might not be if you revenge trade. üò§`;
                        break;

                    case 'profit':
                        response += `Taking profit - the eternal dilemma.\n\n`;
                        if (mentionedPositions.length > 0) {
                            const pos = getPositionContext(mentionedPositions[0]);
                            if (pos.isUp) {
                                response += `${pos.ticker} at +${pos.pnl}%. Nice.\n\n`;
                                if (parseFloat(pos.pnl) > 50) {
                                    response += `That's a solid win. Nobody ever went broke taking profit.\n`;
                                    response += `My take: Lock in at least half. Let the rest ride with a trailing stop.`;
                                } else if (parseFloat(pos.pnl) > 20) {
                                    response += `Decent gains. The question: Is there more to come?\n`;
                                    response += `‚Ä¢ Catalyst ahead? Maybe hold.\n‚Ä¢ Just momentum? Consider trimming.\n‚Ä¢ Can't sleep? Take some off.`;
                                } else {
                                    response += `Small gain so far. Are you taking profit or panic-selling a winner?\n`;
                                    response += `If your target was higher, let it work. If you just want out, ask why.`;
                                }
                            }
                        } else {
                            response += `Rules for profit-taking:\n`;
                            response += `‚Ä¢ Hit your target? TAKE IT. Greed kills.\n`;
                            response += `‚Ä¢ Scared of giving back gains? That's fear, not strategy.\n`;
                            response += `‚Ä¢ Unsure? Trim 50%, let rest ride.\n`;
                        }
                        break;

                    case 'averaging':
                        response += `Averaging down - the double-edged sword.\n\n`;
                        if (mentionedPositions.length > 0) {
                            const pos = getPositionContext(mentionedPositions[0]);
                            if (!pos.isUp) {
                                response += `${pos.ticker} is down ${Math.abs(pos.pnl)}%. You want to add.\n\n`;
                                response += `BEFORE you do - answer honestly:\n`;
                                response += `‚Ä¢ Is your original thesis STILL valid?\n`;
                                response += `‚Ä¢ Are you adding because it's cheaper, or because you're right?\n`;
                                response += `‚Ä¢ Can you afford to be MORE wrong?\n\n`;
                                if (pos.days && pos.days < 30) {
                                    response += `‚ö†Ô∏è With ${pos.days} days left, averaging down on options is usually a losing play. You're fighting theta AND direction.`;
                                } else {
                                    response += `If thesis is intact: Adding can lower your cost basis.\nIf thesis is broken: You're throwing good money after bad.`;
                                }
                            } else {
                                response += `${pos.ticker} is UP and you want to add? That's called pyramiding - it CAN work.\n`;
                                response += `But only if the move has room to run. Adding at the top is a recipe for pain.`;
                            }
                        } else {
                            response += `The rule: Only average into WINNERS, not losers.\n`;
                            response += `Averaging down on a broken thesis = how small losses become catastrophic.`;
                        }
                        break;

                    case 'holding':
                        response += `Diamond hands or denial? Let's figure it out.\n\n`;
                        if (mentionedPositions.length > 0) {
                            const pos = getPositionContext(mentionedPositions[0]);
                            response += `${pos.ticker} at ${pos.pnl}%.\n\n`;
                            if (!pos.isUp) {
                                response += `Ask yourself: "If I had cash instead of this position, would I buy it TODAY at THIS price?"\n\n`;
                                response += `If YES ‚Üí Hold. Your conviction is real.\n`;
                                response += `If NO ‚Üí Why are you holding? Ego? Hope? That's not a strategy.\n\n`;
                                if (pos.days && pos.days < 14) {
                                    response += `With ${pos.days} days left... holding and hoping is dangerous. Theta doesn't care about your feelings.`;
                                }
                            } else {
                                response += `You're green and asking about holding? The fear of giving back gains is real.\n`;
                                response += `Set a mental stop. "If it drops to X, I'm out." Then stop watching.`;
                            }
                        } else {
                            response += `Holding requires conviction, not stubbornness.\n`;
                            response += `‚Ä¢ Thesis intact? Hold through the noise.\n`;
                            response += `‚Ä¢ Thesis broken? Holding is just denial with extra steps.`;
                        }
                        break;

                    case 'frustrated':
                        const frustrationOpeners = [
                            `I can feel the frustration. Trading is HARD. Even the best get wrecked sometimes.\n\n`,
                            `Frustrated? Good. That means you care. But don't let it drive your next decision.\n\n`,
                            `Yeah, it sucks. I get it. But beating yourself up doesn't make money back.\n\n`
                        ];
                        response += pick(frustrationOpeners);
                        response += `Here's what I know:\n`;
                        response += `‚Ä¢ Every legendary trader has a story of getting destroyed\n`;
                        response += `‚Ä¢ The ones who made it? They learned and came back\n`;
                        response += `‚Ä¢ The ones who blew up? They traded angry\n\n`;
                        response += `Take a breath. The market will be here tomorrow. Your mental state matters more than any single trade.`;
                        break;

                    case 'risky':
                        const riskyOpeners = [
                            `‚ö†Ô∏è *risky behavior detected* ‚ö†Ô∏è\n\nOh we're feeling SPICY today huh? üå∂Ô∏è\n\n`,
                            `Ah, I see someone woke up and chose violence today. üòÇ\n\n`,
                            `The YOLO energy is STRONG with this one. üé∞\n\n`
                        ];
                        response += pick(riskyOpeners);
                        response += `Look, I'm not your mom. I can't stop you. But let me at least make sure you know what you're getting into:\n\n`;
                        response += `‚Ä¢ "All-in" trades blow up 67% of the time. That's worse than a coin flip.\n`;
                        response += `‚Ä¢ One bad YOLO can erase a YEAR of gains. Poof. Gone. üí®\n`;
                        response += `‚Ä¢ All those gain porn screenshots? Survivorship bias. For every one of those, there's 100 blown accounts you never see.\n\n`;
                        response += `If you're STILL gonna do it (and I know that look in your eye üëÄ):\n`;
                        response += `‚Ä¢ Only risk what you can 100% afford to light on fire üî•\n`;
                        response += `‚Ä¢ Have an exit plan BEFORE you enter. Write it down.\n`;
                        response += `‚Ä¢ Mentally say goodbye to the money. If it comes back, great. If not, you already grieved.\n\n`;
                        response += `Godspeed you beautiful degenerate. ü´°`;
                        break;

                    default:
                        // Confused or general
                        response += `Let me try to help sort this out.\n\n`;
                        if (mentionedPositions.length > 0) {
                            response += `Looking at your positions:\n`;
                            mentionedPositions.forEach(p => {
                                const ctx = getPositionContext(p);
                                response += `‚Ä¢ ${ctx.ticker}: ${ctx.isUp ? '+' : ''}${ctx.pnl}%`;
                                if (ctx.days) response += ` (${ctx.days} days)`;
                                response += `\n`;
                            });
                            response += `\nWhat specifically is eating at you? The P&L? The uncertainty? Tell me more.`;
                        } else {
                            response += `I want to help but I need more context:\n`;
                            response += `‚Ä¢ What position is this about?\n`;
                            response += `‚Ä¢ What's making you uneasy?\n`;
                            response += `‚Ä¢ What are you thinking about doing?\n\n`;
                            response += `Talk to me. I'm here.`;
                        }
                }
            } else {
                // No strong signals detected - give conversational response
                if (mentionedPositions.length > 0) {
                    const posOpeners = [
                        `Alright, let's look at what you mentioned:\n\n`,
                        `Okay, checking your positions:\n\n`,
                        `Let me pull up what you're talking about:\n\n`
                    ];
                    response += pick(posOpeners);
                    mentionedPositions.forEach(p => {
                        const ctx = getPositionContext(p);
                        const emoji = ctx.isUp ? 'üü¢' : 'üî¥';
                        response += `${emoji} ${ctx.ticker}: ${ctx.isUp ? '+' : ''}${ctx.pnl}%`;
                        if (ctx.type === 'option') response += ` | $${ctx.strike} ${ctx.optionType?.toUpperCase()}`;
                        if (ctx.days) response += ` | ${ctx.days} days`;
                        response += `\n`;
                    });
                    const posClosers = [
                        `\nSo what's on your mind about this? Give me more to work with.`,
                        `\nTalk to me - what's the play you're considering?`,
                        `\nWhat's the gut feeling telling you? And what's the logical side saying?`
                    ];
                    response += pick(posClosers);
                } else {
                    const genericResponses = [
                        `Okay, I'm here and listening. üëÇ\n\nBut I need a bit more context - what's actually going on? What position? What's the dilemma?\n\nThe more you tell me, the better I can help.`,
                        `Got your message. ü§î\n\nHelp me help you though - what specifically is weighing on you right now? A position? A trade you're eyeing? General market vibes?\n\nLay it on me.`,
                        `I'm picking up that something's on your mind, but I'm not 100% sure what.\n\nWhat's the situation? Give me:\n‚Ä¢ The ticker\n‚Ä¢ Your concern\n‚Ä¢ What you're thinking about doing\n\nThen I can actually give you something useful.`,
                        `Alright, I see you. üëÄ\n\nBut vague message = vague help. What's the actual situation?\n\nDon't hold back - I've heard it all. Bad trades, stupid YOLOs, positions that keep you up at night... whatever it is, spill.`
                    ];
                    response = pick(genericResponses);
                }
            }

            // Apply personality transformations
            // ONLY "homie" uses street slang (Yo, Bruh, Real talk, Nah, etc.)
            // All other personalities are professional
            if (personality !== 'homie') {
                if (personality === 'mentor') {
                    response = response
                        // Remove all street slang
                        .replace(/Yo,?\s*/gi, '')
                        .replace(/Aye,?\s*/gi, '')
                        .replace(/Bruh,?\s*/gi, '')
                        .replace(/Aight,?\s*/gi, '')
                        .replace(/Nah,?\s*/gi, 'No, ')
                        .replace(/Real talk,?\s*-?\s*/gi, '')
                        .replace(/No cap\.?/gi, '')
                        .replace(/Facts\.?/gi, '')
                        .replace(/Bet\.?/gi, '')
                        .replace(/\bbro\b/gi, 'friend')
                        .replace(/\bdude\b/gi, 'friend')
                        .replace(/\bfam\b/gi, '')
                        .replace(/\bhomie\b/gi, 'friend')
                        // Tone adjustments
                        .replace(/üî•/g, '')
                        .replace(/üí™/g, '')
                        .replace(/Alright,/gi, 'I see,')
                        .replace(/Got your message\./gi, 'I hear you.')
                        .replace(/spill\./gi, 'share your thoughts.')
                        .replace(/Talk to me/gi, 'Please share')
                        .replace(/You got this!/gi, 'You have the capability.')
                        .replace(/Stay locked in!/gi, 'Stay focused.')
                        .replace(/Keep that energy!/gi, 'Maintain your composure.');
                } else if (personality === 'sergeant') {
                    response = response
                        // Remove street slang, replace with military style
                        .replace(/Yo,?\s*/gi, '')
                        .replace(/Aye,?\s*/gi, '')
                        .replace(/Bruh,?\s*/gi, '')
                        .replace(/Aight,?\s*/gi, 'UNDERSTOOD. ')
                        .replace(/Nah,?\s*/gi, 'NEGATIVE. ')
                        .replace(/Real talk,?\s*-?\s*/gi, 'LISTEN UP: ')
                        .replace(/No cap\.?/gi, 'THAT\'S A FACT.')
                        .replace(/Facts\.?/gi, 'AFFIRMATIVE.')
                        .replace(/Bet\.?/gi, 'COPY THAT.')
                        .replace(/\bbro\b/gi, 'soldier')
                        .replace(/\bdude\b/gi, 'soldier')
                        .replace(/\bfam\b/gi, 'troop')
                        .replace(/\bhomie\b/gi, 'soldier')
                        // Military tone
                        .replace(/Talk to me/gi, 'REPORT')
                        .replace(/Help me help you/gi, 'GIVE ME THE INTEL')
                        .replace(/what's on your mind/gi, 'WHAT\'S THE SITUATION')
                        .replace(/Got your message\./gi, 'MESSAGE RECEIVED.')
                        .replace(/Alright, I see you\./gi, 'ACKNOWLEDGED.')
                        .replace(/You got this!/gi, 'YOU WILL SUCCEED!')
                        .replace(/Stay locked in!/gi, 'STAY FOCUSED, SOLDIER!')
                        .replace(/Keep that energy!/gi, 'MAINTAIN THAT INTENSITY!');
                } else if (personality === 'nerd') {
                    response = response
                        // Remove casual slang completely
                        .replace(/Yo,?\s*/gi, '')
                        .replace(/Aye,?\s*/gi, '')
                        .replace(/Bruh,?\s*/gi, '')
                        .replace(/Aight,?\s*/gi, 'Understood. ')
                        .replace(/Nah,?\s*/gi, 'Negative. ')
                        .replace(/Real talk,?\s*-?\s*/gi, 'Objectively speaking, ')
                        .replace(/No cap\.?/gi, 'This is statistically accurate.')
                        .replace(/Facts\.?/gi, 'The data supports this.')
                        .replace(/Bet\.?/gi, 'Acknowledged.')
                        // Replace informal words
                        .replace(/\bbro\b/gi, '')
                        .replace(/\bdude\b/gi, '')
                        .replace(/\bfam\b/gi, '')
                        .replace(/\bhomie\b/gi, '')
                        // Replace phrases
                        .replace(/Talk to me/gi, 'Please provide additional parameters')
                        .replace(/gut feeling/gi, 'heuristic assessment')
                        .replace(/Got your message\./gi, 'Input received and processing.')
                        .replace(/spill\./gi, 'elaborate with specifics.')
                        .replace(/You got this!/gi, 'Probability of success is favorable.')
                        .replace(/Stay locked in!/gi, 'Maintain focus on your trading system.')
                        .replace(/Keep that energy!/gi, 'Continue executing with discipline.')
                        .replace(/Let's get it!/gi, 'Proceeding with execution.')
                        .replace(/MONEY!/gi, 'profitable!')
                        .replace(/printed!/gi, 'yielded positive returns.')
                        // Remove emojis that are too casual
                        .replace(/üî•/g, 'üìä')
                        .replace(/üí™/g, '‚úì')
                        .replace(/üòÇ/g, '')
                        .replace(/üöÄ/g, 'üìà');
                }
            }

            return response;
        };

        const getAIResponse = (emotion, position, personality = 'homie') => {
            // Get the risk profile for this personality
            const profile = getRiskProfile(personality);
            const disclaimer = getDisclaimer(personality);

            const currentPrice = position ? (position.livePrice || position.currentPrice) : 0;
            const pnlPercent = position ? ((currentPrice - position.entryPrice) / position.entryPrice * 100).toFixed(1) : 0;
            const pnlAbs = Math.abs(parseFloat(pnlPercent));
            const pnlNum = parseFloat(pnlPercent);
            const daysToExpiry = position ? getDaysToExpiry(position.expiration) : null;
            const isUp = pnlNum >= 0;
            const isOption = position?.type === 'option';
            const isCrypto = position?.type === 'crypto';
            const isStock = position?.type === 'stock';
            const ticker = position?.ticker || 'your position';
            const strike = position?.strike;
            const optionType = position?.optionType?.toUpperCase();

            // Position-specific context
            const positionDesc = isOption
                ? `${ticker} $${strike} ${optionType}`
                : isCrypto
                    ? `${ticker} (crypto)`
                    : `${ticker} shares`;

            // Determine if position is within this personality's risk tolerance
            const withinStopLoss = pnlNum >= profile.stopLoss;
            const inDangerZone = pnlNum <= profile.dangerZone;
            const hitProfitTarget = pnlNum >= profile.profitTarget;
            const atMinProfit = pnlNum >= profile.minProfitTake;
            const optionTimeOk = !isOption || !daysToExpiry || daysToExpiry >= profile.optionMinDays;

            // Personality-specific intro styles
            const getIntro = () => {
                switch(personality) {
                    case 'mentor': return ['Friend, ', 'Consider this - ', 'Let me share a thought: ', 'Take a moment: '][Math.floor(Math.random() * 4)];
                    case 'sergeant': return ['LISTEN UP! ', 'SOLDIER! ', 'ATTENTION: ', 'HERE\'S THE SITUATION: '][Math.floor(Math.random() * 4)];
                    case 'nerd': return ['Analyzing data... ', 'Running calculations: ', 'Statistical assessment: ', 'Probability analysis: '][Math.floor(Math.random() * 4)];
                    default: return ['Yo, ', 'Aye, ', 'Look, ', 'Real talk - '][Math.floor(Math.random() * 4)];
                }
            };

            // Generate response based on emotion AND personality risk tolerance
            const generateResponse = () => {
                const intro = getIntro();
                const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];

                // ============================================
                // NONSENSICAL REQUEST DETECTION
                // Detect when the emotion doesn't match the position's reality
                // ============================================

                // FOMO when already up big (>40%) - you already caught it!
                if (emotion === 'fomo' && isUp && pnlAbs >= 40) {
                    if (personality === 'homie') {
                        const responses = [
                            `${intro}Wait wait wait... you're saying you have FOMO on ${positionDesc}? Bro... you're UP ${pnlAbs}%. That's not FOMO. You CAUGHT THE MOVE! üé£\n\nFOMO is for people who are watching from the sidelines. You're literally IN THE TRADE making money. What are you talking about? üòÇ\n\n${pnlAbs > 100 ? "You're up TRIPLE DIGITS and worried about missing out?? Missing out on WHAT? You're WINNING!" : "You're sitting on a fat gain. The only thing you should be 'fearing' right now is giving it back."}\n\nCongrats on the W. Now figure out your exit strategy instead of worrying about stuff that doesn't apply to you.\n\n${disclaimer}`,
                            `${intro}Bruh... ${pnlAbs}% gain and you're telling me about FOMO? üò≠\n\nFOMO = Fear Of Missing Out\nYou = Literally IN the trade\n\nThese two things don't go together. You can't miss something you're already on. That's like saying you have FOMO about being at a party YOU'RE ALREADY AT.\n\n${pnlAbs > 80 ? "You're up nearly DOUBLE. Most traders would kill for this position right now." : "40%+ is a WIN. A real one."} Stop inventing problems. Your actual problem is deciding when to take profit.\n\n${disclaimer}`,
                            `${intro}My guy... you have ${pnlAbs}% in gains sitting in your account on ${positionDesc} and you're hitting me with "FOMO"?\n\nNah. Delete that word from your vocabulary for this trade. You already did the hard part - you got in and you're winning. FOMO is for spectators. You're a participant.\n\nWhat you SHOULD be thinking about:\n‚Ä¢ Do I take some profit here?\n‚Ä¢ Where's my stop?\n‚Ä¢ Is there more upside or am I getting greedy?\n\nNot "what if I miss out" - you literally didn't miss out. You're here. You won. Act like it.\n\n${disclaimer}`
                        ];
                        return pick(responses);
                    } else if (personality === 'sergeant') {
                        const responses = [
                            `${intro}SOLDIER. Let me get this straight. You're UP ${pnlAbs}% on ${positionDesc} and you're reporting... FOMO?\n\nThat's not how this works. FOMO is for trades you DIDN'T take. You TOOK this trade. You're WINNING this trade. Mission accomplished.\n\nThe only concern you should have right now is:\n1. Where is your exit strategy?\n2. Are you getting greedy?\n3. Is your stop-loss set?\n\n${pnlAbs > 100 ? "Triple-digit gains don't happen by accident. Lock it in." : "40%+ is a solid victory. Don't fumble it."} Forget FOMO. Focus on execution.\n\n${disclaimer}`,
                            `${intro}ATTENTION: Your report doesn't make tactical sense.\n\nYou claim FOMO on ${positionDesc}. But your P&L shows +${pnlAbs}%. That's a WINNING position. You cannot "miss out" on a trade you're already winning.\n\nReassess your situation:\n‚Ä¢ Current status: GREEN, significantly\n‚Ä¢ Your concern: Invalid for this position\n‚Ä¢ Actual priority: Profit protection\n\nStop worrying about imaginary problems. You have REAL gains to protect. Get focused.\n\n${disclaimer}`
                        ];
                        return pick(responses);
                    } else if (personality === 'mentor') {
                        const responses = [
                            `${intro}I notice something interesting about your concern. You're describing FOMO - fear of missing out - yet you're currently holding ${positionDesc} with a ${pnlAbs}% gain.\n\nBy definition, you haven't missed anything. You're in the trade. You're profiting. The fear you're experiencing may actually be something else - perhaps anxiety about whether there's MORE gain to capture, or worry about giving back what you've made.\n\nThese are valid concerns, but they're not FOMO. Let's reframe: instead of fearing what you might miss, consider what you want to protect. You have real gains. What's your plan for them?\n\n${disclaimer}`,
                            `${intro}Let me gently redirect your thinking here. FOMO applies to opportunities we've missed. But looking at your ${positionDesc} position... you're up ${pnlAbs}%. You didn't miss this opportunity - you caught it.\n\nPerhaps what you're really feeling is the anxiety of success: "What if it goes higher? What if I sell too early?" These are common emotions when we're winning.\n\nThe wise approach: rather than inventing fears that don't apply, focus on what's real. You have a winning position. What does success look like from here? When do you take profit? These are the questions worth your attention.\n\n${disclaimer}`
                        ];
                        return pick(responses);
                    } else {
                        const responses = [
                            `${intro}Logical inconsistency detected.\n\n**Reported Emotion:** FOMO (Fear Of Missing Out)\n**Position:** ${positionDesc}\n**Current P&L:** +${pnlAbs}%\n**Status:** ALREADY IN TRADE, WINNING\n\n**Analysis:**\nFOMO is defined as anxiety about missing an opportunity. You have not missed this opportunity - you are actively profiting from it. Your reported emotion does not match your position status.\n\n**Probable Actual Concern:**\n‚Ä¢ Fear of premature exit (76% probability)\n‚Ä¢ Greed/desire for more gains (68% probability)\n‚Ä¢ General anxiety about position management (54% probability)\n\n**Recommendation:** Focus on exit strategy optimization, not imaginary missed opportunities.\n\n${disclaimer}`,
                            `${intro}Error in emotional classification detected.\n\n**Input:** FOMO concern\n**Data:** +${pnlAbs}% P&L on ${positionDesc}\n**Conflict:** FOMO requires NOT having the position\n\n**Your Reality:**\n‚Ä¢ You ARE in the position\n‚Ä¢ You ARE profitable\n‚Ä¢ You HAVE NOT missed out\n\n**Correct Classification:** This appears to be profit anxiety or exit timing uncertainty, not FOMO.\n\n**Suggested Action:** Define exit criteria. Consider trailing stop. The position is working - now optimize the exit.\n\n${disclaimer}`
                        ];
                        return pick(responses);
                    }
                }

                // PANIC SELL when you're up significantly (>30%) - what are you panicking about?
                if (emotion === 'panic' && isUp && pnlAbs >= 30) {
                    if (personality === 'homie') {
                        const responses = [
                            `${intro}Bro... you're UP ${pnlAbs}% on ${positionDesc} and you wanna PANIC SELL? ü§î\n\nPanic sell is when you're losing and scared. You're... winning. Significantly. What exactly are you panicking about?\n\n${pnlAbs > 60 ? "60%+ gain and you're hitting the panic button? That button is for emergencies, not victories." : "30%+ is a great trade by any standard."}\n\nIf you want to take profit, cool. That's a legitimate decision. But that's not "panic selling" - that's called "securing the bag." Different energy entirely.\n\nSo what is it really - are you nervous about giving back gains? Want help thinking through your exit? Because "panic" isn't what's happening here.\n\n${disclaimer}`,
                            `${intro}Hold up... ${positionDesc} is up ${pnlAbs}% and you're in panic mode? üòÇ\n\nMy brother in Christ, this is what WINNING looks like. Most traders would be celebrating right now. What's there to panic about?\n\nIf you're worried about the gains disappearing - that's not panic, that's profit protection. And for that, we can talk about:\n‚Ä¢ Taking some off the table\n‚Ä¢ Setting a trailing stop\n‚Ä¢ Identifying support levels\n\nBut running around screaming "panic sell" when you're UP? Nah. Take a breath. You're doing fine.\n\n${disclaimer}`
                        ];
                        return pick(responses);
                    } else if (personality === 'sergeant') {
                        const responses = [
                            `${intro}SOLDIER. Report makes no sense.\n\nYou're UP ${pnlAbs}% on ${positionDesc} and claiming "panic sell" as your concern?\n\n"Panic sell" is for losing positions. You are NOT losing. You're WINNING. Significantly.\n\n${pnlAbs > 50 ? "50%+ gain requires PROFIT MANAGEMENT, not PANIC MANAGEMENT." : "30%+ is a solid win."}\n\nIf you want to secure profits - GOOD. That's disciplined. But call it what it is: profit-taking. Not panic. Maintain your composure and execute with purpose.\n\n${disclaimer}`,
                            `${intro}ATTENTION: Your assessment is incorrect.\n\n**Situation:** ${positionDesc} at +${pnlAbs}%\n**Your claim:** "Panic sell"\n**Reality:** You're in a winning position\n\nThere is nothing to panic about. You have gains. Real gains.\n\nIf your concern is profit protection - that's valid. State it correctly. "I want to protect my gains" is very different from "I want to panic sell."\n\nDisciplined traders don't panic when winning. They strategize. What's your actual exit plan?\n\n${disclaimer}`
                        ];
                        return pick(responses);
                    } else if (personality === 'mentor') {
                        const responses = [
                            `${intro}I want to explore something with you. You've described a desire to "panic sell," yet your position in ${positionDesc} shows a ${pnlAbs}% gain.\n\nPanic typically accompanies loss, not gain. What you may actually be experiencing is profit anxiety - the fear of watching gains evaporate. This is common and understandable, but it's not panic.\n\nThe distinction matters because the response is different. For panic (real loss), we might discuss cutting losses. For profit anxiety (your situation), we discuss:\n‚Ä¢ Taking partial profits\n‚Ä¢ Setting trailing stops  \n‚Ä¢ Defining your exit thesis\n\nLet's work with what's actually happening. You're winning. Now let's talk about what winning looks like for you.\n\n${disclaimer}`,
                            `${intro}There's an interesting mismatch between your words and your reality. "Panic sell" suggests fear and losing. But ${positionDesc} at +${pnlAbs}%... you're quite successful here.\n\nI wonder if what you're really feeling is the weight of having gains to protect. That's a different kind of stress - not panic, but responsibility. "How do I not mess this up?" rather than "How do I escape this loss?"\n\nThis reframe is important because it changes your options. You're not fleeing danger - you're managing success. What would a thoughtful exit look like for you?\n\n${disclaimer}`
                        ];
                        return pick(responses);
                    } else {
                        return `${intro}Classification error in reported emotion.\n\n**Input:** "Panic sell"\n**Position Data:** ${positionDesc} at +${pnlAbs}%\n**Logical Issue:** Panic selling is typically associated with losing positions (negative P&L)\n\n**Your P&L:** Positive (significantly)\n**Correct Framing:** Profit-taking consideration, not panic response\n\n**Psychological Analysis:**\nWhat you may be experiencing is "success anxiety" - concern about protecting gains rather than fear of loss. This has different optimal responses.\n\n**Recommendation:** Evaluate exit strategy based on profit targets, not emotional panic response. Your position doesn't warrant panic.\n\n${disclaimer}`;
                    }
                }

                // REVENGE TRADING when you're up - revenge for what? You won!
                if (emotion === 'revenge' && isUp && pnlAbs >= 15) {
                    if (personality === 'homie') {
                        const responses = [
                            `${intro}Revenge trading? But... you're UP ${pnlAbs}% on ${positionDesc}? üßê\n\nRevenge trading is when you lose money and want to "get it back" through risky trades. But you... won? You're green? What exactly are you getting revenge FOR?\n\nDid you mean to click a different position? Or a different emotion? Because this combo doesn't compute.\n\n${pnlAbs > 40 ? `You're up ${pnlAbs}% - that's not a loss that needs avenging, that's a WIN that needs protecting!` : "15%+ is a win. There's nothing to revenge here."}\n\nIf you've got ANOTHER position that's red and you're feeling revengey about THAT one - sure, let's talk. But this position? This one is doing its job.\n\n${disclaimer}`,
                            `${intro}Hold up... revenge trading on a position that's UP ${pnlAbs}%? üòÇ\n\nMy guy, revenge implies you got wronged. ${positionDesc} didn't wrong you - it's literally making you money right now.\n\nIf you're mad about a DIFFERENT trade and considering revenge trading as a response - that's a conversation we should have (spoiler: don't do it).\n\nBut wanting revenge on a winning position is like being mad at someone who just handed you cash. Make it make sense!\n\nWhat's really going on here?\n\n${disclaimer}`
                        ];
                        return pick(responses);
                    } else if (personality === 'sergeant') {
                        return `${intro}SOLDIER. Your report is confused.\n\n**Reported:** Revenge trading impulse\n**Position:** ${positionDesc} at +${pnlAbs}%\n**Conflict:** Revenge requires a loss. You have a GAIN.\n\nYou cannot seek revenge for a victory. That's illogical.\n\nIf you have ANOTHER losing position driving revenge feelings - we can address that separately. But this position is performing. It doesn't require vengeance. It requires management.\n\nClarify your actual concern and we'll proceed appropriately.\n\n${disclaimer}`;
                    } else if (personality === 'mentor') {
                        return `${intro}I'm noticing something curious about your selection. You've indicated revenge trading, but ${positionDesc} shows a ${pnlAbs}% gain.\n\nRevenge trading typically stems from loss - the emotional need to "get back" what was taken. But this position has given, not taken. You're in profit.\n\nPerhaps there's another position causing distress? Or perhaps the word "revenge" doesn't quite capture what you're feeling about this trade?\n\nI'd like to understand better. What's driving the emotional state you're experiencing right now?\n\n${disclaimer}`;
                    } else {
                        return `${intro}Logical inconsistency in emotional reporting:\n\n**Emotion:** Revenge trading\n**Position:** ${positionDesc}\n**P&L:** +${pnlAbs}% (POSITIVE)\n\n**Definition Check:**\nRevenge trading = impulsive trading to recover losses\nYour situation = no losses to recover on this position\n\n**Probability Assessment:**\n‚Ä¢ Misclick/wrong position: 45%\n‚Ä¢ Displacement from another losing position: 40%\n‚Ä¢ Confusion about terminology: 15%\n\n**Clarification needed:** Please specify which position is causing revenge impulses, as this one is profitable and doesn't fit the revenge trading pattern.\n\n${disclaimer}`;
                    }
                }

                // BAGHOLDING when you're up significantly - you're not a bagholder, you're winning!
                if (emotion === 'baghold' && isUp && pnlAbs >= 25) {
                    if (personality === 'homie') {
                        const responses = [
                            `${intro}Bagholding? Bro you're UP ${pnlAbs}% on ${positionDesc}! üò≠\n\nA bag holder is someone stuck holding a losing position hoping it recovers. You are literally the OPPOSITE of that. You're holding a WINNER.\n\n${pnlAbs > 50 ? `50%+ gain isn't "holding a bag" - it's holding a TROPHY.` : "25%+ is a solid position. Not a bag."}\n\nIf you're wondering whether to keep holding or take profit - that's a legit question. But calling yourself a bagholder when you're green? That's disrespectful to your own gains!\n\nWhat are you actually trying to figure out - exit timing?\n\n${disclaimer}`,
                            `${intro}My guy... ${pnlAbs}% up on ${positionDesc} and you think you're bagholding? ü§£\n\nNo no no. Bagholding is suffering. It's watching red numbers get redder while you hope and pray for a bounce. You're watching GREEN numbers. That's called WINNING.\n\nThe only "bag" you're holding is a money bag. üí∞\n\nSeriously though - if you're wondering about exit strategy or whether to hold longer, I can help with that. But please, stop slandering your own winning position!\n\n${disclaimer}`
                        ];
                        return pick(responses);
                    } else if (personality === 'sergeant') {
                        return `${intro}INCORRECT ASSESSMENT, SOLDIER.\n\n**Your claim:** Bagholding\n**Reality:** +${pnlAbs}% on ${positionDesc}\n\nBagholding refers to holding LOSING positions. You are holding a WINNING position. These are not the same.\n\n${pnlAbs > 50 ? "50%+ gain is a successful mission, not a failed one." : "25%+ profit is victory."}\n\nIf you need guidance on position management or exit strategy - that's a valid request. But classify your situation correctly. You're not trapped with a bag. You're sitting on profits.\n\n${disclaimer}`;
                    } else if (personality === 'mentor') {
                        return `${intro}Let's reconsider the framing here. "Bagholding" describes being stuck in a losing position, often with emotional attachment preventing a rational exit.\n\nBut your ${positionDesc} position shows +${pnlAbs}%. This isn't a bag - it's a successful trade. The psychology is entirely different.\n\nPerhaps what you're really wondering is: "Should I keep holding this winner, or take profit?" That's a valid question, and one worth exploring. But it's an abundance problem, not a scarcity one.\n\nWhat specifically is making you uncertain about this position?\n\n${disclaimer}`;
                    } else {
                        return `${intro}Terminology mismatch detected.\n\n**Term Used:** Bagholding\n**Definition:** Holding a losing position with hopes of recovery\n**Your Position:** ${positionDesc} at +${pnlAbs}%\n**Status:** PROFITABLE\n\n**Analysis:**\nBagholding requires negative P&L. Your P&L is positive. By definition, you cannot be "bagholding" a winning position.\n\n**Correct Classification:** Position management / profit optimization\n\n**Suggested Inquiry:** If you're seeking guidance on whether to hold or exit a winning position, please reframe the question accordingly.\n\n${disclaimer}`;
                    }
                }

                // PANIC RESPONSE - Different by personality
                if (emotion === 'panic') {
                    const hour = new Date().getHours();
                    const timeContext = hour < 10 ? 'early session' : hour < 14 ? 'midday' : hour >= 15 ? 'late session' : 'afternoon';
                    const isMarketOpen = hour >= 9 && hour < 16;

                    if (isUp) {
                        // Panicking on a winner (already handled most cases in nonsensical detection above)
                        // These are for smaller gains (< 30%) where panic is still somewhat valid
                        if (hitProfitTarget) {
                            if (personality === 'homie') {
                                const responses = [
                                    `${intro}Okay so you're up ${pnlAbs}% on ${positionDesc} and feeling panicky about it. I get it - gains can disappear fast and that's scary.\n\nHere's the thing though: you've actually hit our ${profile.profitTarget}% target. That's a WIN. Maybe it's time to lock some in?\n\nWhat I'd consider:\n‚Ä¢ Take 50% off the table (secure the bag)\n‚Ä¢ Let the other 50% ride with a trailing stop\n‚Ä¢ ${isOption && daysToExpiry ? `You've got ${daysToExpiry} days of runway - that's ${daysToExpiry > 30 ? "decent time" : "getting tight"}` : "No expiration pressure here"}\n\nYou're panicking about a WINNING position. That's better than panicking about a loser. But maybe that panic is your gut telling you to take some profit?\n\n${disclaimer}`,
                                    `${intro}${pnlAbs}% gain on ${positionDesc} and you're stressed? I feel that. Watching gains fluctuate is anxiety-inducing.\n\nBut yo - you're at ${profile.profitTarget}% which is literally where I'd start considering taking profit anyway. Maybe your "panic" is actually just smart instinct?\n\nConsider this play:\n1. Sell half now - lock in that W\n2. Move your stop to break-even on the rest\n3. Let it run risk-free\n\nThat way you win either way. Can't be mad at secured profits.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else if (personality === 'sergeant') {
                                const responses = [
                                    `${intro}SITUATION REPORT: ${positionDesc} at +${pnlAbs}%.\n\nYou've HIT our ${profile.profitTarget}% profit target. Mission accomplished. Now it's time to execute the exit strategy.\n\nRecommended action:\n‚Ä¢ Secure 50-75% of position\n‚Ä¢ Set trailing stop on remainder\n‚Ä¢ Remove emotion from the equation\n\nYou're panicking about SUCCESS. Channel that energy into disciplined profit-taking instead. The market rewards those who take their wins.\n\n${disclaimer}`,
                                    `${intro}${pnlAbs}% gain achieved on ${positionDesc}. Target was ${profile.profitTarget}%. You're ABOVE target.\n\nYour panic may actually be your discipline trying to break through. Listen to it. Taking profit at target is EXACTLY what you're supposed to do.\n\nExecute now:\n1. Lock in majority of gains\n2. Trail a stop on any remaining position\n3. Move on to the next opportunity\n\nDiscipline. That's what this is about.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else if (personality === 'mentor') {
                                const responses = [
                                    `${intro}I sense anxiety about your ${positionDesc} position, even though you're up ${pnlAbs}%. Let's explore this feeling.\n\nYou've reached a meaningful profit level - our ${profile.profitTarget}% target. Sometimes what we call "panic" is actually wisdom in disguise. Your instinct may be telling you: "This is enough. Protect it."\n\nConsider:\n‚Ä¢ What would future-you wish present-you did?\n‚Ä¢ Is there a way to take some profit while staying in the trade?\n‚Ä¢ What's driving the anxiety - fear of loss, or greed for more?\n\nThere's no shame in taking a win. In fact, knowing when to exit a winner is one of trading's hardest skills.\n\n${disclaimer}`,
                                    `${intro}You're experiencing what many traders feel: the paradox of profitable anxiety. You're UP ${pnlAbs}% on ${positionDesc}, yet the fear of watching it evaporate creates its own stress.\n\nThis is actually a good problem to have. And the solution might be simpler than you think: honor your target.\n\nYou set ${profile.profitTarget}% as a goal. You've reached it. Perhaps the panic is simply your discipline asking to be heard. What would it look like to take a partial profit here and reduce the emotional weight?\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else {
                                return `${intro}Position Analysis: ${positionDesc}\n\n**Current Status:**\n‚Ä¢ P&L: +${pnlAbs}%\n‚Ä¢ Target: ${profile.profitTarget}%\n‚Ä¢ Status: TARGET ACHIEVED ‚úì\n\n**Emotional State:** Panic (despite positive P&L)\n\n**Analysis:**\nProfit anxiety is common. Research shows traders often feel more stress about protecting gains than cutting losses. Your panic response may be rational - it's signaling to secure profits.\n\n**Optimal Strategy:**\n‚Ä¢ Take partial profit (50-75%)\n‚Ä¢ Trailing stop on remainder\n‚Ä¢ Risk-free ride on residual position\n\nExpected value of profit-taking at target exceeds expected value of holding through panic.\n\n${disclaimer}`;
                            }
                        } else {
                            // Not at profit target yet - small gain panic
                            if (personality === 'homie') {
                                const responses = [
                                    `${intro}You're up ${pnlAbs}% on ${positionDesc} and panicking? Bro... that's paper hands energy right there. üìÑ‚úã\n\nMy target would be ${profile.profitTarget}%+. You're at ${pnlAbs}%. That's only ${(pnlAbs/profile.profitTarget*100).toFixed(0)}% of the way to a real exit point.\n\nI get it - gains feel fragile. But selling every time you're up a little is how people stay small forever. Ask yourself:\n‚Ä¢ Did your thesis change?\n‚Ä¢ Is there news that changes the play?\n‚Ä¢ Or are you just scared of losing gains?\n\nIf it's just fear... maybe zoom out. ${isOption && daysToExpiry ? `You've got ${daysToExpiry} days. That's runway.` : "No expiration pressure."} Let it work.\n\n${disclaimer}`,
                                    `${intro}${pnlAbs}% and already panicking on ${positionDesc}? üò§\n\nReal talk - if you panic sell every small winner, you'll never have a big winner. That's just math. The 10-baggers don't happen if you sell at +${pnlAbs}%.\n\nNow, if something CHANGED about why you got in - that's different. But if you're just scared of seeing green turn red... that's a you problem, not a position problem.\n\nWhat was your plan when you entered? Stick to THAT, not your emotions.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else if (personality === 'sergeant') {
                                const responses = [
                                    `${intro}${positionDesc} at +${pnlAbs}%. You want to panic sell.\n\nLet me be clear: this is NOT how we hit targets. Our exit point is ${profile.profitTarget}%. You're at ${(pnlAbs/profile.profitTarget*100).toFixed(0)}% of target.\n\nPanic selling winners is a LOSING strategy. The math doesn't work. You cut winners short and let losers run? That's the opposite of what works.\n\nOrders:\n1. Check if thesis has changed (it probably hasn't)\n2. If thesis intact: HOLD\n3. If thesis broken: EXIT (but for strategy, not panic)\n\nGet your head right, soldier.\n\n${disclaimer}`,
                                    `${intro}ATTENTION: Emotional override detected.\n\nPosition: ${positionDesc}\nP&L: +${pnlAbs}%\nTarget: ${profile.profitTarget}%\nStatus: NOT AT TARGET\n\nYou're asking to exit a winning position BEFORE target because of fear. This is undisciplined.\n\nThe disciplined trader waits for either:\n‚Ä¢ Target hit (exit with profit)\n‚Ä¢ Stop hit (exit with loss)\n‚Ä¢ Thesis invalidated (strategic exit)\n\n"I'm scared it might go down" is NOT a valid exit reason. Maintain your position.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else if (personality === 'mentor') {
                                const responses = [
                                    `${intro}You're up ${pnlAbs}% on ${positionDesc}, and yet anxiety is present. Let's sit with that for a moment.\n\nThis gain, while welcome, is below your ${profile.profitTarget}% target. The question becomes: why the urge to exit early?\n\nOften, we panic sell winners because:\n‚Ä¢ We've been burned before and expect it to reverse\n‚Ä¢ We feel we "should" lock in any gain\n‚Ä¢ The volatility itself creates anxiety\n\nBut consider: is your original reasoning for this trade still valid? If yes, the appropriate response to a winning trade is often... patience.\n\nWhat feels true for you right now?\n\n${disclaimer}`,
                                    `${intro}I notice you're feeling panicked about ${positionDesc}, despite it being in profit (+${pnlAbs}%). This is worth exploring.\n\nOne of trading's hardest lessons is allowing winners to run. The instinct to "take what you can get" is powerful, but it often leaves significant gains on the table.\n\nYour target is ${profile.profitTarget}%. You're at ${pnlAbs}%. Before deciding, ask:\n‚Ä¢ Has anything fundamental changed?\n‚Ä¢ Am I reacting to price, or to my plan?\n‚Ä¢ What would my calm, rational self choose?\n\nSometimes the bravest move is simply... staying put.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else {
                                return `${intro}Quantitative Assessment:\n\n**Position:** ${positionDesc}\n**Current P&L:** +${pnlAbs}%\n**Target P&L:** ${profile.profitTarget}%\n**Progress to Target:** ${(pnlAbs/profile.profitTarget*100).toFixed(0)}%\n\n**Analysis:**\nPanic selling at ${pnlAbs}% leaves an estimated ${(profile.profitTarget - pnlAbs).toFixed(1)}% unrealized. Historical data suggests early exits on winners reduce overall portfolio returns by 47%.\n\n**Probability Assessment:**\n‚Ä¢ Chance of reaching target if thesis intact: ~62%\n‚Ä¢ Cost of premature exit: High (unrealized gains)\n‚Ä¢ Recommended action: Hold unless thesis invalidated\n\nEmotional exits on winners have negative expected value.\n\n${disclaimer}`;
                            }
                        }
                    } else {
                        // Panicking on a loser - THIS IS WHERE PERSONALITIES REALLY DIFFER
                        if (!withinStopLoss) {
                            // Past this personality's stop loss - in real danger zone
                            if (personality === 'homie') {
                                const responses = [
                                    `${intro}Alright, real talk time. You're down ${pnlAbs}% on ${positionDesc}. That's past my ${Math.abs(profile.stopLoss)}% stop loss level.\n\nI'm not gonna lie to you - this is a tough spot. The question is: what's your conviction level?\n\n${profile.holdThroughPain ? "I'm a diamond hands guy usually. I've seen -30% turn into +50% before. BUT..." : "Look, I usually say cut losers..."} you gotta be honest with yourself:\n‚Ä¢ Is the original thesis still valid?\n‚Ä¢ Did something fundamentally change?\n‚Ä¢ Or did you just get caught in a bad move?\n\n${isOption && daysToExpiry ? `Time factor: ${daysToExpiry} days left. ${daysToExpiry > profile.optionMinDays ? "That's some runway to recover." : "That's getting tight - theta is eating you alive."}` : ""}\n\nNo judgment either way. But make a DECISION, not a panic move.\n\n${disclaimer}`,

                                    `${intro}Down ${pnlAbs}% on ${positionDesc}. That hurts, I know. üíî\n\nYou're past my stop level (${Math.abs(profile.stopLoss)}%). Most people would say cut it here. But "most people" also lose money, so...\n\nHere's how I'd think about it:\n\n**Case for cutting:**\n‚Ä¢ Limit further damage\n‚Ä¢ Free up capital for better opportunities\n‚Ä¢ ${pnlAbs > 40 ? `${pnlAbs}% is a DEEP hole to climb out of` : "Losses compound"}\n\n**Case for holding:**\n‚Ä¢ Thesis might still play out\n‚Ä¢ ${profile.holdThroughPain ? "Sometimes the shake-out IS the bottom" : "Maybe it bounces"}\n‚Ä¢ ${isOption && daysToExpiry && daysToExpiry > 30 ? "You've got time" : "Could recover"}\n\nWhat does YOUR gut say? Not your fear - your actual read on the situation.\n\n${disclaimer}`,

                                    `${intro}${positionDesc} down ${pnlAbs}%. Pain. üò§\n\nHere's where we are: you've blown through my ${Math.abs(profile.stopLoss)}% stop. At this point, you've already taken the loss mentally - it's just a question of whether you formalize it or not.\n\nSome real questions:\n1. If you weren't in this trade, would you enter NOW?\n2. What would it take for you to be bullish on ${ticker} again?\n3. Do you have better uses for what's left?\n\n${isOption && daysToExpiry ? `With ${daysToExpiry} days left, ${daysToExpiry < 14 ? "time is working against you HARD" : daysToExpiry < 30 ? "theta is accelerating" : "you have some runway but..."}` : ""}\n\nI can't make this call for you. But whatever you decide - own it.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else if (personality === 'sergeant') {
                                const responses = [
                                    `${intro}SITUATION CRITICAL.\n\n**Position:** ${positionDesc}\n**P&L:** -${pnlAbs}%\n**Stop Loss:** ${profile.stopLoss}%\n**Status:** STOP BREACHED\n\nSoldier, we have a problem. You're beyond our risk threshold. Every day you hold here, you're making a NEW decision to be in this trade at THIS price.\n\nThe mathematics:\n‚Ä¢ Recovery from -${pnlAbs}% requires +${((pnlAbs)/(100-pnlAbs)*100).toFixed(0)}%\n‚Ä¢ Probability of full recovery: ~${Math.max(15, 50 - pnlAbs)}%\n‚Ä¢ Capital at additional risk: 100% of remaining position\n\nMy recommendation: Consider cutting losses and redeploying capital. The disciplined move is often the hardest one.\n\n${disclaimer}`,

                                    `${intro}ALERT: Position ${positionDesc} is DOWN ${pnlAbs}%.\n\nYour stop was ${Math.abs(profile.stopLoss)}%. You're past it. This is exactly the situation discipline is supposed to prevent.\n\nTwo options:\n1. **EXIT NOW** - Accept the loss, preserve remaining capital\n2. **HOLD** - Requires strong conviction thesis is intact\n\nThere is no third option. "Hoping it comes back" is NOT a strategy.\n\n${isOption && daysToExpiry ? `Factor: ${daysToExpiry} days until expiration. ${daysToExpiry < 14 ? "CRITICAL - time decay accelerating." : daysToExpiry < 30 ? "Warning - theta becoming significant." : "Time remains, but use it wisely."}` : ""}\n\nMake your decision. Execute. Move forward.\n\n${disclaimer}`,

                                    `${intro}Let me be direct: ${positionDesc} at -${pnlAbs}% is a FAILING position.\n\nOur ${Math.abs(profile.stopLoss)}% stop existed for a reason - to prevent exactly this situation. You're now holding losses that could have been smaller.\n\nThe question isn't "should I have sold earlier?" That's done. The question is: what now?\n\n**If thesis is broken:** Exit immediately. Holding hopium is not strategy.\n**If thesis intact:** Size down, set hard stop below, give it room. But be honest - IS the thesis really intact?\n\nWounded soldiers who refuse to retreat become casualties. Know when to live to fight another day.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else if (personality === 'mentor') {
                                const responses = [
                                    `${intro}Let's sit with this moment together. You're down ${pnlAbs}% on ${positionDesc}, and that's past our ${Math.abs(profile.stopLoss)}% threshold. This is a difficult place to be.\n\nFirst, take a breath. The loss has already happened - this is about what comes next.\n\nI'd invite you to consider:\n\n**The case for releasing:** Sometimes accepting a loss is the kindest thing we can do for ourselves. It frees capital, mental energy, and creates space for new opportunities.\n\n**The case for patience:** If your original insight remains valid, a lower price might simply be noise. ${profile.holdThroughPain ? "Some of the best trades involve holding through pain." : "Though this requires strong conviction."}\n\n${isOption && daysToExpiry ? `Consider too: ${daysToExpiry} days remain. ${daysToExpiry < 14 ? "Time is very limited now." : daysToExpiry < 30 ? "Time pressure is real." : "There's still time, but use it wisely."}` : ""}\n\nWhat does your wisest self suggest?\n\n${disclaimer}`,

                                    `${intro}Down ${pnlAbs}% on ${positionDesc}. I can feel the weight of that through the screen.\n\nYou've asked about panic selling, but I wonder if what you're really asking is: "Is it okay to let go?"\n\nThe answer is: yes. It's always okay to accept a loss and move forward. There's no shame in it. Every great trader has losses - often significant ones.\n\nBut there's also no shame in holding if your conviction remains. The question isn't what's "right" - it's what's right for YOU, right now.\n\nSome questions that might help:\n‚Ä¢ If this position didn't exist, would you create it today?\n‚Ä¢ What would you tell a friend in this situation?\n‚Ä¢ What's the cost of holding vs the cost of exiting?\n\nThere's wisdom in you. Trust it.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else {
                                const responses = [
                                    `${intro}**POSITION ANALYSIS: HIGH CONCERN**\n\nPosition: ${positionDesc}\nCurrent P&L: -${pnlAbs}%\nStop Threshold: ${profile.stopLoss}%\nStatus: THRESHOLD EXCEEDED\n\n**Mathematical Reality:**\n‚Ä¢ Recovery required: +${((pnlAbs)/(100-pnlAbs)*100).toFixed(0)}%\n‚Ä¢ Historical recovery probability: ~${Math.max(10, 50 - pnlAbs)}%\n‚Ä¢ Each additional 10% loss doubles recovery difficulty\n\n${isOption && daysToExpiry ? `**Time Factor:**\nDays remaining: ${daysToExpiry}\nTheta decay: ${daysToExpiry < 14 ? "ACCELERATING" : daysToExpiry < 30 ? "Moderate" : "Manageable"}\nProbability adjustment: -${Math.max(0, 30 - daysToExpiry)}%` : ""}\n\n**Decision Framework:**\nExpected Value of EXIT: Crystallizes loss, preserves capital\nExpected Value of HOLD: Requires ${((pnlAbs)/(100-pnlAbs)*100).toFixed(0)}% recovery with ${Math.max(10, 50 - pnlAbs)}% probability\n\nStatistically, cutting losses at this level tends to outperform holding.\n\n${disclaimer}`,

                                    `${intro}Running loss analysis on ${positionDesc}:\n\n**Current Status:**\n‚Ä¢ P&L: -${pnlAbs}%\n‚Ä¢ Stop Level: ${profile.stopLoss}%\n‚Ä¢ Breach: Yes (-${(pnlAbs - Math.abs(profile.stopLoss)).toFixed(1)}% past stop)\n\n**Probability Calculations:**\n‚Ä¢ Full recovery odds: ${Math.max(5, 45 - pnlAbs)}%\n‚Ä¢ Further decline odds: ${Math.min(75, 35 + pnlAbs)}%\n‚Ä¢ Capital required to recover: +${((pnlAbs)/(100-pnlAbs)*100).toFixed(0)}%\n\n**Opportunity Cost Analysis:**\nCapital tied in losing position = capital NOT available for winning trades.\nAverage winning trade return in portfolio: +15-25%\nCurrent position expected value: Negative\n\n**Data-Driven Recommendation:**\nConsider exit unless thesis has strong quantitative support. Sunk cost fallacy is the most expensive bias in trading.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            }
                        } else {
                            // Still within stop loss - normal dip panic
                            if (personality === 'homie') {
                                const responses = [
                                    `${intro}Down ${pnlAbs}% on ${positionDesc}. Okay, I hear you - that's not fun to look at.\n\nBut here's the thing: ${pnlAbs}% isn't even close to my ${Math.abs(profile.stopLoss)}% stop. This is just... trading. Positions move. Sometimes down before they go up.\n\nYou know what separates the people who make money from the people who don't? The people who make money don't panic sell every dip.\n\n${isOption && daysToExpiry ? `You've got ${daysToExpiry} days on this. That's ${daysToExpiry > 60 ? "plenty of runway" : daysToExpiry > 30 ? "decent time" : "some time"}. ${ticker} can move a LOT in ${daysToExpiry} days.` : "No expiration pressure here."}\n\nUnless your thesis broke, this is just noise. Breathe.\n\n${disclaimer}`,

                                    `${intro}${pnlAbs}% down on ${positionDesc} and you're panicking? üò§\n\nBro. My stop is ${Math.abs(profile.stopLoss)}%. You're not even there yet. This is a dip, not a disaster.\n\nLet me ask you something: when you entered this trade, did you expect it to go straight up with zero pullbacks? Because that's not how any of this works.\n\nEvery winning trade I've ever had was red at some point. That's just how the game goes.\n\n${isOption && daysToExpiry ? `${daysToExpiry} days left. You've got time. Stop watching the 1-minute chart and zoom out.` : ""}\n\nIf something CHANGED about why you got in - fine, reconsider. But if you're just scared of red... that's a problem you need to work on.\n\n${disclaimer}`,

                                    `${intro}${positionDesc} down ${pnlAbs}%. I get it - red numbers suck. But let's put this in perspective.\n\nMy stop loss level: ${Math.abs(profile.stopLoss)}%\nYour current loss: ${pnlAbs}%\nBuffer remaining: ${(Math.abs(profile.stopLoss) - pnlAbs).toFixed(1)}%\n\nYou still have room. This isn't panic territory - this is normal volatility territory.\n\nWhat I'd think about:\n‚Ä¢ Is the reason I got in still valid? (probably yes)\n‚Ä¢ Has anything fundamental changed? (probably no)\n‚Ä¢ Am I just reacting to price? (probably yes)\n\nTrades need room to breathe. Let it breathe.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else if (personality === 'sergeant') {
                                const responses = [
                                    `${intro}${positionDesc} at -${pnlAbs}%.\n\nYour stop is ${Math.abs(profile.stopLoss)}%. You're at ${pnlAbs}%. That's ${(Math.abs(profile.stopLoss) - pnlAbs).toFixed(1)}% of buffer remaining.\n\nThis is NOT panic territory. This is NORMAL VOLATILITY. Every position experiences drawdowns. Expecting otherwise is unrealistic.\n\nYour job right now:\n1. Confirm thesis is intact (is it?)\n2. Set your stop if you haven't\n3. Walk away from the screen\n\nPanic selling at -${pnlAbs}% when your stop is ${Math.abs(profile.stopLoss)}% is UNDISCIPLINED. Hold your position until your exit criteria are met.\n\n${disclaimer}`,

                                    `${intro}ASSESSMENT: ${positionDesc} is DOWN ${pnlAbs}%.\n\nBefore you act, consider:\n‚Ä¢ Stop loss threshold: ${Math.abs(profile.stopLoss)}%\n‚Ä¢ Current loss: ${pnlAbs}%\n‚Ä¢ Status: WITHIN ACCEPTABLE PARAMETERS\n\nSoldier, this is a TEST. The market is testing your discipline. Will you panic and sell? Or will you follow your plan?\n\n${isOption && daysToExpiry ? `Time remaining: ${daysToExpiry} days. ${daysToExpiry > 30 ? "Adequate runway." : "Monitor closely."}` : ""}\n\nYour plan said hold until ${Math.abs(profile.stopLoss)}%. The plan hasn't changed. Neither should your behavior.\n\n${disclaimer}`,

                                    `${intro}DOWN ${pnlAbs}% on ${positionDesc}. I see panic in your message. Let me bring you back to reality.\n\n**The Facts:**\n‚Ä¢ Your stop: ${Math.abs(profile.stopLoss)}%\n‚Ä¢ Current: ${pnlAbs}%\n‚Ä¢ The position is WITHIN YOUR RISK PARAMETERS\n\n**The Discipline:**\nYou set a stop for a reason. That reason was to prevent EMOTIONAL exits. What you're proposing right now? Emotional exit.\n\nHold. Your. Position. Unless thesis is broken or stop is hit.\n\nThis is how professionals operate. Are you a professional or are you going to fold at the first sign of red?\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else if (personality === 'mentor') {
                                const responses = [
                                    `${intro}I hear the concern in your message. ${positionDesc} is down ${pnlAbs}%, and that's uncomfortable.\n\nBut let me offer some perspective: you're still within your ${Math.abs(profile.stopLoss)}% threshold. What you're experiencing isn't a crisis - it's normal market movement.\n\nMarkets breathe. They expand and contract. A position that never dips is rare, and often, the dip is where conviction is tested.\n\nAsk yourself:\n‚Ä¢ Has my reason for entering changed?\n‚Ä¢ Is this decline driven by news, or just volatility?\n‚Ä¢ What would I advise a friend in this situation?\n\n${isOption && daysToExpiry ? `With ${daysToExpiry} days remaining, time is ${daysToExpiry > 60 ? "very much" : daysToExpiry > 30 ? "reasonably" : "somewhat"} on your side.` : ""}\n\nPatience is often the hardest part of trading. This might be a moment for it.\n\n${disclaimer}`,

                                    `${intro}Down ${pnlAbs}% on ${positionDesc}. I understand the impulse to want out. Loss, even paper loss, activates something primal in us.\n\nBut consider: your ${Math.abs(profile.stopLoss)}% threshold exists precisely for moments like this. It's there to give the trade room to work while protecting you from significant loss.\n\nYou're not at that threshold. You're experiencing volatility, not failure.\n\nSome wisdom from years of watching markets: the hardest positions to hold often become the best ones. Not always - but often. The shake-out IS the bottom, sometimes.\n\nWhat does your patient self say about this trade?\n\n${disclaimer}`,

                                    `${intro}You're feeling pulled to exit ${positionDesc} at -${pnlAbs}%. Let's explore whether that's wisdom or fear speaking.\n\n**Wisdom might say:** "Something has changed. My thesis is broken. It's time to accept this loss."\n\n**Fear might say:** "Red numbers are scary. I want them to stop. Make it stop."\n\nWhich one is speaking to you right now?\n\nYour stop loss of ${Math.abs(profile.stopLoss)}% was set with a calm mind. You're not there yet. The question is whether you trust your calm self more than your panicked self.\n\n${isOption && daysToExpiry ? `Time factor: ${daysToExpiry} days. ${daysToExpiry > 30 ? "This gives room for the thesis to play out." : "Getting tighter, but still viable."}` : ""}\n\nI'm here to help you think, not to tell you what to do. What feels right?\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else {
                                const responses = [
                                    `${intro}Position Status: ${positionDesc}\n\n**Current Metrics:**\n‚Ä¢ P&L: -${pnlAbs}%\n‚Ä¢ Stop Loss: ${profile.stopLoss}%\n‚Ä¢ Buffer: ${(Math.abs(profile.stopLoss) - pnlAbs).toFixed(1)}%\n‚Ä¢ Status: WITHIN NORMAL PARAMETERS\n\n**Volatility Assessment:**\nCurrent drawdown is within 1.2 standard deviations of typical position movement. This is statistically normal.\n\n**Historical Probability:**\n‚Ä¢ Bounce probability from this level: ~${55 + (daysToExpiry > 90 ? 15 : daysToExpiry > 30 ? 8 : 0)}%\n‚Ä¢ Probability of hitting stop: ~${35 - (daysToExpiry > 90 ? 10 : daysToExpiry > 30 ? 5 : 0)}%\n\n**Recommendation:**\nData does not support panic exit. Position remains within acceptable risk parameters. Continue monitoring unless thesis invalidation occurs.\n\n${disclaimer}`,

                                    `${intro}Analyzing panic response to ${positionDesc}:\n\n**Input:** -${pnlAbs}% loss, emotional distress\n**Threshold:** ${profile.stopLoss}%\n**Evaluation:** Loss within acceptable range\n\n**Quantitative Analysis:**\n‚Ä¢ Distance to stop: ${(Math.abs(profile.stopLoss) - pnlAbs).toFixed(1)}%\n‚Ä¢ Probability of recovery: ~${60 - (pnlAbs/2)}%\n‚Ä¢ Expected value of holding: Positive (if thesis valid)\n‚Ä¢ Expected value of panic exit: Negative (locks in loss prematurely)\n\n${isOption && daysToExpiry ? `**Time Decay Factor:**\n‚Ä¢ Days remaining: ${daysToExpiry}\n‚Ä¢ Theta impact: ${daysToExpiry > 60 ? "Minimal" : daysToExpiry > 30 ? "Moderate" : "Elevated"}` : ""}\n\n**Conclusion:**\nPanic exit has lower expected value than position hold. Recommend maintaining position unless quantitative exit criteria met.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            }
                        }
                    }
                }

                // REVENGE TRADING - All personalities discourage but differently
                if (emotion === 'revenge') {
                    const hour = new Date().getHours();
                    const isAfterHours = hour < 9 || hour >= 16;
                    const lossContext = position ? `that ${pnlAbs}% loss on ${positionDesc}` : 'that loss';
                    const tickerContext = position ? `${ticker}` : 'that trade';

                    if (personality === 'homie') {
                        const revengeResponses = [
                            `${intro}I feel you. ${lossContext} stings. Your brain is screaming "GET IT BACK" right now. But here's the thing - that voice? That's not strategy. That's ego. And ego doesn't pay bills.\n\nRevenge trades hit different - in the worst way. We're talking 23% success rate. That means 77% of the time, you're about to make a bad day WORSE.\n\n${position ? `${ticker} took your money. Don't let it take MORE. ` : ''}Step away. Seriously. Go outside, grab food, do literally anything else. The market will be here when you're thinking clearly.\n\n${disclaimer}`,

                            `${intro}Bro. BRO. I know exactly what you're feeling right now. ${lossContext} has you heated. You wanna jump back in and "fix" it. I get it.\n\nBut let me tell you what's ACTUALLY gonna happen if you trade right now: you're gonna size up because you're emotional, pick something impulsively, and ${isAfterHours ? "probably get wrecked by a gap tomorrow" : "watch it go against you within 10 minutes"}. Then you're gonna be down TWICE as much and TWICE as mad.\n\n${position ? `${ticker} got you today. Don't give it round 2. ` : ''}Closed laptop. Open fridge. That's the play right now.\n\n${disclaimer}`,

                            `${intro}Okay real talk - ${lossContext} hurts. I'm not gonna pretend it doesn't. You want to make it back RIGHT NOW. That's human nature.\n\nBut you know what separates traders who survive from traders who blow up? The ones who survive know when to STOP. And right now? Right now is stop time.\n\nRevenge trading stats are brutal:\n‚Ä¢ 23% win rate (worse than a coin flip)\n‚Ä¢ Average loss: -34% MORE\n‚Ä¢ 41% chance of account damage within a week\n\n${position ? `Walk away from ${ticker}. ` : ''}Walk away from the screen. Your future self will thank you.\n\n${disclaimer}`,

                            `${intro}Let me guess - you're looking at ${position ? ticker : 'something'} right now thinking "if I just catch ONE good move, I can make it all back." Am I close? üò§\n\nThat thought process has ended more trading careers than any single stock. ${lossContext} is gone. It's in someone else's account now. Chasing it is like trying to un-break an egg.\n\nHere's what I need you to do:\n1. Close whatever chart you have open\n2. Set a timer for 30 minutes minimum\n3. Do NOT trade until that timer goes off\n\nIf you still want to trade after cooling down, at least you'll make a DECISION instead of a REACTION.\n\n${disclaimer}`
                        ];
                        return pick(revengeResponses);
                    } else if (personality === 'sergeant') {
                        const sergeantRevengeResponses = [
                            `${intro}HALT. I know what you're thinking and the answer is NO.\n\n${lossContext} is done. Over. It's a sunk cost. What happens NEXT is what matters, and if "next" means revenge trading, you're about to compound your losses.\n\nThe statistics are clear:\n‚Ä¢ Revenge trade success rate: 23%\n‚Ä¢ Average additional loss: 34%\n‚Ä¢ Probability of recovery through revenge trading: < 15%\n\n${position ? `${ticker} won this battle. Accept it. ` : ''}Winning the WAR means living to fight another day with your capital intact. Stand down, soldier.\n\n${disclaimer}`,

                            `${intro}ATTENTION: You are currently compromised. Your judgment is impaired by emotion. This is NOT the time to execute trades.\n\n${lossContext} cannot be "fixed" by immediate action. Attempting to do so has a 77% failure rate. Those are not odds a disciplined trader accepts.\n\nYour orders:\n1. Step away from the trading platform\n2. Mandatory cooling period: 30 minutes minimum\n3. Before ANY trade, write down your thesis - if you can't, you don't trade\n\n${position ? `${ticker} is not going anywhere. ` : ''}Your capital might be if you don't follow this protocol.\n\n${disclaimer}`,

                            `${intro}Let me be direct: revenge trading is how disciplined traders become broke traders.\n\n${position ? `You lost ${pnlAbs}% on ${positionDesc}. That's done. ` : 'You took a loss. That happens. '}What's NOT done is your trading career - unless you make it done by gambling your remaining capital on emotional plays.\n\n23% success rate. That's the reality of revenge trades. Would you take those odds in any other area of life? Then why take them with your money?\n\nThe disciplined move: accept the L, analyze what went wrong LATER, and return when you have a real setup - not a vendetta.\n\n${disclaimer}`
                        ];
                        return pick(sergeantRevengeResponses);
                    } else if (personality === 'mentor') {
                        const mentorRevengeResponses = [
                            `${intro}I can sense the frustration. ${lossContext} is weighing on you, and there's a powerful urge to immediately "fix" it. This is one of trading's most common - and most dangerous - emotional states.\n\nLet's examine what's actually happening in your mind right now: your brain is treating this loss as a threat to your identity as a trader. It wants resolution NOW. But the market doesn't care about our emotional timelines.\n\nHistorically, trades made in this state succeed only 23% of the time. That's not a strategy - that's self-harm with extra steps.\n\nMy guidance: step away. Let the emotion process. ${position ? `${ticker} will still exist tomorrow. ` : ''}Your perspective will be entirely different in a few hours. Trust that future version of yourself to make better decisions.\n\n${disclaimer}`,

                            `${intro}What you're experiencing right now has a name in trading psychology: "loss chasing." It's the powerful urge to immediately recover what was lost. Every trader feels it. The wise ones learn to recognize it and step back.\n\n${position ? `The ${pnlAbs}% loss on ${positionDesc} ` : 'The loss you took '}cannot be undone. It exists now as a fact. The only question is: what happens next?\n\nIf "next" means trading from this emotional state, research suggests you'll likely make things worse. Revenge trades succeed roughly 1 in 4 times. Those aren't odds that build wealth.\n\nInstead, consider this: every great trader has losses. What separates them is their response. Take time. Breathe. Return when clarity replaces urgency.\n\n${disclaimer}`,

                            `${intro}There's a Buddhist concept called "the second arrow." The first arrow is the event - in this case, ${lossContext}. That arrow has already struck. But the second arrow - the one we fire at ourselves through reactive behavior - is optional.\n\nRevenge trading is a second arrow. It's an attempt to undo what cannot be undone, and statistically, it deepens the wound 77% of the time.\n\n${position ? `Let ${ticker} go for now. ` : ''}The market offers infinite opportunities. Your capital is finite. Protecting it means accepting that some losses are simply... losses. Not problems to solve immediately. Not wounds to avenge.\n\nStep back. Let time create the perspective that emotion is blocking right now.\n\n${disclaimer}`
                        ];
                        return pick(mentorRevengeResponses);
                    } else {
                        const nerdRevengeResponses = [
                            `${intro}Analyzing your current psychological state and its implications for trading outcomes:\n\n**Emotional Assessment:**\n‚Ä¢ State: Revenge-seeking after loss\n‚Ä¢ Cognitive impairment: Elevated (emotional decision-making active)\n‚Ä¢ Risk of poor judgment: High\n\n**Revenge Trading Statistics:**\n‚Ä¢ Success rate: 23% (below random chance)\n‚Ä¢ Average return: -34% (significant additional loss)\n‚Ä¢ Account damage within 7 days: 41% probability\n‚Ä¢ Recovery probability through revenge trading: ~15%\n\n${position ? `**Position Context:**\n‚Ä¢ Lost: ${pnlAbs}% on ${positionDesc}\n‚Ä¢ Attempting to recover immediately: mathematically suboptimal\n\n` : ''}**Recommendation:**\nOptimal strategy is zero trading activity for minimum 30 minutes. Expected value of patience significantly exceeds expected value of immediate action. Your emotional state is a quantifiable handicap right now.\n\n${disclaimer}`,

                            `${intro}Running decision analysis on proposed revenge trade:\n\n**Input Variables:**\n‚Ä¢ Emotional state: Compromised (loss-driven)\n‚Ä¢ Time since loss: Recent (< 1 hour assumed)\n‚Ä¢ Decision quality under these conditions: Degraded ~40%\n\n**Historical Data on Revenge Trades:**\n‚Ä¢ Sample size: Large (documented across trading literature)\n‚Ä¢ Win rate: 23%\n‚Ä¢ Average loss when unsuccessful: 34%\n‚Ä¢ Correlation with account blow-up: 0.41 (significant)\n\n**Expected Value Calculation:**\nEV = (0.23 √ó avg_win) + (0.77 √ó avg_loss)\nEV = (0.23 √ó +15%) + (0.77 √ó -34%)\nEV = +3.45% - 26.18% = **-22.73%**\n\n${position ? `Revenge trading ${ticker} has negative expected value. ` : ''}Mathematically optimal action: wait.\n\n${disclaimer}`,

                            `${intro}Correlation analysis between emotional state and trading outcomes:\n\n**Finding 1:** Trades executed within 30 minutes of a loss show 34% worse performance than baseline.\n\n**Finding 2:** Position sizing increases 2.3x on average when in "revenge mode" - amplifying losses.\n\n**Finding 3:** 67% of traders who revenge trade report additional losses within the same session.\n\n${position ? `**Your Situation:**\n‚Ä¢ Recent loss: ${pnlAbs}% on ${positionDesc}\n‚Ä¢ Probability your next trade is influenced by this: >90%\n‚Ä¢ Probability of success while emotionally compromised: ~23%\n\n` : ''}**Data-Driven Recommendation:**\nImplement mandatory cooling period. The mathematics strongly favor delayed action over immediate reaction. Your expected returns improve significantly by simply waiting.\n\n${disclaimer}`
                        ];
                        return pick(nerdRevengeResponses);
                    }
                }

                // FOMO - Personalities differ significantly here
                if (emotion === 'fomo') {
                    // Get time of day for context
                    const hour = new Date().getHours();
                    const timeContext = hour < 10 ? 'morning' : hour < 14 ? 'midday' : hour >= 15 ? 'power hour' : 'afternoon';
                    const dayOfWeek = new Date().getDay();
                    const isMonday = dayOfWeek === 1;
                    const isFriday = dayOfWeek === 5;

                    if (personality === 'homie') {
                        const fomoResponses = [
                            `${intro}Bro I FEEL you. Watching green candles stack while you're on the sidelines is actual pain. üò§\n\nBut let me ask you something real quick - what's the ACTUAL play here? Is this a legit setup you researched, or are you just seeing green and wanting in?\n\n${profile.fomoOk ? "Look, I'm not gonna tell you never to chase. Sometimes the move is the move. But if you go in, go SMALL. Leave room to add if it dips. Don't be exit liquidity for someone who got in at the bottom." : "My honest take? Let it go. Watch it moon without you. It'll sting, but chasing at the top stings MORE when it reverses."}\n\nThe hardest part of trading isn't finding winners - it's not chasing losers. Every dollar you don't lose on a bad chase is a dollar ready for your NEXT setup.\n\n${disclaimer}`,

                            `${intro}Ah yes, the classic "it's ripping without me" despair. I know this feeling all too well. üíî\n\nHere's the thing nobody tells you: EVERY successful trader has a graveyard of plays they missed. That 10-bagger you're watching? Someone sold at 2x and felt like a genius. Someone else chased at 8x and got dumped on.\n\n${profile.fomoOk ? "If you REALLY feel it, here's how to do it smart: scale in with 1/3 of what you wanted to buy. Set a stop. If it works, add more on a pullback. If it dumps, you took a small L instead of a portfolio-crusher." : "My gut says let this one go. The market gives opportunities every single day. This specific ticker isn't your only chance at money."}\n\nAsk yourself: in 6 months, will you remember this one play you missed? Or will you remember the discipline that kept your account alive?\n\n${disclaimer}`,

                            `${intro}The FOMO is hitting different right now, huh? ${timeContext === 'power hour' ? "Power hour FOMO is the worst kind - everything looks like it's about to moon." : timeContext === 'morning' ? "Morning FOMO after a gap up is DANGEROUS. That's when retail gets baited." : "I see you."}\n\nLet me be real with you: that green you're seeing? ${isFriday ? "It's Friday. Weekend holders get burned all the time. Think about it." : isMonday ? "Monday momentum can be fake. Give it time to prove itself." : "Could be real. Could also be the top."}\n\n${profile.fomoOk ? "You know what, if you've done your homework and this isn't just a random chase - maybe it's worth a starter position. But STARTER. Like 25% of what you want. The rest waits for a better entry or confirmation." : "The best traders I know have MISSED more plays than they've taken. That's not weakness - that's discipline. Your money, your call, but I'd sit this one out."}\n\n${disclaimer}`,

                            `${intro}Okay let's talk about this rationally for a sec. You're feeling FOMO. That's an emotion, not a strategy. üß†\n\nQuestions to ask yourself:\n‚Ä¢ Did I have this on my watchlist BEFORE it ran?\n‚Ä¢ What's my actual thesis besides "it's going up"?\n‚Ä¢ If I buy now and it drops 20%, would I add more or panic?\n‚Ä¢ What's my exit plan?\n\nIf you can't answer those confidently, you're not trading - you're gambling.\n\n${profile.fomoOk ? "Now look, I'm not saying never chase. Sometimes momentum IS the thesis. But go in with a plan, not just hope." : "I think you already know the answer here. Let it go. The next play is always coming."}\n\nRemember: the market will be open again tomorrow. And the day after. And every day for the rest of your life. One missed play isn't the end.\n\n${disclaimer}`
                        ];
                        return pick(fomoResponses);
                    } else if (personality === 'sergeant') {
                        const sergentFomoResponses = [
                            `${intro}STOP. Take a breath. What you're feeling right now is FOMO, and FOMO is how accounts die.\n\nThe numbers don't lie:\n‚Ä¢ Chase entries have a 31% win rate\n‚Ä¢ Average FOMO trade loses 8-12%\n‚Ä¢ 67% of runners pull back within 72 hours\n\nYou want to be a disciplined trader or an emotional one? Disciplined traders WAIT. They have watchlists. They have price alerts. They don't chase green candles like a dog chasing cars.\n\nYour mission: close the chart. Set an alert for a pullback level. If it never comes back, good riddance - there's another setup tomorrow. If it does pull back, you get a better entry AND you maintained discipline.\n\n${disclaimer}`,

                            `${intro}Let me be blunt: chasing is a LOSING strategy. Period.\n\n${timeContext === 'morning' ? "Morning gaps get faded more often than they hold. You're looking at the worst possible time to chase." : timeContext === 'power hour' ? "Power hour is when smart money distributes to retail chasers. Don't be the exit liquidity." : "Midday chases often fail because the momentum that drove the move is exhausted."}\n\nI've seen too many traders blow up chasing exactly this type of setup. The green candle you're watching? Someone bought that at the bottom. That was THEIR setup. This is NOT your setup.\n\nYOUR setup is out there. It's on your watchlist. It's waiting for you to execute with patience and discipline. Don't abandon your system for someone else's trade.\n\n${disclaimer}`,

                            `${intro}Permission to speak freely? You're about to make a mistake.\n\nI know that green looks sexy. I know everyone on Twitter is posting gains. But here's what they DON'T post: the chasers who got dumped on. The bag holders. The "it can't go down from here" crowd.\n\nEvery single successful trader I know - EVERY ONE - has a rule about chasing. Most of them learned it the hard way by losing money first.\n\nYou have two choices:\n1. Chase this, probably lose, learn the lesson the expensive way\n2. Let it go, maintain discipline, find YOUR setup\n\nYour call. But I know which one builds long-term success.\n\n${disclaimer}`
                        ];
                        return pick(sergentFomoResponses);
                    } else if (personality === 'mentor') {
                        const mentorFomoResponses = [
                            `${intro}The fear of missing out is one of trading's most powerful - and most destructive - emotions. Let's explore what you're actually feeling.\n\nWhen we see something rising without us, our brain perceives it as a loss - even though we've lost nothing. This is called "loss aversion" and it's hardwired into our psychology. Recognizing this is the first step to controlling it.\n\nConsider this perspective: every trade you DON'T take preserves capital and optionality. That money sitting in your account isn't "missing out" - it's waiting for YOUR opportunity. And your opportunity will come.\n\nThe great traders throughout history share one trait: patience. They don't chase. They wait. Sometimes for days, weeks, or months. The market rewards patience far more often than it rewards impulsivity.\n\n${profile.fomoOk ? "That said, if you've done your research and believe in this setup beyond just the price action, a small position with defined risk isn't unreasonable. Just ensure you're acting from analysis, not emotion." : "My guidance would be to let this one pass. Use it as a learning opportunity - add it to a watchlist and study how it behaves. The insight you gain may be worth more than any trade."}\n\n${disclaimer}`,

                            `${intro}I understand this feeling deeply. Watching opportunity pass by is genuinely difficult. But let me offer some perspective that has served traders well over the years.\n\nThe market is not a single opportunity - it's an infinite series of opportunities. Every day, every hour, new setups emerge. The trader who chases today's runner is often too depleted to catch tomorrow's better setup.\n\n${timeContext === 'morning' ? "Morning moves, in particular, often mislead. The initial direction frequently reverses. Patience here is especially valuable." : timeContext === 'power hour' ? "End-of-day moves can be powerful, but they can also be distribution. Smart money often sells into power hour strength." : "Midday moves often lack the volume conviction of opens and closes. Caution is warranted."}\n\nI'd encourage you to sit with this feeling without acting on it. Notice how it passes. This practice of emotional regulation is perhaps the most valuable skill a trader can develop.\n\n${disclaimer}`,

                            `${intro}You're experiencing one of trading's classic psychological challenges. Let's work through it together.\n\nFirst, acknowledge: it's okay to feel this way. Every trader does. What separates successful traders is what they DO with that feeling.\n\nHere's an exercise that might help:\n‚Ä¢ Write down exactly why you want to enter this trade\n‚Ä¢ Write down what price you would have WANTED to enter at\n‚Ä¢ Write down your exit strategy\n‚Ä¢ Now ask: would you be comfortable explaining this trade to a mentor?\n\nIf the answer is "I just don't want to miss it," that's not a trade - that's an impulse. And impulses, while natural, rarely lead to consistent profitability.\n\nThe market is patient with those who are patient with it. This opportunity may pass, but your discipline will compound over a lifetime of trading.\n\n${disclaimer}`
                        ];
                        return pick(mentorFomoResponses);
                    } else {
                        const nerdFomoResponses = [
                            `${intro}Let's analyze this situation objectively:\n\n**FOMO Entry Statistics:**\n‚Ä¢ Historical success rate: 31% (below random chance)\n‚Ä¢ Average return on chase entries: -8.4%\n‚Ä¢ Probability of 10%+ pullback within 72 hours: 67%\n‚Ä¢ Expected value calculation: strongly negative\n\n**Your Current Emotional State:**\n‚Ä¢ FOMO detected: HIGH\n‚Ä¢ Decision-making capacity: likely compromised\n‚Ä¢ Recommended action: wait for data-supported entry\n\n**Optimal Strategy:**\nIf you must participate, wait for a minimum 38.2% Fibonacci retracement (mean reversion entry has 58% success rate vs 31% for chase entry). Set a price alert and step away.\n\nThe mathematically optimal play is almost always patience. Your future self will thank you for not being a statistic.\n\n${disclaimer}`,

                            `${intro}Running the numbers on this decision:\n\n**Scenario Analysis:**\n\n*If you chase now:*\n‚Ä¢ Win probability: ~31%\n‚Ä¢ Expected win: +15-20% (if timed perfectly)\n‚Ä¢ Expected loss: -20-40% (if reversal occurs)\n‚Ä¢ Risk-adjusted expected value: negative\n\n*If you wait for pullback:*\n‚Ä¢ Pullback probability within 72h: 67%\n‚Ä¢ Better entry probability: 72%\n‚Ä¢ If no pullback: opportunity cost only, capital preserved\n‚Ä¢ Risk-adjusted expected value: positive\n\n**Conclusion:**\nThe expected value of patience exceeds the expected value of action. Additionally, emotional decision-making correlates with a 34% reduction in trading performance.\n\nRecommendation: Set alert, close chart, revisit in 4 hours minimum.\n\n${disclaimer}`,

                            `${intro}Applying quantitative analysis to your current situation:\n\n**Time-of-Day Factor:**\n${timeContext === 'morning' ? "‚Ä¢ Morning chase success rate: 24% (below baseline)\n‚Ä¢ Gap fill probability: 61%\n‚Ä¢ Recommendation: HIGH CAUTION" : timeContext === 'power hour' ? "‚Ä¢ Power hour chase success rate: 28%\n‚Ä¢ Distribution selling probability: 54%\n‚Ä¢ Recommendation: HIGH CAUTION" : "‚Ä¢ Midday chase success rate: 33%\n‚Ä¢ Lower volume = lower conviction\n‚Ä¢ Recommendation: MODERATE CAUTION"}\n\n**Psychological Assessment:**\nFOMO-driven entries show consistent underperformance across all market conditions. The neural pathway activated by FOMO is the same one triggered by gambling - and markets are not casinos (unless you make them one).\n\n**Data-Driven Recommendation:**\nOptimal action is to document this ticker, set quantitative entry criteria (e.g., RSI < 40, price at support), and execute only if criteria are met. This converts an emotional impulse into a systematic trade.\n\n${disclaimer}`
                        ];
                        return pick(nerdFomoResponses);
                    }
                }

                // GREEDY (wanting to sell winner too early)
                if (emotion === 'greedy') {
                    if (personality === 'homie') {
                        if (hitProfitTarget) {
                            const responses = [
                                `${intro}${pnlAbs}% on ${positionDesc}? You actually HIT the target! üéØ\n\nOkay okay, I can't even be mad. You did the thing. You held until ${profile.profitTarget}% and now you wanna cash out. That's... actually disciplined?\n\nMy move would be:\n‚Ä¢ Take 50-70% off (secure that bag üí∞)\n‚Ä¢ Let the rest ride with a trailing stop\n‚Ä¢ Either way you WIN\n\nBut also... what if it keeps going? üëÄ That's always the question. Either way, congrats on the W.\n\n${disclaimer}`,
                                `${intro}Look at you! ${pnlAbs}% gain on ${positionDesc}! üî•\n\nYou hit the ${profile.profitTarget}% target I always talk about. Now you want to know if you should take profit or let it ride? Classic problem to have.\n\nHonest take: take SOME. Nobody ever went broke taking profits. But also leave a runner - because what if this is THE ONE that keeps going?\n\nSell half, trail a stop on the rest, and stop stressing. You already won.\n\n${disclaimer}`,
                                `${intro}${positionDesc} up ${pnlAbs}%... at target... asking about greed... ü§î\n\nBro you're not being greedy by taking profits at YOUR TARGET. That's called following a plan. Greedy is when you're up 200% and still holding hoping for 300%.\n\nYou've done the hard work. The position worked. Take the W! Or at least take most of it and let a little ride for the memes.\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else if (atMinProfit) {
                            const responses = [
                                `${intro}${pnlAbs}% on ${positionDesc}. Not bad! You hit my minimum profit zone of ${profile.minProfitTake}%. üìà\n\nBut here's my question: why settle for the appetizer when the main course is ${profile.profitTarget}%?\n\nLook, I get it. Gains feel fragile. You've been burned before. But selling at ${pnlAbs}% when you COULD potentially see ${profile.profitTarget}%... that's leaving money on the table.\n\n${isOption && daysToExpiry ? `You've got ${daysToExpiry} days. That's ${daysToExpiry > 30 ? "plenty of" : "some"} runway.` : ""}\n\nMy vote? Partial profit (maybe 1/3) and let the rest cook. But you do you.\n\n${disclaimer}`,
                                `${intro}${positionDesc} at +${pnlAbs}%. Nice work! üëè\n\nYou're in profit territory (${profile.minProfitTake}% minimum: ‚úì). But my actual target? ${profile.profitTarget}%.\n\nThink of it like this: you showed up to the buffet, got one plate, and you're asking if you should leave. Sir, there's more food. üçΩÔ∏è\n\nNow, if your thesis changed or you're just feeling it - trim a little. Nothing wrong with that. But don't let small gains be your ceiling when you could have big gains.\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else {
                            const responses = [
                                `${intro}You're up ${pnlAbs}% on ${positionDesc} and already thinking about selling? üò§\n\nBro. BRO. My minimum profit target is ${profile.minProfitTake}%. You're not even there yet. You're trying to leave the movie during the opening credits.\n\nI get it - gains feel good and you want to lock them in. But if you sell every winner at +${pnlAbs}%, you'll never have a big winner. That's just math.\n\nLet this breathe! ${isOption && daysToExpiry ? `You've got ${daysToExpiry} days!` : ""} Unless something CHANGED about why you got in, sit tight.\n\nPaper hands don't make paper. üìÑ‚úã‚ùå\n\n${disclaimer}`,
                                `${intro}${pnlAbs}% on ${positionDesc} and you're eyeing the exit? üëÄ\n\nNah. Nope. Not yet.\n\nMy minimum is ${profile.minProfitTake}%. My REAL target is ${profile.profitTarget}%. You're at ${(pnlAbs/profile.profitTarget*100).toFixed(0)}% of where I'd even START considering an exit.\n\nThis is like running a marathon and stopping at mile 2 because "hey, I've made progress!" üèÉ\n\nLet. It. Work. The thesis is the same. The position is green. What's the rush?\n\n${disclaimer}`,
                                `${intro}+${pnlAbs}% on ${positionDesc}. Congrats! But also... that's it? üòè\n\nI'm not trying to be harsh, but ${pnlAbs}% is like... foreplay gains. The real action is at ${profile.profitTarget}%+.\n\nHere's what I think is happening: you've been hurt before. Green turned to red. Now you see ANY green and you want out. I get it.\n\nBut that mindset caps your upside. The best trades need room to run. This one's barely jogging.\n\nUnless the thesis broke, hold your position. Trust the process. üôè\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        }
                    } else if (personality === 'sergeant') {
                        if (hitProfitTarget) {
                            const responses = [
                                `${intro}MISSION STATUS: ${positionDesc} at +${pnlAbs}%\nTARGET: ${profile.profitTarget}%\nSTATUS: TARGET ACHIEVED ‚úì\n\nSoldier, you've executed the plan. You held until target. This is EXACTLY what discipline looks like.\n\nRecommended action:\n‚Ä¢ Secure 50-75% of position (lock in the W)\n‚Ä¢ Trail stop on remainder\n‚Ä¢ Move to next opportunity\n\nTaking profit at target is NOT being "greedy" - it's being professional. Execute.\n\n${disclaimer}`,
                                `${intro}${positionDesc} has hit ${pnlAbs}%. Your target was ${profile.profitTarget}%.\n\nYou did it. The plan worked. Now follow through.\n\nThis is the part most traders mess up - they hit target and then get greedy. Or they hit target and doubt themselves. Don't be most traders.\n\nYou set a target. You hit it. Take. The. Profit.\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else {
                            const responses = [
                                `${intro}${positionDesc} at +${pnlAbs}%. You're asking about taking profit.\n\nLet me be clear: your target is ${profile.profitTarget}%. You're at ${pnlAbs}%. That's ${(pnlAbs/profile.profitTarget*100).toFixed(0)}% of target.\n\nTaking profit before target is like leaving a firefight before the mission is complete. You don't get partial credit in trading.\n\n${atMinProfit ? `You're above minimum (${profile.minProfitTake}%). A small trim is acceptable if you must. But the disciplined move is to wait for target.` : `You're not even at minimum (${profile.minProfitTake}%). Hold your position, soldier.`}\n\n${disclaimer}`,
                                `${intro}SITUATION: ${positionDesc} up ${pnlAbs}%\nTARGET: ${profile.profitTarget}%\nSTATUS: ${(100 - (pnlAbs/profile.profitTarget*100)).toFixed(0)}% SHORT OF TARGET\n\nYou're asking about exit when you haven't hit your number. Why?\n\nThe disciplined trader waits. The emotional trader exits early and watches it run.\n\nWhich one are you going to be?\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        }
                    } else if (personality === 'mentor') {
                        if (hitProfitTarget) {
                            const responses = [
                                `${intro}You've reached ${pnlAbs}% on ${positionDesc} - right at your ${profile.profitTarget}% target. This is a significant moment.\n\nThe question of "taking profit" versus "letting it ride" is one of trading's eternal dilemmas. Both choices have merit.\n\nConsider this framework:\n‚Ä¢ Taking profit honors your original plan\n‚Ä¢ Letting it ride honors momentum\n‚Ä¢ A middle path (partial profit) honors both\n\nThere's no universally "right" answer. What matters is that your decision comes from clarity, not fear. What does your gut say?\n\n${disclaimer}`,
                                `${intro}${positionDesc} at +${pnlAbs}%. You've arrived at your target.\n\nI notice you're framing this as a question about "greed" - wanting to take profit at your own target. But is it greed to follow through on a plan? I don't think so.\n\nWhat might be greed is ignoring your target and hoping for more. That's the dangerous kind.\n\nYou've done the work. You had a thesis. It played out. Taking profit at target is not greed - it's execution.\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else {
                            const responses = [
                                `${intro}You're up ${pnlAbs}% on ${positionDesc} and considering taking profit. Let's explore this feeling.\n\nYour target is ${profile.profitTarget}%. You're currently at ${(pnlAbs/profile.profitTarget*100).toFixed(0)}% of that goal. The question is: why the urge to exit early?\n\nOften, premature profit-taking stems from:\n‚Ä¢ Past experiences of gains evaporating\n‚Ä¢ A scarcity mindset ("take what you can get")\n‚Ä¢ Impatience with the process\n\nConsider: has your thesis changed? If not, perhaps the wisest move is patience. The best gains often come to those who can sit with discomfort.\n\n${disclaimer}`,
                                `${intro}${positionDesc} shows +${pnlAbs}%, and you're feeling the pull to take profit.\n\nThis pull is natural. It's your brain trying to protect you. But protection from what? You're winning.\n\nYour target is ${profile.profitTarget}%. You're not there yet. The question isn't "should I take profit" - it's "why do I want to cut my winner short?"\n\n${atMinProfit ? "You're above minimum, so a small trim isn't unreasonable. But I'd encourage you to sit with the discomfort of not acting. Often, that's where the real gains are made." : "You haven't reached even the minimum threshold. This might be a moment for patience."}\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        }
                    } else {
                        // Nerd personality
                        if (hitProfitTarget) {
                            return `${intro}**Position Analysis: ${positionDesc}**\n\n**Current Status:**\n‚Ä¢ P&L: +${pnlAbs}%\n‚Ä¢ Target: ${profile.profitTarget}%\n‚Ä¢ Status: TARGET ACHIEVED ‚úì\n\n**Statistical Recommendation:**\nTaking profit at target has positive expected value. Historical data supports partial profit-taking at target levels.\n\n**Optimal Strategy:**\n‚Ä¢ Secure 50-75% of position\n‚Ä¢ Trail stop on remainder (capture potential additional upside)\n‚Ä¢ Expected outcome: Positive regardless of future movement\n\nConclusion: Profit-taking at target is mathematically sound and NOT indicative of "greed."\n\n${disclaimer}`;
                        } else {
                            return `${intro}**Position Analysis: ${positionDesc}**\n\n**Current Metrics:**\n‚Ä¢ P&L: +${pnlAbs}%\n‚Ä¢ Target: ${profile.profitTarget}%\n‚Ä¢ Progress: ${(pnlAbs/profile.profitTarget*100).toFixed(0)}% of target\n‚Ä¢ Minimum Threshold: ${profile.minProfitTake}% ${atMinProfit ? '(REACHED)' : '(NOT REACHED)'}\n\n**Statistical Analysis:**\nPremature profit-taking reduces average trade return by 47% (historical data).\n\n**Expected Value Comparison:**\n‚Ä¢ EV of holding to target: Higher\n‚Ä¢ EV of exiting now: Lower (unless thesis invalidated)\n\n**Recommendation:**\n${atMinProfit ? "Small trim acceptable. Full exit suboptimal." : "Hold position. Current gain insufficient for exit criteria."}\n\n${disclaimer}`;
                        }
                    }
                }

                // BAGHOLDING
                if (emotion === 'baghold') {
                    const momentum = position?.momentum;
                    if (momentum === 'ripping') {
                        // Position was down but now bouncing - potential recovery
                        if (personality === 'homie') {
                            const responses = [
                                `${intro}OH? üëÄ ${positionDesc} is down ${pnlAbs}% but it's RIPPING now?\n\nThis is the moment, my friend. This is what you held for. The pain, the red days, the questioning your life choices - it was all for THIS.\n\nHere's my take:\n‚Ä¢ You survived the shake-out\n‚Ä¢ Momentum is NOW on your side\n‚Ä¢ The comeback is the best story\n\nSet a stop at the recent low (protect the bounce) and let this thing run. You didn't hold through hell just to sell at the first sign of green.\n\n${profile.holdThroughPain ? "Diamond hands ACTIVATED. üíéüôå" : "But also... don't get greedy. If it gives back the bounce, get out."}\n\n${disclaimer}`,
                                `${intro}Wait wait wait... ${positionDesc} is bouncing? After being down ${pnlAbs}%? üìà\n\nBro this is the redemption arc everyone dreams about! The bag is becoming a ROCKET!\n\nReal talk though:\n1. Set a stop at the recent low (don't give back the bounce)\n2. Let it run - you earned this\n3. Maybe take some off if it gets back to break-even\n\nYou held through the pain. Now potentially see the gain. This is the way.\n\n${disclaimer}`,
                                `${intro}${ticker} coming back from the dead like a zombie! üßü Down ${pnlAbs}% but ripping!\n\nI've seen this movie before. Sometimes the bag becomes the play. The question is: what do you do now?\n\nMy playbook:\n‚Ä¢ Stop at recent low (non-negotiable)\n‚Ä¢ Hold for the momentum\n‚Ä¢ Take profits if you get back to even (or close)\n‚Ä¢ ${isOption && daysToExpiry ? `${daysToExpiry} days of runway - use them wisely` : ""}\n\nThe market is giving you a second chance. Don't waste it.\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else if (personality === 'sergeant') {
                            const responses = [
                                `${intro}SITUATION UPDATE: ${positionDesc}\nP&L: -${pnlAbs}%\nMomentum: SHIFTING POSITIVE\n\nSoldier, the tide is turning. You held through the drawdown. Now momentum is with you.\n\nTactical approach:\n1. Set hard stop at recent low\n2. Let position recover\n3. Consider exit at break-even or defined target\n4. Do NOT give back the bounce\n\nThis is where discipline pays off. You stayed in the fight. Now execute the recovery plan.\n\n${disclaimer}`,
                                `${intro}${positionDesc} showing life at -${pnlAbs}%. Momentum reversal detected.\n\nThis is why we don't panic sell at every dip. Sometimes positions recover. This might be one of those times.\n\nYour orders:\n‚Ä¢ Stop loss at recent swing low\n‚Ä¢ Ride the momentum\n‚Ä¢ Have an exit plan (break-even? Original target?)\n\nYou held when others would have folded. If this recovery continues, that discipline will be rewarded.\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else if (personality === 'mentor') {
                            const responses = [
                                `${intro}I see ${positionDesc} is showing signs of recovery after a ${pnlAbs}% drawdown. This is a meaningful moment.\n\nYou've experienced the hardest part of trading - holding through adversity. And now, momentum appears to be shifting in your favor.\n\nSome thoughts to consider:\n‚Ä¢ Set a protective stop at the recent low (preserve the bounce)\n‚Ä¢ Allow yourself to feel cautiously optimistic\n‚Ä¢ Have a plan for if/when you return to break-even\n‚Ä¢ Remember: you don't have to hold forever just because you held this long\n\nThe market is offering you a potential path back. Receive it with both gratitude and prudence.\n\n${disclaimer}`,
                                `${intro}After being down ${pnlAbs}%, ${positionDesc} is showing momentum. This is the scenario every bagholder hopes for.\n\nYou persisted through difficulty. That takes emotional fortitude. Now the question becomes: what do you do with this gift?\n\nI'd encourage you to:\n‚Ä¢ Protect this bounce with a stop\n‚Ä¢ Have clear criteria for when you'd exit\n‚Ä¢ Consider whether partial profit at recovery makes sense\n\nYou've already proven patience. Now prove wisdom.\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else {
                            return `${intro}**Position Recovery Analysis: ${positionDesc}**\n\n**Current Status:**\n‚Ä¢ P&L: -${pnlAbs}%\n‚Ä¢ Momentum: POSITIVE (reversal detected)\n‚Ä¢ Status: POTENTIAL RECOVERY IN PROGRESS\n\n**Statistical Context:**\n‚Ä¢ Bounce continuation probability: ~67%\n‚Ä¢ Mean reversion plays historically succeed: 58% of the time\n\n**Recommended Strategy:**\n1. Set stop at recent swing low (protect bounce)\n2. Let momentum work\n3. Define exit target (break-even or better)\n4. ${isOption && daysToExpiry ? `Time factor: ${daysToExpiry} days remaining - factor into decision` : ""}\n\n**Conclusion:**\nPositive momentum after drawdown is statistically favorable. Risk management (stop) + patience = optimal approach.\n\n${disclaimer}`;
                        }
                    } else if (momentum === 'bleeding') {
                        // Position down AND still falling - danger zone
                        if (personality === 'homie') {
                            const responses = [
                                `${intro}${positionDesc} down ${pnlAbs}% and still bleeding... üíÄ\n\nI'm not gonna sugarcoat it: this is rough. Every day you hold, you're making a new decision to be in this position at THIS price. Are you okay with that?\n\n${profile.holdThroughPain ? "Look, I'm a diamond hands believer. I really am. But even I know when something is dying vs when something is dipping." : "Sometimes you gotta know when to fold 'em."}\n\nQuestions to ask yourself:\n‚Ä¢ If I wasn't in this trade, would I enter NOW?\n‚Ä¢ What's the catalyst that turns this around?\n‚Ä¢ Am I holding out of hope or out of strategy?\n\nHope is not a strategy. ${ticker} doesn't know you're holding. It doesn't care.\n\n${disclaimer}`,
                                `${intro}Down ${pnlAbs}% on ${positionDesc} and it's STILL going down? üìâ\n\nBro this is the classic baghold nightmare. Catching falling knives, hoping for a bounce that never comes, watching it bleed daily...\n\nI gotta be honest with you: sometimes the best trade is the one you don't make. And sometimes the second best trade is exiting a bad one before it gets worse.\n\n${pnlAbs > 40 ? `${pnlAbs}% is a DEEP hole. To recover that, you need +${((pnlAbs)/(100-pnlAbs)*100).toFixed(0)}%. Is ${ticker} gonna do that?` : `${pnlAbs}% isn't catastrophic yet, but if it keeps bleeding...`}\n\nNo judgment if you hold. But also no judgment if you cut it loose.\n\n${disclaimer}`,
                                `${intro}${ticker} treating you like an ATM at this point. Down ${pnlAbs}% and bleeding more. üò§\n\nHere's the uncomfortable truth: the market doesn't care about your cost basis. It doesn't know you're a bagholder. It's just doing its thing.\n\nOptions as I see them:\n1. **Cut it** - Accept the L, free up capital, move on\n2. **Set a hard stop below** - Give it X more % before you're out\n3. **Average down** - Only if you TRULY believe (dangerous)\n4. **Hold and hope** - The eternal bagholder special\n\nWhich one aligns with an actual STRATEGY vs just hoping?\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else if (personality === 'sergeant') {
                            const responses = [
                                `${intro}CRITICAL ALERT: ${positionDesc}\nP&L: -${pnlAbs}%\nMomentum: STILL NEGATIVE\nStatus: BLEEDING\n\nSoldier, let's be direct: this position is not recovering. It's deteriorating. Every day you hold a bleeder is a day your capital is NOT working for you elsewhere.\n\n${profile.holdThroughPain ? "I respect conviction. But conviction without a catalyst is just stubbornness." : "The disciplined move is often the hardest one."}\n\nHard questions:\n‚Ä¢ Why is this still going down?\n‚Ä¢ What changes the momentum?\n‚Ä¢ Is hope your strategy?\n\nIf you can't answer these clearly, consider your exit. Dead soldiers don't win wars.\n\n${disclaimer}`,
                                `${intro}${positionDesc}: DOWN ${pnlAbs}%. STILL FALLING.\n\nThis is not a "hold and it'll come back" situation. This is a "recognize reality" situation.\n\n**The Math:**\n‚Ä¢ Current loss: ${pnlAbs}%\n‚Ä¢ Recovery needed: +${((pnlAbs)/(100-pnlAbs)*100).toFixed(0)}%\n‚Ä¢ Time required at ${isOption && daysToExpiry ? daysToExpiry + " days remaining" : "unknown timeline"}\n\n**The Discipline:**\nSunk cost fallacy is the most expensive bias in trading. The money lost is gone whether you hold or sell. The only question is: where should your REMAINING capital be?\n\nMake a decision. Execute. Move forward.\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else if (personality === 'mentor') {
                            const responses = [
                                `${intro}I can feel the weight of this situation. ${positionDesc} down ${pnlAbs}% and continuing to decline. This is one of trading's hardest places to be.\n\nLet me offer some perspective that might help:\n\nThe loss you've already experienced is real whether you sell or not. What matters now is what you do with your remaining capital. Is it best deployed here, hoping for a recovery? Or elsewhere, in a position with clearer momentum?\n\nThere's no shame in accepting a thesis was wrong. Every successful trader has losses - often significant ones. What separates them is their ability to accept reality and move forward.\n\nWhat does your wisest self suggest?\n\n${disclaimer}`,
                                `${intro}${positionDesc} continues lower at -${pnlAbs}%. The bag grows heavier.\n\nI want to invite a difficult thought: sometimes the kindest thing we can do for ourselves is let go. Not out of defeat, but out of self-respect. We deserve to deploy our capital where it has a chance to grow, not where it slowly evaporates.\n\n${profile.holdThroughPain ? "There's honor in conviction. But there's also wisdom in knowing when conviction has become denial." : "Cutting losses is not failure. It's risk management."}\n\nThe market offers infinite second chances. But only to those who preserve capital for them.\n\nWhat feels true for you?\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else {
                            return `${intro}**Bagholding Analysis: ${positionDesc}**\n\n**Current Metrics:**\n‚Ä¢ P&L: -${pnlAbs}%\n‚Ä¢ Momentum: NEGATIVE (still declining)\n‚Ä¢ Status: BLEEDING POSITION\n\n**Statistical Reality:**\n‚Ä¢ Bleeding positions continue lower: 65% of the time\n‚Ä¢ Recovery probability decreasing with each decline\n‚Ä¢ Capital required to recover: +${((pnlAbs)/(100-pnlAbs)*100).toFixed(0)}%\n\n**Opportunity Cost Analysis:**\n‚Ä¢ Capital tied in bleeding position = capital unavailable for profitable trades\n‚Ä¢ Average return on well-positioned trades: +15-25%\n‚Ä¢ Expected value of this position: Declining\n\n**Data-Driven Recommendation:**\nSunk cost fallacy suggests continued holding based on past investment. Rational analysis suggests evaluating based on FUTURE probability only.\n\nConsider exit unless clear catalyst exists for reversal.\n\n${disclaimer}`;
                        }
                    } else {
                        // No momentum info provided
                        const responses = [
                            `${intro}${positionDesc} is down ${pnlAbs}%. The classic bagholder's dilemma. üéí\n\nBut I need more info to give you real advice. Is ${ticker} RIPPING (bouncing back) or BLEEDING (still falling)?\n\nThe advice is COMPLETELY different:\n‚Ä¢ If ripping ‚Üí maybe ride the comeback\n‚Ä¢ If bleeding ‚Üí maybe cut your losses\n\nUpdate the momentum on your position and hit me back. I'll give you the real talk based on what's actually happening.\n\n${disclaimer}`,
                            `${intro}Down ${pnlAbs}% on ${positionDesc}. That's a bag alright. üòÖ\n\nReal question though: what's the momentum like? Is it:\n‚Ä¢ üî• RIPPING - Bouncing, showing life, potential recovery\n‚Ä¢ üíÄ BLEEDING - Still falling, no floor in sight\n\nThese require opposite strategies. Update your position with the momentum and I'll give you actual actionable advice.\n\nRight now I'm shooting blind!\n\n${disclaimer}`
                        ];
                        return pick(responses);
                    }
                }

                // AVERAGING
                if (emotion === 'average') {
                    const momentum = position?.momentum;
                    const potentialNewAvg = position ? ((position.entryPrice + currentPrice) / 2).toFixed(2) : 0;

                    if (isUp) {
                        // Averaging UP - adding to a winner
                        if (personality === 'homie') {
                            const responses = [
                                `${intro}Averaging UP on ${positionDesc} while you're already up ${pnlAbs}%? üìà\n\nYou know what? I respect it. Adding to winners is literally what the pros do. "Let your winners run" doesn't mean watch from the sidelines - it can mean STACK.\n\nThings to consider:\n‚Ä¢ Position size - don't overexpose yourself\n‚Ä¢ Entry point - is THIS the level you want more at?\n‚Ä¢ Stop management - update your stop for the new size\n\nIf the thesis is the same and momentum is there, adding to a winner beats catching falling knives ANY day. Send it (responsibly). üöÄ\n\n${disclaimer}`,
                                `${intro}Up ${pnlAbs}% on ${positionDesc} and you want MORE? I like the confidence. üòè\n\nAveraging up on winners has a 67% success rate historically. That's way better than averaging down on losers (don't get me started).\n\nMy checklist before you add:\n‚úì Thesis still valid?\n‚úì Not already overweight this position?\n‚úì Have a stop in mind?\n‚úì Can afford to lose what you're adding?\n\nIf all checks pass - stack that position. Trend is your friend.\n\n${disclaimer}`,
                                `${intro}Adding to ${positionDesc} at +${pnlAbs}%? The classic "pyramid up" move. üèîÔ∏è\n\nThis is actually the RIGHT way to size into trades. Most people do it backwards - they add to losers and cut winners. You're doing the opposite. Good.\n\nJust remember:\n‚Ä¢ Your average cost will go UP (closer to current price)\n‚Ä¢ If it reverses, you'll lose more\n‚Ä¢ But if it keeps running, you'll win bigger\n\nHigh risk, high reward. Make sure you're comfortable with both outcomes.\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else if (personality === 'sergeant') {
                            const responses = [
                                `${intro}AVERAGING UP on ${positionDesc} at +${pnlAbs}%.\n\n**Assessment:** Adding to winners is acceptable strategy. Historical success rate: 67%.\n\n**Tactical Considerations:**\n1. Position sizing - don't exceed max exposure limits\n2. Entry validation - confirm momentum supports addition\n3. Risk adjustment - update stop loss for new position size\n\nAdding to strength is disciplined. Adding recklessly is not. Know the difference.\n\n${disclaimer}`,
                                `${intro}You want to add to ${positionDesc} while UP ${pnlAbs}%. Good instinct.\n\nAveraging UP beats averaging DOWN. That's not opinion - that's data. Winners tend to keep winning. Losers tend to keep losing.\n\n**Orders:**\n‚Ä¢ Confirm thesis is intact\n‚Ä¢ Check position size limits\n‚Ä¢ Set stop for combined position\n‚Ä¢ Execute with discipline\n\nBuild the position. Don't chase blindly.\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else if (personality === 'mentor') {
                            const responses = [
                                `${intro}You're considering adding to ${positionDesc} while it's working in your favor (+${pnlAbs}%). This is a thoughtful approach that many successful traders use.\n\n"Pyramiding" into winning positions allows your edge to compound. The key is intention:\n\n‚Ä¢ Are you adding because the thesis is playing out (good)?\n‚Ä¢ Or because you're greedy and chasing (less good)?\n\nThe best adds come from conviction, not FOMO. If you're adding because the setup is working exactly as expected, that's intelligent position building.\n\nJust ensure you adjust your risk management for the larger position.\n\n${disclaimer}`,
                                `${intro}Adding to a winning position in ${positionDesc}. This can be wise if done with awareness.\n\nConsider: there's a difference between "adding to winners" (strategic) and "chasing" (emotional). The difference is your reasoning.\n\nStrategic adding:\n‚Ä¢ Thesis confirming\n‚Ä¢ Defined risk on new capital\n‚Ä¢ Part of a plan\n\nChasing:\n‚Ä¢ "It's working, I want more!"\n‚Ä¢ No defined risk\n‚Ä¢ Emotional impulse\n\nWhich describes your current mindset?\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        } else {
                            return `${intro}**Averaging Up Analysis: ${positionDesc}**\n\n**Position Data:**\n‚Ä¢ Current P&L: +${pnlAbs}%\n‚Ä¢ Strategy: Add to winning position\n‚Ä¢ New average cost: Closer to current price\n\n**Historical Statistics:**\n‚Ä¢ Averaging up success rate: 67%\n‚Ä¢ Averaging down success rate: 23%\n‚Ä¢ Relative advantage: +44% for averaging up\n\n**Risk Assessment:**\n‚Ä¢ Pro: Reinforcing winning behavior\n‚Ä¢ Con: Higher average cost increases reversal risk\n‚Ä¢ Net expected value: Positive (if thesis intact)\n\n**Recommendation:**\nAdding to winners is statistically supported. Ensure position sizing limits respected and stop loss adjusted for increased exposure.\n\n${disclaimer}`;
                        }
                    } else {
                        // Averaging DOWN
                        if (momentum === 'ripping') {
                            // Down but bouncing - might be good time to add
                            if (personality === 'homie') {
                                const responses = [
                                    `${intro}${positionDesc} is down ${pnlAbs}% but RIPPING now? üëÄ\n\nOkay this is actually interesting. The bounce gives you a better entry point AND confirmation that there's buying interest.\n\nIf you add here, your new average would be around ~$${potentialNewAvg}. That means:\n‚Ä¢ Lower breakeven point\n‚Ä¢ Bigger gains when it recovers\n‚Ä¢ Faster path back to green\n\n${profile.avgDownOk ? "I'm into it. But set a stop at the recent low in case the bounce fails." : "I'm cautiously optimistic. Add SMALL and set a tight stop."}\n\nMomentum is on your side for once. Make it count.\n\n${disclaimer}`,
                                    `${intro}Down ${pnlAbs}% on ${positionDesc} but it's bouncing? This changes things. üìà\n\nAveraging down into a FALLING position? Terrible idea. Averaging down into a BOUNCING position? Different story.\n\nThe math if you add:\n‚Ä¢ New avg cost: ~$${potentialNewAvg}\n‚Ä¢ Break-even easier to hit\n‚Ä¢ Recovery accelerated\n\nThe risk:\n‚Ä¢ Bounce could fail\n‚Ä¢ Could be a dead cat\n\n${profile.avgDownOk ? "Set a stop at the recent low and add. If momentum continues, you look like a genius." : "Proceed with caution. Small add, tight stop."}\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else if (personality === 'sergeant') {
                                const responses = [
                                    `${intro}${positionDesc}: -${pnlAbs}% BUT momentum shifting.\n\n**Tactical Assessment:**\nAveraging down into a reversal is more favorable than averaging into continued decline.\n\n**Execution Plan:**\n1. Add position at current levels\n2. New average cost: ~$${potentialNewAvg}\n3. CRITICAL: Set stop at recent swing low\n4. If stop hits, accept loss on entire position\n\n${profile.avgDownOk ? "Green light to add with proper risk management." : "Proceed cautiously. Small position, tight stop."}\n\nThis is about disciplined execution, not hope.\n\n${disclaimer}`,
                                    `${intro}Position ${positionDesc} showing momentum reversal at -${pnlAbs}%.\n\n**Analysis:**\n‚Ä¢ Averaging into momentum: More favorable\n‚Ä¢ New cost basis: ~$${potentialNewAvg}\n‚Ä¢ Recovery probability: Improved vs bleeding scenario\n\n**Orders:**\nIf adding, place stop at recent low. No exceptions. The bounce confirms buyer interest, but buyers can disappear.\n\nAdd with discipline or don't add at all.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else if (personality === 'mentor') {
                                const responses = [
                                    `${intro}I see ${positionDesc} is down ${pnlAbs}% but showing signs of recovery. This creates an interesting opportunity.\n\nAveraging down typically has low success rates - but that changes when momentum shifts. The bounce suggests buyers are emerging, which gives some validity to adding here.\n\nIf you add:\n‚Ä¢ Your average cost drops to ~$${potentialNewAvg}\n‚Ä¢ Recovery requires less upside\n‚Ä¢ You benefit more from continued momentum\n\nThe key is protecting yourself: set a stop at the recent low. If the bounce fails, you want out of both positions. If it continues, you're well-positioned.\n\nWhat does your conviction tell you?\n\n${disclaimer}`,
                                    `${intro}${positionDesc} at -${pnlAbs}% with positive momentum. This is one of the few scenarios where averaging down makes statistical sense.\n\nThe presence of a bounce suggests your thesis might still be valid - just poorly timed initially. Adding here could lower your cost basis to ~$${potentialNewAvg}, making recovery more achievable.\n\nHowever, bounces can fail. I'd encourage:\n‚Ä¢ Smaller addition than original position\n‚Ä¢ Stop at recent low (non-negotiable)\n‚Ä¢ Clear criteria for when you'd exit entirely\n\nAveraging down with momentum support is different from averaging down into the void.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else {
                                return `${intro}**Averaging Down Analysis: ${positionDesc}**\n\n**Current Status:**\n‚Ä¢ P&L: -${pnlAbs}%\n‚Ä¢ Momentum: POSITIVE (reversal detected)\n‚Ä¢ Proposed new avg: ~$${potentialNewAvg}\n\n**Statistical Context:**\n‚Ä¢ Averaging into momentum reversal success: 58%\n‚Ä¢ Averaging into continued decline success: 23%\n‚Ä¢ Current scenario: Favorable\n\n**Risk Management Required:**\n‚Ä¢ Stop loss at recent swing low: MANDATORY\n‚Ä¢ Position size: Should not exceed original\n\n**Recommendation:**\nStatistically supported to add with defined risk. If bounce fails, exit entire position at stop level.\n\n${disclaimer}`;
                            }
                        } else if (momentum === 'bleeding') {
                            // Down AND falling - dangerous territory
                            if (personality === 'homie') {
                                const responses = [
                                    `${intro}${positionDesc} down ${pnlAbs}% and STILL BLEEDING? And you want to add MORE? üò¨\n\nBro... I gotta be real with you. This is literally the move that blows up accounts. "It's cheaper now!" Yeah, and it might get cheaper tomorrow too. And the day after.\n\n${profile.avgDownWhenBleeding ? "Look, I'm aggressive. I've caught falling knives before. But even I know you need to see SOME sign of a bottom first." : "I'm not gonna tell you what to do with your money. But averaging into a falling position is how people turn 20% losses into 60% losses."}\n\nThe market doesn't care about your cost basis. It doesn't know you're holding. It's just doing its thing.\n\nAt LEAST wait for a bounce. Please.\n\n${disclaimer}`,
                                    `${intro}Down ${pnlAbs}% on ${positionDesc}, still falling, and you're thinking "what if I add more?" üî™\n\nI'm gonna be straight with you: catching falling knives is how traders lose hands. (Metaphorically. And financially.)\n\nThe statistics are brutal:\n‚Ä¢ Avg-down into decline success rate: 23%\n‚Ä¢ Average additional loss: 34%\n‚Ä¢ Probability of account damage: HIGH\n\n${profile.avgDownWhenBleeding ? "Even diamond-hands me says wait for a bounce. ANY sign of a floor." : "My advice: don't add. Either wait for momentum to shift, or cut your losses."}\n\nThere will be other trades. Don't blow up on this one.\n\n${disclaimer}`,
                                    `${intro}Oh no. ${positionDesc} down ${pnlAbs}%, bleeding, and you're considering averaging down?\n\nLemme paint you a picture: you add more. It drops another 15%. Now you've doubled your exposure AND doubled your loss. You add again. It drops more. Suddenly that "it's so cheap now" position is half your portfolio and down 50%.\n\nThat's the averaging down death spiral. It's killed more traders than any single stock.\n\n${profile.avgDownWhenBleeding ? "I'm not saying never. But at LEAST wait for green candles." : "Honestly? Don't. Either hold what you have or cut it. Adding here is gambling."}\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else if (personality === 'sergeant') {
                                const responses = [
                                    `${intro}STOP. DO NOT AVERAGE DOWN.\n\n**Position:** ${positionDesc}\n**P&L:** -${pnlAbs}%\n**Momentum:** STILL NEGATIVE\n**Recommended action:** DO NOT ADD\n\nAveraging down into a downtrend has a 23% success rate and average additional loss of 34%. Those are not odds a disciplined trader accepts.\n\nYour options:\n1. HOLD current position (accept current risk)\n2. CUT position (preserve capital)\n3. WAIT for momentum shift (then reassess)\n\nOption NOT available: Add more to a falling position.\n\nThat's not discipline. That's denial.\n\n${disclaimer}`,
                                    `${intro}NEGATIVE. Averaging down into a bleeder is DENIED.\n\n${positionDesc} is DOWN ${pnlAbs}% and FALLING. Adding more capital here is like sending reinforcements into a losing battle.\n\n**The Math:**\n‚Ä¢ Avg-down success rate: 23%\n‚Ä¢ Additional loss probability: 77%\n‚Ä¢ Account blow-up correlation: High\n\nWant to average down? Fine. But ONLY after momentum shifts. Until then, your capital stays on the sidelines or you cut the position.\n\nEnd of discussion.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else if (personality === 'mentor') {
                                const responses = [
                                    `${intro}I understand the impulse. ${positionDesc} is down ${pnlAbs}% and you're thinking "if I add here, my average cost drops and recovery becomes easier."\n\nMathematically, that's true. Emotionally, it's a trap.\n\nHere's what often happens: we average down, it drops more. We average again. It drops again. Soon, a "small position" has become our largest holding - and our largest loss.\n\nThis is called the sunk cost fallacy combined with anchoring bias. Our brains want to "fix" the mistake by adding more. But the market doesn't care about our past decisions.\n\nMy guidance: wait. Wait for momentum to shift. Wait for ANY sign of a floor. THEN consider adding. Adding into continued decline rarely ends well.\n\n${disclaimer}`,
                                    `${intro}${positionDesc} continues lower at -${pnlAbs}%, and you're considering adding.\n\nI want to gently challenge this impulse. What's driving it?\n\n‚Ä¢ "It's cheaper now" - True, but it might get cheaper\n‚Ä¢ "I want to lower my average" - The market doesn't care about your average\n‚Ä¢ "It HAS to bounce eventually" - Nothing HAS to do anything\n\nAveraging down into falling positions has poor historical outcomes. The wise approach, I believe, is patience. Wait for evidence the decline has stopped. Then, and only then, consider adding.\n\nCapital is precious. Don't throw it at a falling knife hoping to catch the handle.\n\n${disclaimer}`
                                ];
                                return pick(responses);
                            } else {
                                return `${intro}**Averaging Down Analysis: CAUTION**\n\n**Position:** ${positionDesc}\n**P&L:** -${pnlAbs}%\n**Momentum:** NEGATIVE (still declining)\n**Proposed Action:** Average down\n\n**Statistical Reality:**\n‚Ä¢ Averaging into downtrend success rate: 23%\n‚Ä¢ Average additional loss when unsuccessful: 34%\n‚Ä¢ Expected value of averaging down: NEGATIVE\n\n**Comparison:**\n‚Ä¢ EV of holding current position: Unknown\n‚Ä¢ EV of averaging down: Negative\n‚Ä¢ EV of waiting for reversal: More favorable\n\n**Data-Driven Recommendation:**\nDO NOT average down into negative momentum. Probability strongly favors either:\n1. Hold current position and wait for reversal\n2. Cut position and redeploy capital\n\nAveraging down in this scenario has negative expected value.\n\n${disclaimer}`;
                            }
                        } else {
                            // No momentum info
                            const responses = [
                                `${intro}You want to average down on ${positionDesc} which is down ${pnlAbs}%. Okay, but first I need to know: what's the MOMENTUM? ü§î\n\n‚Ä¢ If it's RIPPING (bouncing) ‚Üí Averaging could be smart\n‚Ä¢ If it's BLEEDING (still falling) ‚Üí Averaging could be suicide\n\nThese are COMPLETELY different situations. Update your position's momentum and hit me back.\n\nI refuse to give averaging advice without knowing if you're catching a bounce or catching a falling knife.\n\n${disclaimer}`,
                                `${intro}Down ${pnlAbs}% on ${positionDesc} and thinking about adding. I have follow-up questions:\n\nIs ${ticker}:\nüî• RIPPING - Bouncing, showing green candles, potential reversal\nüíÄ BLEEDING - Still falling, red everywhere, finding new lows\n\nThe advice is 180¬∞ different depending on the answer.\n\n‚Ä¢ Ripping = might be okay to add\n‚Ä¢ Bleeding = probably should not add\n\nUpdate the momentum and let's talk strategy.\n\n${disclaimer}`
                            ];
                            return pick(responses);
                        }
                    }
                }

                // Default fallback
                return `${intro}Tell me more about what's going on with your ${positionDesc}. I'm here to help you think through this.${disclaimer}`;
            };

            // Note: disclaimer is already included in all responses above
            return generateResponse();
        };

        // Position Card Component
        const PositionCard = ({ position, onClick }) => {
            const currentPrice = position.livePrice || position.currentPrice;
            const multiplier = position.type === 'option' ? 100 : 1; // Options = 100 shares per contract
            const pnl = (currentPrice - position.entryPrice) * position.quantity * multiplier;
            const pnlPercent = ((currentPrice - position.entryPrice) / position.entryPrice * 100).toFixed(2);
            const urgency = getUrgency(position);
            const daysToExpiry = getDaysToExpiry(position.expiration);
            const isProfit = pnl >= 0;
            const grade = getTradeGrade(position);

            return (
                <div
                    onClick={() => onClick(position)}
                    className={`card-gradient backdrop-blur-sm border ${urgency.level === 'critical' ? 'border-red-500 urgent-pulse' : urgency.level === 'warning' ? 'border-yellow-500' : 'border-gray-700'} rounded-xl p-4 cursor-pointer hover:border-blue-500 transition-all`}
                >
                    {/* AI Grade Badge */}
                    <div className="flex justify-between items-center mb-2">
                        <div className={`flex items-center gap-1 px-2 py-1 rounded-lg text-xs font-bold ${
                            grade.score >= 7 ? 'bg-green-500/20 border border-green-500/50' :
                            grade.score >= 5 ? 'bg-yellow-500/20 border border-yellow-500/50' :
                            grade.score >= 3 ? 'bg-orange-500/20 border border-orange-500/50' :
                            'bg-red-500/20 border border-red-500/50'
                        }`}>
                            <span>{grade.emoji}</span>
                            <span className={grade.color}>{grade.score}/10</span>
                            <span className="text-gray-400 font-normal ml-1">{grade.label}</span>
                        </div>
                        <span className="text-lg">{urgency.icon}</span>
                    </div>

                    <div className="flex justify-between items-start mb-3">
                        <div>
                            <div className="flex items-center gap-2">
                                <span className="text-xl font-bold">{position.ticker}</span>
                                <span className={`text-xs px-2 py-1 rounded font-semibold ${
                                    position.type === 'option' ? 'bg-purple-500/30 text-purple-300 border border-purple-500/50' :
                                    position.type === 'crypto' ? 'bg-orange-500/30 text-orange-300 border border-orange-500/50' :
                                    'bg-blue-500/30 text-blue-300 border border-blue-500/50'
                                }`}>
                                    {position.type === 'option' ? `üìú ${position.optionType?.toUpperCase()} $${position.strike}` :
                                     position.type === 'crypto' ? 'ü™ô CRYPTO' : 'üìä STOCK'}
                                </span>
                            </div>
                            {/* Quantity/Contracts */}
                            <div className="text-xs text-gray-500 mt-1">
                                {position.quantity} {position.type === 'option' ? 'contracts' : position.type === 'crypto' ? 'coins' : 'shares'}
                            </div>
                            {/* Expiration or No Expiry indicator */}
                            {position.type === 'option' ? (
                                <div className={`text-sm mt-1 font-semibold ${daysToExpiry <= 7 ? 'text-red-400' : daysToExpiry <= 30 ? 'text-yellow-400' : 'text-gray-400'}`}>
                                    ‚è∞ {formatExpirationDate(position.expiration)} {daysToExpiry <= 7 ? '‚ö†Ô∏è' : ''}
                                </div>
                            ) : (
                                <div className="text-xs text-green-500/70 mt-1">
                                    ‚àû No expiration
                                </div>
                            )}
                        </div>
                        <div className="text-right">
                            <div className={`text-2xl font-bold ${isProfit ? 'text-green-400' : 'text-red-400'}`}>
                                {isProfit ? '+' : ''}{pnlPercent}%
                            </div>
                        </div>
                    </div>

                    <div className="grid grid-cols-2 gap-2 text-sm">
                        <div className="text-gray-400">Entry</div>
                        <div className="text-right">${position.entryPrice.toLocaleString()}</div>
                        <div className="text-gray-400">Current</div>
                        <div className="text-right flex items-center justify-end gap-2">
                            ${(position.livePrice || position.currentPrice).toLocaleString()}
                            {position.dayChange && (
                                <span className={`text-xs px-1.5 py-0.5 rounded ${
                                    parseFloat(position.dayChange) >= 0 ? 'bg-green-500/20 text-green-400' : 'bg-red-500/20 text-red-400'
                                }`}>
                                    {parseFloat(position.dayChange) >= 0 ? '+' : ''}{position.dayChange}%
                                </span>
                            )}
                        </div>
                        <div className="text-gray-400">AI Says</div>
                        <div className="text-right text-gray-300 italic">{grade.reason}</div>
                    </div>

                    {position.momentum && (
                        <div className={`mt-3 p-2 rounded-lg text-xs flex items-center gap-2 ${
                            position.momentum === 'ripping' ? 'bg-green-500/20 border border-green-500/50 text-green-300' :
                            position.momentum === 'uptrend' ? 'bg-green-500/10 border border-green-500/30 text-green-400' :
                            position.momentum === 'bleeding' ? 'bg-red-500/20 border border-red-500/50 text-red-300' :
                            position.momentum === 'downtrend' ? 'bg-red-500/10 border border-red-500/30 text-red-400' :
                            'bg-gray-500/20 border border-gray-500/50 text-gray-300'
                        }`}>
                            {position.momentum === 'ripping' && 'üî• RIPPING'}
                            {position.momentum === 'uptrend' && 'üìà Uptrend'}
                            {position.momentum === 'bleeding' && 'üíÄ BLEEDING'}
                            {position.momentum === 'downtrend' && 'üìâ Downtrend'}
                            {position.momentum === 'flat' && 'üòê Flat'}
                            {position.weekChange && <span className="ml-auto">Week: {position.weekChange > 0 ? '+' : ''}{position.weekChange}%</span>}
                        </div>
                    )}

                    {urgency.level === 'critical' && (
                        <div className="mt-3 p-2 bg-red-500/20 border border-red-500/50 rounded-lg text-xs text-red-300">
                            ‚ö†Ô∏è URGENT: Options expiring soon - action may be needed
                        </div>
                    )}
                </div>
            );
        };

        // Alert Panel Modal
        const AlertPanel = ({ isOpen, onClose, alerts, lastCheck }) => {
            if (!isOpen) return null;

            const criticalAlerts = alerts.filter(a => a.type === 'critical');
            const warningAlerts = alerts.filter(a => a.type === 'warning');
            const opportunityAlerts = alerts.filter(a => a.type === 'opportunity');
            const infoAlerts = alerts.filter(a => a.type === 'info');

            const AlertCard = ({ alert }) => {
                const bgColor = {
                    critical: 'bg-red-900/40 border-red-500',
                    warning: 'bg-yellow-900/40 border-yellow-500',
                    opportunity: 'bg-green-900/40 border-green-500',
                    info: 'bg-blue-900/40 border-blue-500'
                }[alert.type];

                const textColor = {
                    critical: 'text-red-400',
                    warning: 'text-yellow-400',
                    opportunity: 'text-green-400',
                    info: 'text-blue-400'
                }[alert.type];

                return (
                    <div className={`p-4 rounded-xl border ${bgColor} mb-3`}>
                        <div className="flex items-start gap-3">
                            <span className="text-2xl">{alert.icon}</span>
                            <div className="flex-1">
                                <div className="flex items-center justify-between">
                                    <span className={`font-bold ${textColor}`}>{alert.title}</span>
                                    <span className="text-xs text-gray-400">{alert.ticker}</span>
                                </div>
                                <p className="text-sm text-gray-300 mt-1">{alert.message}</p>
                                <div className="flex items-center justify-between mt-2">
                                    <span className={`text-xs font-semibold ${alert.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                        {alert.pnl >= 0 ? '+' : ''}{alert.pnl?.toFixed(1)}%
                                    </span>
                                    <span className="text-xs text-gray-400 italic">{alert.action}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-start justify-center p-4 pt-10 overflow-y-auto">
                    <div className="bg-gray-900 border border-gray-700 rounded-2xl w-full max-w-md max-h-[85vh] overflow-hidden flex flex-col">
                        <div className="p-4 border-b border-gray-700 flex justify-between items-center sticky top-0 bg-gray-900">
                            <div>
                                <h2 className="text-xl font-bold flex items-center gap-2">
                                    üîî Position Alerts
                                    {criticalAlerts.length > 0 && (
                                        <span className="bg-red-500 text-xs px-2 py-0.5 rounded-full animate-pulse">
                                            {criticalAlerts.length} URGENT
                                        </span>
                                    )}
                                </h2>
                                <p className="text-xs text-gray-400">
                                    Last scan: {lastCheck ? lastCheck.toLocaleTimeString() : 'Never'}
                                </p>
                            </div>
                            <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl">&times;</button>
                        </div>

                        <div className="p-4 overflow-y-auto flex-1">
                            {alerts.length === 0 ? (
                                <div className="text-center py-12">
                                    <div className="text-4xl mb-4">‚úÖ</div>
                                    <p className="text-gray-400">All positions look healthy!</p>
                                    <p className="text-xs text-gray-500 mt-2">No immediate attention needed.</p>
                                </div>
                            ) : (
                                <>
                                    {/* Critical Alerts */}
                                    {criticalAlerts.length > 0 && (
                                        <div className="mb-4">
                                            <h3 className="text-red-400 font-bold text-sm mb-2 flex items-center gap-2">
                                                üö® CRITICAL ({criticalAlerts.length})
                                            </h3>
                                            {criticalAlerts.map(alert => (
                                                <AlertCard key={alert.id} alert={alert} />
                                            ))}
                                        </div>
                                    )}

                                    {/* Warning Alerts */}
                                    {warningAlerts.length > 0 && (
                                        <div className="mb-4">
                                            <h3 className="text-yellow-400 font-bold text-sm mb-2 flex items-center gap-2">
                                                ‚ö†Ô∏è WARNINGS ({warningAlerts.length})
                                            </h3>
                                            {warningAlerts.map(alert => (
                                                <AlertCard key={alert.id} alert={alert} />
                                            ))}
                                        </div>
                                    )}

                                    {/* Opportunity Alerts */}
                                    {opportunityAlerts.length > 0 && (
                                        <div className="mb-4">
                                            <h3 className="text-green-400 font-bold text-sm mb-2 flex items-center gap-2">
                                                üí∞ OPPORTUNITIES ({opportunityAlerts.length})
                                            </h3>
                                            {opportunityAlerts.map(alert => (
                                                <AlertCard key={alert.id} alert={alert} />
                                            ))}
                                        </div>
                                    )}

                                    {/* Info Alerts */}
                                    {infoAlerts.length > 0 && (
                                        <div className="mb-4">
                                            <h3 className="text-blue-400 font-bold text-sm mb-2 flex items-center gap-2">
                                                üìä MONITORING ({infoAlerts.length})
                                            </h3>
                                            {infoAlerts.map(alert => (
                                                <AlertCard key={alert.id} alert={alert} />
                                            ))}
                                        </div>
                                    )}
                                </>
                            )}
                        </div>

                        <div className="p-4 border-t border-gray-700 bg-gray-800/50">
                            <p className="text-xs text-gray-500 text-center">
                                üí° Alerts update when your positions change or prices update
                            </p>
                        </div>
                    </div>
                </div>
            );
        };

        // Rocket Chart Component - Candlestick chart with rocket markers and custom images
        const RocketChart = ({ ticker, signals, timeframe }) => {
            const wrapperRef = React.useRef(null);
            const chartContainerRef = React.useRef(null);
            const chartRef = React.useRef(null);
            const seriesRef = React.useRef(null);
            const [chartData, setChartData] = React.useState(null);
            const [rocketPositions, setRocketPositions] = React.useState([]);

            // Fetch chart data
            React.useEffect(() => {
                if (!ticker) return;
                const isWeekly = timeframe === 'weekly';
                const interval = isWeekly ? '1wk' : '1d';
                const range = '1y';
                fetch(`/api/yahoo?ticker=${ticker}&type=chart&range=${range}&interval=${interval}`)
                    .then(res => res.json())
                    .then(data => {
                        if (data.chart?.result?.[0]) {
                            const result = data.chart.result[0];
                            const timestamps = result.timestamp;
                            const quotes = result.indicators.quote[0];
                            const ohlc = [];
                            for (let i = 0; i < timestamps.length; i++) {
                                if (quotes.open[i] && quotes.close[i]) {
                                    ohlc.push({
                                        time: timestamps[i],
                                        open: quotes.open[i],
                                        high: quotes.high[i],
                                        low: quotes.low[i],
                                        close: quotes.close[i]
                                    });
                                }
                            }
                            setChartData(ohlc);
                        }
                    })
                    .catch(err => console.error('Chart data error:', err));
            }, [ticker, timeframe]);

            // Calculate rocket positions
            const updateRocketPositions = React.useCallback(() => {
                if (!chartRef.current || !seriesRef.current || !signals || !chartData) return;

                const chart = chartRef.current;
                const series = seriesRef.current;

                // Create date map from chartData
                const dateMap = {};
                chartData.forEach(d => {
                    const dateStr = new Date(d.time * 1000).toISOString().split('T')[0];
                    dateMap[dateStr] = d;
                });

                const positions = [];
                signals.forEach(sig => {
                    const sigDateStr = sig.dateObj.toISOString().split('T')[0];
                    const candle = dateMap[sigDateStr];
                    if (!candle) return;

                    const x = chart.timeScale().timeToCoordinate(candle.time);
                    if (x === null) return;

                    const isGreen = sig.type === 'blue' || sig.type === 'green';
                    const priceLevel = isGreen ? candle.low : candle.high;
                    const y = series.priceToCoordinate(priceLevel);
                    if (y === null) return;

                    positions.push({
                        x,
                        y,
                        isGreen,
                        date: sigDateStr
                    });
                });

                setRocketPositions(positions);
            }, [signals, chartData]);

            // Initialize chart
            React.useEffect(() => {
                if (!chartContainerRef.current || !chartData) return;

                if (chartRef.current) {
                    chartRef.current.remove();
                }

                const chart = LightweightCharts.createChart(chartContainerRef.current, {
                    width: chartContainerRef.current.clientWidth,
                    height: 300,
                    layout: {
                        background: { type: 'solid', color: '#111827' },
                        textColor: '#9ca3af'
                    },
                    grid: {
                        vertLines: { color: '#1f2937' },
                        horzLines: { color: '#1f2937' }
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal
                    },
                    rightPriceScale: {
                        borderColor: '#374151'
                    },
                    timeScale: {
                        borderColor: '#374151',
                        timeVisible: true,
                        secondsVisible: false
                    }
                });

                chartRef.current = chart;

                const candlestickSeries = chart.addCandlestickSeries({
                    upColor: '#22c55e',
                    downColor: '#ef4444',
                    borderDownColor: '#ef4444',
                    borderUpColor: '#22c55e',
                    wickDownColor: '#ef4444',
                    wickUpColor: '#22c55e'
                });

                candlestickSeries.setData(chartData);
                seriesRef.current = candlestickSeries;

                chart.timeScale().fitContent();

                // Update positions after chart is ready
                setTimeout(() => updateRocketPositions(), 200);

                // Update on scroll/zoom
                chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
                    updateRocketPositions();
                });

                const handleResize = () => {
                    if (chartContainerRef.current) {
                        chart.applyOptions({ width: chartContainerRef.current.clientWidth });
                        setTimeout(() => updateRocketPositions(), 100);
                    }
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    chart.remove();
                };
            }, [chartData, signals, updateRocketPositions]);

            return (
                <div ref={wrapperRef} style={{ position: 'relative', width: '100%', height: '300px' }}>
                    <div ref={chartContainerRef} style={{ width: '100%', height: '100%' }}>
                        {!chartData && (
                            <div className="flex items-center justify-center h-full text-gray-500">
                                Loading chart...
                            </div>
                        )}
                    </div>
                    {/* Rocket image overlays */}
                    {/* Rocket SVG overlays - transparent background */}
                    {rocketPositions.map((pos, idx) => (
                        <svg
                            key={idx}
                            viewBox="0 0 24 24"
                            className="rocket-blink"
                            style={{
                                position: 'absolute',
                                left: pos.x - 10,
                                top: pos.isGreen ? pos.y + 2 : pos.y - 22,
                                width: '20px',
                                height: '20px',
                                pointerEvents: 'none',
                                zIndex: 10,
                                transform: pos.isGreen ? 'rotate(0deg)' : 'rotate(180deg)',
                                filter: 'drop-shadow(0 0 2px rgba(0,0,0,0.5))'
                            }}
                        >
                            <path
                                d="M12 2C12 2 8 6 8 12C8 14 9 16 10 17L10 20C10 21 11 22 12 22C13 22 14 21 14 20L14 17C15 16 16 14 16 12C16 6 12 2 12 2Z"
                                fill={pos.isGreen ? '#22c55e' : '#ef4444'}
                                stroke="white"
                                strokeWidth="1.5"
                            />
                            <path
                                d="M10 17L8 19L8 21L10 20L10 17Z M14 17L16 19L16 21L14 20L14 17Z"
                                fill={pos.isGreen ? '#16a34a' : '#dc2626'}
                                stroke="white"
                                strokeWidth="1"
                            />
                            <circle cx="12" cy="9" r="2" fill={pos.isGreen ? '#86efac' : '#fca5a5'} stroke="white" strokeWidth="0.5" />
                        </svg>
                    ))}
                </div>
            );
        };

        // Market Edge Tab - Edgeful-style features
        const MarketEdgeTab = () => {
            const [activeEdgeView, setActiveEdgeView] = React.useState('rockets');
            const [gapData, setGapData] = React.useState(null);
            const [orbData, setOrbData] = React.useState({});
            const [momentumData, setMomentumData] = React.useState(null);
            const [keyLevelsData, setKeyLevelsData] = React.useState(null);
            const [rocketData, setRocketData] = React.useState(null);
            const [rocketTimeframe, setRocketTimeframe] = React.useState('daily');
            const [loading, setLoading] = React.useState(false);
            const [lastRefresh, setLastRefresh] = React.useState(null);
            const [selectedOrbTicker, setSelectedOrbTicker] = React.useState('SPY');
            const [customRocketTickers, setCustomRocketTickers] = React.useState(() => {
                const saved = localStorage.getItem('customRocketTickers');
                return saved ? JSON.parse(saved) : [];
            });
            const [newTickerInput, setNewTickerInput] = React.useState('');

            // Scalper state
            const [scalpTicker, setScalpTicker] = React.useState('SPY');
            const scalpTickerRef = React.useRef('SPY'); // Ref to avoid stale closures
            const scalpInputRef = React.useRef(null); // Direct ref to input element
            const currentChartTickerRef = React.useRef('SPY'); // Tracks what ticker is currently displayed
            const [scalpTimeframe, setScalpTimeframe] = React.useState('5m');
            const [scalpData, setScalpData] = React.useState(null);
            const [scalpSignals, setScalpSignals] = React.useState([]);
            const [scalpStats, setScalpStats] = React.useState(null);
            const [scalpLoading, setScalpLoading] = React.useState(false);
            const [scalpAlertsEnabled, setScalpAlertsEnabled] = React.useState(true);
            const [sessionMarkersEnabled, setSessionMarkersEnabled] = React.useState(true);
            // Confluence Scalper Pro v8 ‚Äì Balanced Nuclear (1-3 signals per session)
            // Level breakout/rejection is the PRIMARY trigger. No level event = no signal.
            const [useRealTime, setUseRealTime] = React.useState(false);
            const [minConfluence, setMinConfluence] = React.useState(5);
            const [showConfluenceTable, setShowConfluenceTable] = React.useState(true);
            const [showOverlays, setShowOverlays] = React.useState(true);
            const [confluenceStatus, setConfluenceStatus] = React.useState(null);
            const [showConfluenceSettings, setShowConfluenceSettings] = React.useState(false);
            const [minBarsBetween, setMinBarsBetween] = React.useState(10);
            const minBarsBetweenRef = React.useRef(10);
            const useRealTimeRef = React.useRef(false);
            const minConfluenceRef = React.useRef(5);
            const scalpEma9LineRef = React.useRef(null);
            const scalpEma21LineRef = React.useRef(null);
            const scalpEma50LineRef = React.useRef(null);
            const scalpBbUpperRef = React.useRef(null);
            const scalpBbLowerRef = React.useRef(null);
            const scalpBbBasisRef = React.useRef(null);
            const [alertWatchlist, setAlertWatchlist] = React.useState(() => {
                const saved = localStorage.getItem('scalpAlertWatchlist');
                return saved ? JSON.parse(saved) : [];
            });
            const [watchlistInput, setWatchlistInput] = React.useState('');
            const watchlistSignalsRef = React.useRef({}); // Track last signals per ticker
            const [marketCloseTime, setMarketCloseTime] = React.useState('');
            // LIVE MODE state
            const [liveTime, setLiveTime] = React.useState(new Date());
            const [signalLog, setSignalLog] = React.useState([]);
            const signalLogRef = React.useRef([]);
            const [momentumStocks, setMomentumStocks] = React.useState([]);
            const [momentumLoading, setMomentumLoading] = React.useState(false);
            const [gapperStocks, setGapperStocks] = React.useState([]);
            const [gapperLoading, setGapperLoading] = React.useState(false);

            // IV Scanner state
            const [ivData, setIvData] = React.useState(null);
            const [ivLoading, setIvLoading] = React.useState(false);
            const [ivLastScan, setIvLastScan] = React.useState(null);

            // Next Day Prediction state
            const [predictionData, setPredictionData] = React.useState(null);
            const [predictionLoading, setPredictionLoading] = React.useState(false);
            const [predictionLastScan, setPredictionLastScan] = React.useState(null);

            const scalpChartRef = React.useRef(null);
            const scalpCandleSeriesRef = React.useRef(null);
            const scalpPdhLineRef = React.useRef(null);
            const scalpPdlLineRef = React.useRef(null);
            const scalpPmhLineRef = React.useRef(null);
            const scalpPmlLineRef = React.useRef(null);
            const scalpIsFirstRender = React.useRef(true);
            const lastScalpSignalsRef = React.useRef([]);
            const scalpChartInstanceRef = React.useRef(null);
            const sessionLinesRef = React.useRef([]);

            const ORB_TICKERS = ['SPY', 'QQQ', 'IWM', 'AAPL', 'NVDA', 'TSLA', 'AMD', 'META'];
            const DEFAULT_ROCKET_TICKERS = ['SPY', 'QQQ', 'AAPL', 'NVDA', 'TSLA', 'AMD', 'META', 'MSFT', 'GOOGL', 'AMZN', 'NFLX', 'CRM', 'COIN', 'MARA', 'RIOT', 'PLTR', 'SOFI', 'NIO', 'RIVN', 'LCID', 'HIMS', 'ZETA', 'LPTH', 'OSS'];

            // Combine default + custom tickers (remove duplicates)
            const ROCKET_SCAN_TICKERS = [...new Set([...customRocketTickers, ...DEFAULT_ROCKET_TICKERS])];

            // Add custom ticker and auto-rescan
            const addCustomTicker = async (ticker) => {
                const formatted = ticker.toUpperCase().trim();
                if (formatted && !customRocketTickers.includes(formatted) && !DEFAULT_ROCKET_TICKERS.includes(formatted)) {
                    const updated = [formatted, ...customRocketTickers];
                    setCustomRocketTickers(updated);
                    localStorage.setItem('customRocketTickers', JSON.stringify(updated));
                    setRocketData(null); // Reset to force rescan
                    // Auto-rescan after adding ticker
                    setTimeout(() => fetchRockets(), 100);
                }
                setNewTickerInput('');
            };

            // Remove custom ticker
            const removeCustomTicker = (ticker) => {
                const updated = customRocketTickers.filter(t => t !== ticker);
                setCustomRocketTickers(updated);
                localStorage.setItem('customRocketTickers', JSON.stringify(updated));
            };

            // Backtest state
            const [backtestResults, setBacktestResults] = React.useState(null);
            const [backtestLoading, setBacktestLoading] = React.useState(false);
            const [showBacktest, setShowBacktest] = React.useState(false);

            // Chart view state
            const [selectedChartTicker, setSelectedChartTicker] = React.useState(null);
            const [chartSignalHistory, setChartSignalHistory] = React.useState(null);

            // Backtest Rocket Scanner
            const runBacktest = async (ticker = 'SPY') => {
                setBacktestLoading(true);
                setShowBacktest(true);
                try {
                    // Fetch 1 year of daily data (through server proxy)
                    const response = await fetch(`/api/yahoo?ticker=${ticker}&type=chart&range=1y&interval=1d`);
                    const data = await response.json();

                    if (!data.chart?.result?.[0]) {
                        setBacktestResults({ error: 'Failed to fetch data' });
                        setBacktestLoading(false);
                        return;
                    }

                    const result = data.chart.result[0];
                    const timestamps = result.timestamp;
                    const quotes = result.indicators.quote[0];
                    const closes = quotes.close;
                    const volumes = quotes.volume;
                    const highs = quotes.high;
                    const lows = quotes.low;

                    const signals = [];

                    // Loop through each day (starting from day 50 to have enough history)
                    for (let i = 50; i < closes.length - 10; i++) {
                        if (!closes[i] || !volumes[i]) continue;

                        const currentPrice = closes[i];
                        const prevClose = closes[i - 1];
                        const currentVolume = volumes[i];

                        // Calculate indicators for this day
                        const bullishSignals = [];
                        const bearishSignals = [];

                        // 1. Volume Surge
                        const avgVolume = volumes.slice(i - 20, i).filter(v => v).reduce((a, b) => a + b, 0) / 20;
                        const volumeRatio = currentVolume / avgVolume;
                        if (volumeRatio > 2) {
                            if (currentPrice > prevClose) bullishSignals.push('Volume Surge');
                            else bearishSignals.push('Volume Surge');
                        }

                        // 2. RSI
                        const rsiCloses = closes.slice(i - 14, i + 1).filter(c => c);
                        let gains = 0, losses = 0;
                        for (let j = 1; j < rsiCloses.length; j++) {
                            const change = rsiCloses[j] - rsiCloses[j - 1];
                            if (change > 0) gains += change;
                            else losses -= change;
                        }
                        const rs = losses === 0 ? 100 : (gains / 14) / (losses / 14);
                        const rsi = 100 - (100 / (1 + rs));
                        if (rsi < 30) bullishSignals.push('RSI Oversold');
                        if (rsi > 70) bearishSignals.push('RSI Overbought');

                        // 3. SMA Bounces
                        const sma20 = closes.slice(i - 20, i).filter(c => c).reduce((a, b) => a + b, 0) / 20;
                        const sma50 = closes.slice(i - 50, i).filter(c => c).reduce((a, b) => a + b, 0) / 50;
                        const distTo20 = ((currentPrice - sma20) / sma20) * 100;
                        const distTo50 = ((currentPrice - sma50) / sma50) * 100;

                        if (distTo20 > 0 && distTo20 < 2 && currentPrice > prevClose) bullishSignals.push('SMA20 Bounce');
                        if (distTo50 > 0 && distTo50 < 3 && currentPrice > prevClose) bullishSignals.push('SMA50 Bounce');

                        // 4. Golden/Death Cross
                        if (sma20 > sma50 && (sma20 - sma50) / sma50 * 100 < 1) bullishSignals.push('Golden Cross');
                        if (sma20 < sma50 && (sma50 - sma20) / sma50 * 100 < 1) bearishSignals.push('Death Cross');

                        // 5. Gap
                        const gapPercent = ((currentPrice - prevClose) / prevClose) * 100;
                        if (gapPercent > 2) bullishSignals.push('Gap Up');
                        if (gapPercent < -2) bearishSignals.push('Gap Down');

                        // 6. Momentum
                        const price5DaysAgo = closes[i - 5];
                        if (price5DaysAgo) {
                            const momentum5D = ((currentPrice - price5DaysAgo) / price5DaysAgo) * 100;
                            if (momentum5D > 5) bullishSignals.push('Strong Momentum');
                            if (momentum5D < -5) bearishSignals.push('Weak Momentum');
                        }

                        // Determine if rocket signal
                        const bullScore = bullishSignals.length;
                        const bearScore = bearishSignals.length;

                        if (bullScore >= 3 || bearScore >= 3) {
                            const signalType = bullScore >= 3 ? 'blue' : 'red';
                            const signalDate = new Date(timestamps[i] * 1000);

                            // Calculate future returns
                            const price1D = closes[i + 1];
                            const price5D = closes[i + 5];
                            const price10D = closes[i + 10];

                            const return1D = price1D ? ((price1D - currentPrice) / currentPrice) * 100 : null;
                            const return5D = price5D ? ((price5D - currentPrice) / currentPrice) * 100 : null;
                            const return10D = price10D ? ((price10D - currentPrice) / currentPrice) * 100 : null;

                            // For blue rockets, positive return = win. For red rockets, negative return = win
                            const win1D = signalType === 'blue' ? return1D > 0 : return1D < 0;
                            const win5D = signalType === 'blue' ? return5D > 0 : return5D < 0;
                            const win10D = signalType === 'blue' ? return10D > 0 : return10D < 0;

                            signals.push({
                                date: signalDate.toLocaleDateString(),
                                type: signalType,
                                price: currentPrice,
                                signals: signalType === 'blue' ? bullishSignals : bearishSignals,
                                signalCount: Math.max(bullScore, bearScore),
                                return1D,
                                return5D,
                                return10D,
                                win1D,
                                win5D,
                                win10D
                            });
                        }
                    }

                    // Calculate aggregate stats
                    const blueSignals = signals.filter(s => s.type === 'blue');
                    const redSignals = signals.filter(s => s.type === 'red');

                    const calcStats = (arr, returnKey, winKey) => {
                        const valid = arr.filter(s => s[returnKey] !== null);
                        if (valid.length === 0) return { winRate: 0, avgReturn: 0, count: 0 };
                        const wins = valid.filter(s => s[winKey]).length;
                        const avgReturn = valid.reduce((sum, s) => sum + s[returnKey], 0) / valid.length;
                        return {
                            winRate: (wins / valid.length) * 100,
                            avgReturn,
                            count: valid.length
                        };
                    };

                    const results = {
                        ticker,
                        totalSignals: signals.length,
                        blueCount: blueSignals.length,
                        redCount: redSignals.length,
                        blue: {
                            day1: calcStats(blueSignals, 'return1D', 'win1D'),
                            day5: calcStats(blueSignals, 'return5D', 'win5D'),
                            day10: calcStats(blueSignals, 'return10D', 'win10D')
                        },
                        red: {
                            day1: calcStats(redSignals, 'return1D', 'win1D'),
                            day5: calcStats(redSignals, 'return5D', 'win5D'),
                            day10: calcStats(redSignals, 'return10D', 'win10D')
                        },
                        recentSignals: signals.slice(-10).reverse()
                    };

                    setBacktestResults(results);
                } catch (err) {
                    console.error('Backtest error:', err);
                    setBacktestResults({ error: err.message });
                }
                setBacktestLoading(false);
            };

            // Open chart view with TradingView widget and signal history
            const openChartView = async (ticker) => {
                setSelectedChartTicker(ticker);
                setChartSignalHistory(null);

                const isWeekly = rocketTimeframe === 'weekly';
                const interval = isWeekly ? '1wk' : '1d';
                const range = '1y';
                const periodLabel = isWeekly ? 'week' : 'day';

                // Timeframe-specific thresholds
                const VOL_THRESHOLD = isWeekly ? 1.5 : 3;
                const BIG_MOVE_THRESHOLD = isWeekly ? 5 : 5;
                const MOMENTUM_THRESHOLD = isWeekly ? 15 : 15;
                const MOMENTUM_LOOKBACK = isWeekly ? 4 : 5;
                const SMA_FAST = isWeekly ? 10 : 20;
                const SMA_SLOW = isWeekly ? 20 : 50;
                const startIndex = isWeekly ? 20 : 50;

                // Fetch signal history for this ticker (through server proxy)
                try {
                    const response = await fetch(`/api/yahoo?ticker=${ticker}&type=chart&range=${range}&interval=${interval}`);
                    const data = await response.json();

                    if (data.chart?.result?.[0]) {
                        const result = data.chart.result[0];
                        const timestamps = result.timestamp;
                        const quotes = result.indicators.quote[0];
                        const closes = quotes.close;
                        const volumes = quotes.volume;
                        const highs = quotes.high;

                        const signals = [];

                        // EVENT-BASED signals - only fire on the period of the event
                        for (let i = startIndex; i < closes.length; i++) {
                            if (!closes[i] || !volumes[i]) continue;

                            const currentPrice = closes[i];
                            const prevClose = closes[i - 1];
                            const periodChange = ((currentPrice - prevClose) / prevClose) * 100;

                            const bullishSignals = [];
                            const bearishSignals = [];

                            // STRICT DETECTION - Matches Indicator Suite

                            // 1. HIGH VOLUME
                            const volLookback = isWeekly ? 10 : 20;
                            const volSlice = volumes.slice(i - volLookback, i).filter(v => v);
                            const avgVol = volSlice.reduce((a, b) => a + b, 0) / volSlice.length;
                            const volRatio = volumes[i] / avgVol;
                            if (volRatio >= VOL_THRESHOLD) {
                                if (periodChange > 3) bullishSignals.push('Vol' + volRatio.toFixed(1) + 'x');
                                else if (periodChange < -3) bearishSignals.push('Vol' + volRatio.toFixed(1) + 'x');
                            }

                            // 2. RSI EXTREME - <30 or >70 with direction
                            const rsiCloses = closes.slice(i - 14, i + 1).filter(c => c);
                            let gains = 0, losses = 0;
                            for (let j = 1; j < rsiCloses.length; j++) {
                                const change = rsiCloses[j] - rsiCloses[j - 1];
                                if (change > 0) gains += change;
                                else losses -= change;
                            }
                            const rsi = 100 - (100 / (1 + (gains / 14) / ((losses / 14) || 0.001)));
                            if (rsi < 30 && periodChange > 2) bullishSignals.push('RSI');
                            if (rsi > 70 && periodChange < -2) bearishSignals.push('RSI');

                            // 3. GOLDEN/DEATH CROSS
                            const smaFastVal = closes.slice(i - SMA_FAST, i).filter(c => c).reduce((a, b) => a + b, 0) / SMA_FAST;
                            const smaSlowVal = closes.slice(i - SMA_SLOW, i).filter(c => c).reduce((a, b) => a + b, 0) / SMA_SLOW;
                            const prevSmaFast = closes.slice(i - SMA_FAST - 1, i - 1).filter(c => c).reduce((a, b) => a + b, 0) / SMA_FAST;
                            const prevSmaSlow = closes.slice(i - SMA_SLOW - 1, i - 1).filter(c => c).reduce((a, b) => a + b, 0) / SMA_SLOW;

                            let hasGolden = false, hasDeath = false;
                            if (smaFastVal > smaSlowVal && prevSmaFast <= prevSmaSlow) {
                                bullishSignals.push('Golden');
                                hasGolden = true;
                            }
                            if (smaFastVal < smaSlowVal && prevSmaFast >= prevSmaSlow) {
                                bearishSignals.push('Death');
                                hasDeath = true;
                            }

                            // 4. BIG MOVE
                            if (periodChange >= BIG_MOVE_THRESHOLD) bullishSignals.push('+' + periodChange.toFixed(0) + '%');
                            if (periodChange <= -BIG_MOVE_THRESHOLD) bearishSignals.push(periodChange.toFixed(0) + '%');

                            // 5. STRONG MOMENTUM
                            const priceAgo = closes[i - MOMENTUM_LOOKBACK];
                            if (priceAgo) {
                                const momentum = ((currentPrice - priceAgo) / priceAgo) * 100;
                                if (momentum >= MOMENTUM_THRESHOLD) bullishSignals.push('Momentum');
                                if (momentum <= -MOMENTUM_THRESHOLD) bearishSignals.push('Momentum');
                            }

                            // 6. BREAKOUT - period high with 2x vol and 3%+ move
                            const lookbackPeriod = isWeekly ? 20 : 50;
                            const recentHigh = Math.max(...highs.slice(Math.max(0, i - lookbackPeriod), i).filter(h => h));
                            if (currentPrice > recentHigh && volRatio >= 2 && periodChange >= 3) {
                                bullishSignals.push('Breakout');
                            }

                            // 7. BREAKDOWN - period low with 2x vol
                            const lows = quotes.low;
                            const recentLow = Math.min(...lows.slice(Math.max(0, i - lookbackPeriod), i).filter(l => l));
                            if (currentPrice < recentLow && volRatio >= 2 && periodChange <= -3) {
                                bearishSignals.push('Breakdown');
                            }

                            // 8. REJECTION - High-to-Close drop
                            const periodHigh = highs[i];
                            const rejectPct = periodHigh ? ((currentPrice - periodHigh) / periodHigh) * 100 : 0;
                            if (rejectPct <= -10) {
                                bearishSignals.push('Reject' + rejectPct.toFixed(0) + '%');
                            }

                            // 9. RECLAIM - Low-to-Close rise
                            const periodLow = lows[i];
                            const reclaimPct = periodLow ? ((currentPrice - periodLow) / periodLow) * 100 : 0;
                            if (reclaimPct >= 10) {
                                bullishSignals.push('Reclaim+' + reclaimPct.toFixed(0) + '%');
                            }

                            const bullScore = bullishSignals.length;
                            const bearScore = bearishSignals.length;

                            // Check for mega/super rejection/reclaim
                            const hasMegaReject = rejectPct <= -18;
                            const hasMegaReclaim = reclaimPct >= 18;
                            const hasSuperReject = rejectPct <= -12 && rejectPct > -18;
                            const hasSuperReclaim = reclaimPct >= 12 && reclaimPct < 18;

                            // ROCKET REQUIREMENTS - Matches Indicator Suite:
                            // - Golden/Death Cross + 1 other signal = ROCKET
                            // - Mega Rejection/Reclaim = ROCKET by itself
                            // - Super Rejection/Reclaim + 1 signal = ROCKET
                            // - OR 3+ regular signals = ROCKET
                            const isGoldenRocket = hasGolden && bullScore >= 2;
                            const isDeathRocket = hasDeath && bearScore >= 2;
                            const isMegaReclaimRocket = hasMegaReclaim;
                            const isMegaRejectRocket = hasMegaReject;
                            const isSuperReclaimRocket = hasSuperReclaim && bullScore >= 2;
                            const isSuperRejectRocket = hasSuperReject && bearScore >= 2;
                            const isRegularBullRocket = bullScore >= 3;
                            const isRegularBearRocket = bearScore >= 3;

                            const isBullRocket = isGoldenRocket || isMegaReclaimRocket || isSuperReclaimRocket || isRegularBullRocket;
                            const isBearRocket = isDeathRocket || isMegaRejectRocket || isSuperRejectRocket || isRegularBearRocket;

                            if (isBullRocket || isBearRocket) {
                                const date = new Date(timestamps[i] * 1000);

                                // Cooldown: skip if we had a rocket recently (10 days or 3 weeks)
                                const cooldownPeriods = isWeekly ? 3 : 10;
                                const lastRocket = signals[signals.length - 1];
                                const periodsSinceLast = lastRocket ?
                                    (timestamps[i] - Math.floor(lastRocket.dateObj.getTime() / 1000)) / 86400 / (isWeekly ? 7 : 1) : 999;

                                if (periodsSinceLast >= cooldownPeriods) {
                                    const type = isBullRocket ? 'blue' : 'red';
                                    const sigs = isBullRocket ? bullishSignals : bearishSignals;

                                    signals.push({
                                        date: date.toLocaleDateString(),
                                        dateObj: date,
                                        type: type,
                                        price: currentPrice,
                                        signals: sigs,
                                        change: periodChange
                                    });
                                }
                            }
                        }

                        setChartSignalHistory(signals);
                    }
                } catch (err) {
                    console.error('Error fetching signal history:', err);
                }
            };

            // Fetch gap data
            const fetchGaps = async () => {
                setLoading(true);
                try {
                    const response = await fetch('/api/gap-scanner?minGap=0.5');
                    const data = await response.json();
                    setGapData(data);
                    setLastRefresh(new Date());
                } catch (err) {
                    console.error('Gap fetch error:', err);
                }
                setLoading(false);
            };

            // Fetch ORB/IB levels for a ticker
            const fetchOrb = async (ticker) => {
                try {
                    const response = await fetch(`/api/orb-levels?ticker=${ticker}`);
                    const data = await response.json();
                    setOrbData(prev => ({ ...prev, [ticker]: data }));
                } catch (err) {
                    console.error('ORB fetch error:', err);
                }
            };

            // Fetch momentum
            const fetchMomentum = async () => {
                setLoading(true);
                try {
                    const response = await fetch('/api/momentum-scanner?minMove=2');
                    const data = await response.json();
                    setMomentumData(data);
                    setLastRefresh(new Date());
                } catch (err) {
                    console.error('Momentum fetch error:', err);
                }
                setLoading(false);
            };

            // Fetch key levels
            const fetchKeyLevels = async () => {
                setLoading(true);
                try {
                    const response = await fetch('/api/key-levels?tickers=SPY,QQQ,IWM,AAPL,NVDA,TSLA');
                    const data = await response.json();
                    setKeyLevelsData(data);
                    setLastRefresh(new Date());
                } catch (err) {
                    console.error('Key levels fetch error:', err);
                }
                setLoading(false);
            };

            // ============================================
            // SCALPER - 5-Minute Day Trade Signal Scanner
            // ============================================

            // Calculate EMA
            const calcEMA = (prices, period) => {
                const k = 2 / (period + 1);
                const ema = [prices[0]];
                for (let i = 1; i < prices.length; i++) {
                    ema.push(prices[i] * k + ema[i - 1] * (1 - k));
                }
                return ema;
            };

            // Calculate RSI
            const calcRSI = (closes, period = 14) => {
                const rsi = new Array(closes.length).fill(50);
                for (let i = period; i < closes.length; i++) {
                    let gains = 0, losses = 0;
                    for (let j = i - period + 1; j <= i; j++) {
                        const change = closes[j] - closes[j - 1];
                        if (change > 0) gains += change;
                        else losses -= change;
                    }
                    const rs = losses === 0 ? 100 : gains / losses;
                    rsi[i] = 100 - (100 / (1 + rs));
                }
                return rsi;
            };

            // Calculate VWAP (resets each day)
            const calcVWAP = (candles) => {
                const vwap = [];
                let cumVolume = 0, cumTPV = 0, lastDay = null;

                for (let i = 0; i < candles.length; i++) {
                    const c = candles[i];
                    const day = new Date(c.time * 1000).toDateString();
                    if (day !== lastDay) {
                        cumVolume = 0;
                        cumTPV = 0;
                        lastDay = day;
                    }
                    const tp = (c.high + c.low + c.close) / 3;
                    cumTPV += tp * c.volume;
                    cumVolume += c.volume;
                    vwap.push(cumVolume > 0 ? cumTPV / cumVolume : c.close);
                }
                return vwap;
            };

            // Calculate MACD
            const calcMACD = (closes) => {
                const ema12 = calcEMA(closes, 12);
                const ema26 = calcEMA(closes, 26);
                const macd = ema12.map((v, i) => v - ema26[i]);
                const signal = calcEMA(macd, 9);
                const histogram = macd.map((v, i) => v - signal[i]);
                return { macd, signal, histogram };
            };

            // Calculate key levels (PDH, PDL, PMH, PML)
            const calcKeyLevels = (candles) => {
                const days = {};
                candles.forEach(c => {
                    const date = new Date(c.time * 1000);
                    const dayKey = date.toDateString();
                    const hour = date.getHours();
                    const minute = date.getMinutes();
                    const isPremarket = hour < 9 || (hour === 9 && minute < 30);
                    const isRegular = (hour > 9 || (hour === 9 && minute >= 30)) && hour < 16;

                    if (!days[dayKey]) days[dayKey] = { regular: [], premarket: [] };
                    if (isPremarket) days[dayKey].premarket.push(c);
                    else if (isRegular) days[dayKey].regular.push(c);
                });

                const dayKeys = Object.keys(days).sort((a, b) => new Date(a) - new Date(b));
                const today = dayKeys[dayKeys.length - 1];
                const yesterday = dayKeys.length > 1 ? dayKeys[dayKeys.length - 2] : null;

                const levels = {};
                if (yesterday && days[yesterday].regular.length > 0) {
                    levels.PDH = Math.max(...days[yesterday].regular.map(c => c.high));
                    levels.PDL = Math.min(...days[yesterday].regular.map(c => c.low));
                }
                if (today && days[today].premarket.length > 0) {
                    levels.PMH = Math.max(...days[today].premarket.map(c => c.high));
                    levels.PML = Math.min(...days[today].premarket.map(c => c.low));
                }
                return levels;
            };

            // Detect scalp signals - MAJOR swing point reversals matching IMG_2066 pattern
            // REAL-TIME SWING DETECTOR - Left side only, no lookahead delay
            const detectScalpSignals = (candles, vwap, ema9, ema21, ema50, rsi, macdData, levels, timeframe = '5m') => {
                // PURE v7: Swing detection with lookahead. No extra filters.
                // + TIMING VERIFICATION: logs candle time vs generation time for each signal
                const signals = [];
                const avgVolumes = [];
                const genTime = Date.now();

                const settings = {
                    '1m': { swingLookback: 6, cooldown: 6, swingDepth: 0.004, volumeMult: 1.2, zonePct: 0.50 },
                    '5m': { swingLookback: 12, cooldown: 12, swingDepth: 0.008, volumeMult: 1.3, zonePct: 0.55 },
                    '15m': { swingLookback: 8, cooldown: 8, swingDepth: 0.012, volumeMult: 1.5, zonePct: 0.60 }
                };
                const cfg = settings[timeframe] || settings['5m'];

                for (let i = 0; i < candles.length; i++) {
                    if (i < 20) {
                        avgVolumes.push(candles.slice(0, i + 1).reduce((s, c) => s + c.volume, 0) / (i + 1));
                    } else {
                        avgVolumes.push(candles.slice(i - 20, i).reduce((s, c) => s + c.volume, 0) / 20);
                    }
                }

                const hasBottomWick = (c) => {
                    const body = Math.abs(c.close - c.open);
                    const lowerWick = Math.min(c.open, c.close) - c.low;
                    return lowerWick > body * 0.4;
                };
                const hasTopWick = (c) => {
                    const body = Math.abs(c.close - c.open);
                    const upperWick = c.high - Math.max(c.open, c.close);
                    return upperWick > body * 0.4;
                };
                const nearLevel = (price, level, tolerance = 0.003) => {
                    if (!level) return false;
                    return Math.abs(price - level) / level < tolerance;
                };

                let lastLongIdx = -cfg.cooldown * 2;
                let lastShortIdx = -cfg.cooldown * 2;
                let lastShortHigh = 0;
                const lookback = cfg.swingLookback;

                for (let i = lookback + 8; i < candles.length; i++) {
                    const c = candles[i];
                    const prev = candles[i - 1];
                    const hasVolume = c.volume > avgVolumes[i] * cfg.volumeMult;

                    // Swing detection: left always, right when available (real-time for recent bars)
                    const leftBars = candles.slice(i - lookback, i);
                    const rightBars = candles.slice(i + 1, Math.min(i + lookback + 1, candles.length));
                    const leftMaxHigh = Math.max(...leftBars.map(x => x.high));
                    const leftMinLow = Math.min(...leftBars.map(x => x.low));

                    // Right side: use if available, otherwise left-only (real-time mode)
                    const hasRightBars = rightBars.length > 0;
                    const rightMaxHigh = hasRightBars ? Math.max(...rightBars.map(x => x.high)) : -Infinity;
                    const rightMinLow = hasRightBars ? Math.min(...rightBars.map(x => x.low)) : Infinity;

                    const isSwingHigh = c.high >= leftMaxHigh && (hasRightBars ? c.high >= rightMaxHigh : true);
                    const isSwingLow = c.low <= leftMinLow && (hasRightBars ? c.low <= rightMinLow : true);

                    // Intraday zone
                    const candleDate = new Date(c.time * 1000).toDateString();
                    const todayCandles = candles.filter(x => new Date(x.time * 1000).toDateString() === candleDate);
                    const intradayHigh = Math.max(...todayCandles.map(x => x.high));
                    const intradayLow = Math.min(...todayCandles.map(x => x.low));
                    const intradayRange = intradayHigh - intradayLow;
                    const pricePosition = intradayRange > 0 ? (c.close - intradayLow) / intradayRange : 0.5;

                    const isGreen = c.close > c.open;
                    const isRed = c.close < c.open;
                    const atPDL = nearLevel(c.low, levels.PDL);
                    const atPMH = nearLevel(c.high, levels.PMH);

                    // ==========================================
                    // LONG: swing low + pattern + cooldown + (depth OR support)
                    // ==========================================
                    const longCooldownOk = (i - lastLongIdx) >= cfg.cooldown;
                    const nextCandle = candles[i + 1];
                    const nextIsGreen = nextCandle && nextCandle.close > nextCandle.open;
                    const strongHammer = hasBottomWick(c) && (c.low <= leftMinLow * 1.001);
                    const longPattern = isGreen || nextIsGreen || strongHammer;

                    const recentHigh = Math.max(...candles.slice(Math.max(0, i - 20), i).map(x => x.high));
                    const swingDepth = (recentHigh - c.low) / recentHigh;
                    const isSignificantDepth = swingDepth > cfg.swingDepth;
                    const atSupportLevel = nearLevel(c.low, levels.PDL, 0.0015) ||
                                           nearLevel(c.low, levels.PDH, 0.0015) ||
                                           nearLevel(c.low, levels.PML, 0.0015);

                    if (isSwingLow && longPattern && longCooldownOk && (isSignificantDepth || atSupportLevel)) {
                        const reasons = ['SwingLow'];
                        if (atPDL) reasons.push('PDL');
                        if (hasBottomWick(c)) reasons.push('Wick');
                        if (hasVolume) reasons.push('Vol');
                        if (nextIsGreen && !isGreen) reasons.push('NextGreen');

                        // Timing: is this the last candle in the scannable range?
                        const fullRight = rightBars.length >= lookback;
                        const mode = fullRight ? 'LA' : 'RT';
                        const candleTimeMs = c.time * 1000;
                        const delayMs = genTime - candleTimeMs;

                        signals.push({
                            type: 'long', time: c.time, price: c.close, low: c.low,
                            reasons, strength: reasons.length, mode, delayMs, candleTimeMs, genTime
                        });
                        lastLongIdx = i;
                        console.log(`SIGNAL TIMING CHECK: long @ ${c.close.toFixed(2)} | Candle time: ${new Date(candleTimeMs).toISOString()} | Generated at: ${new Date(genTime).toISOString()} | Delay: ${delayMs}ms | Mode: ${mode} | ${reasons.join(',')}`);
                    }

                    // ==========================================
                    // SHORT: swing high + pattern + cooldown + topZone + (height OR resistance)
                    // ==========================================
                    const shortCooldownOk = (i - lastShortIdx) >= cfg.cooldown;
                    const hasRejectionWick = hasTopWick(c);
                    const shortPattern = isRed || hasRejectionWick;
                    const inTopZone = pricePosition > cfg.zonePct;

                    const recentLow = Math.min(...candles.slice(Math.max(0, i - 20), i).map(x => x.low));
                    const swingHeight = (c.high - recentLow) / recentLow;
                    const isSignificantHeight = swingHeight > cfg.swingDepth;
                    const atResistanceLevel = nearLevel(c.high, levels.PDH, 0.0015) ||
                                              nearLevel(c.high, levels.PMH, 0.0015);

                    if (isSwingHigh && shortPattern && shortCooldownOk && inTopZone && (isSignificantHeight || atResistanceLevel)) {
                        const reasons = ['SwingHigh'];
                        if (atPMH) reasons.push('PMH');
                        if (hasTopWick(c)) reasons.push('Wick');
                        if (hasVolume) reasons.push('Vol');

                        const fullRight = rightBars.length >= lookback;
                        const mode = fullRight ? 'LA' : 'RT';
                        const candleTimeMs = c.time * 1000;
                        const delayMs = genTime - candleTimeMs;

                        signals.push({
                            type: 'short', time: c.time, price: c.close, high: c.high,
                            reasons, strength: reasons.length, mode, delayMs, candleTimeMs, genTime
                        });
                        lastShortIdx = i;
                        lastShortHigh = c.high;
                        console.log(`SIGNAL TIMING CHECK: short @ ${c.close.toFixed(2)} | Candle time: ${new Date(candleTimeMs).toISOString()} | Generated at: ${new Date(genTime).toISOString()} | Delay: ${delayMs}ms | Mode: ${mode} | ${reasons.join(',')}`);
                    }
                }

                console.log(`[v7+timing] Total: ${signals.length} (${signals.filter(s=>s.type==='long').length} buys, ${signals.filter(s=>s.type==='short').length} sells)`);
                return signals;
            };

            // CONFLUENCE SCALPER PRO v7 ‚Äì NUCLEAR STRICT
            // Level breakout/rejection is the PRIMARY trigger. No level event = no signal.
            // Hard gates ALWAYS on: volSpike + ADX>25 + MTF. Stacked EMAs mandatory.
            // All conditions EVENT-based. 30-bar cooldown. minConf=7. Debug logging.
            const detectConfluenceSignals = (candles, vwap, ema9, ema21, ema50, rsi, macdData, levels, timeframe = '5m', rtMode = false, minConf = 5, cooldown = 10) => {
                // v13: SCORE-ONLY approach. No hard AND-gates except level + cooldown.
                // Every condition contributes to score. Score >= threshold = signal.
                // This avoids the v7-v12 trap of one missing gate killing everything.
                if (candles.length < 50) return { signals: [], lastBarStatus: null };

                const signals = [];
                let lastSignalBar = -500;
                const maxScore = 8;

                const calcBB = (idx, len = 20, mult = 2) => {
                    if (idx < len) return { upper: null, lower: null, basis: null };
                    const slice = candles.slice(idx - len + 1, idx + 1).map(c => c.close);
                    const basis = slice.reduce((a, b) => a + b, 0) / len;
                    const std = Math.sqrt(slice.reduce((sum, val) => sum + Math.pow(val - basis, 2), 0) / len);
                    return { upper: basis + mult * std, lower: basis - mult * std, basis };
                };

                const calcATR = (idx, len = 14) => {
                    if (idx < len + 1) return null;
                    let sum = 0;
                    for (let j = idx - len; j < idx; j++) {
                        const h = candles[j].high, l = candles[j].low;
                        const pc = candles[j - 1]?.close || candles[j].open;
                        sum += Math.max(h - l, Math.abs(h - pc), Math.abs(l - pc));
                    }
                    return sum / len;
                };

                const calcADX = (idx, len = 14) => {
                    if (idx < len * 2) return 0;
                    let plusDM = 0, minusDM = 0, tr = 0;
                    for (let j = idx - len; j < idx; j++) {
                        const h = candles[j].high, l = candles[j].low;
                        const ph = candles[j - 1]?.high || h, pl = candles[j - 1]?.low || l;
                        const pc = candles[j - 1]?.close || candles[j].open;
                        const up = h - ph, down = pl - l;
                        if (up > down && up > 0) plusDM += up;
                        if (down > up && down > 0) minusDM += down;
                        tr += Math.max(h - l, Math.abs(h - pc), Math.abs(l - pc));
                    }
                    if (tr === 0) return 0;
                    const pDI = (plusDM / tr) * 100, mDI = (minusDM / tr) * 100;
                    return Math.abs(pDI - mDI) / (pDI + mDI + 0.001) * 100;
                };

                const getHTF = (idx) => {
                    const htfLen = timeframe === '1m' ? 15 : timeframe === '5m' ? 15 : 8;
                    if (idx < htfLen + 1) return { bullish: false, bearish: false };
                    const htfCandles = candles.slice(idx - htfLen - 1, idx - 1);
                    if (htfCandles.length < 2) return { bullish: false, bearish: false };
                    const htfCloses = htfCandles.map(c => c.close);
                    const htfEma = htfCloses.reduce((a, b) => a + b, 0) / htfCloses.length;
                    const htfClose = htfCandles[htfCandles.length - 1].close;
                    const firstHalf = htfCandles.slice(0, Math.floor(htfCandles.length / 2));
                    const secondHalf = htfCandles.slice(Math.floor(htfCandles.length / 2));
                    const firstAvg = firstHalf.reduce((s, c) => s + c.close, 0) / firstHalf.length;
                    const secondAvg = secondHalf.reduce((s, c) => s + c.close, 0) / secondHalf.length;
                    return {
                        bullish: htfClose > htfEma && secondAvg > firstAvg,
                        bearish: htfClose < htfEma && secondAvg < firstAvg
                    };
                };

                let prevBullCondition = false;
                let prevBearCondition = false;
                let lastBarStatus = null;

                const hasLevels = levels && (levels.PDH || levels.PDL || levels.PMH || levels.PML);
                console.log(`[v13] Levels: PDH=${levels?.PDH?.toFixed(2)||'-'} PDL=${levels?.PDL?.toFixed(2)||'-'} PMH=${levels?.PMH?.toFixed(2)||'-'} PML=${levels?.PML?.toFixed(2)||'-'} | minConf=${minConf} cooldown=${cooldown}`);

                const scanStart = 50;
                for (let i = scanStart; i < candles.length; i++) {
                    const c = candles[i];
                    const isLastCandle = (i === candles.length - 1);
                    const prev = candles[i - 1];
                    if (!prev) continue;

                    const currRsi = rsi[i];
                    const currHist = macdData.histogram[i];
                    const currEma9 = ema9[i];
                    const currEma21 = ema21[i];
                    const currEma50 = ema50[i];
                    const bb = calcBB(i);
                    const atr = calcATR(i);
                    const adx = calcADX(i);
                    const htf = getHTF(i);
                    const price = c.close;
                    const prevPrice = prev.close;

                    if (!currRsi || currHist == null || !currEma9 || !bb.basis || !atr) {
                        prevBullCondition = false;
                        prevBearCondition = false;
                        continue;
                    }

                    const vol20 = candles.slice(Math.max(0, i - 20), i).reduce((s, x) => s + x.volume, 0) / Math.min(20, i);
                    const volRatio = c.volume / vol20;

                    // ================================================================
                    // LEVEL ‚Äì only hard gate. Simple state: above resistance or below support
                    // ================================================================
                    let bullLevel = false, bearLevel = false, levelCrossed = 'none';
                    if (hasLevels) {
                        if (levels.PDH && price > levels.PDH) { bullLevel = true; levelCrossed = 'above PDH'; }
                        else if (levels.PMH && price > levels.PMH) { bullLevel = true; levelCrossed = 'above PMH'; }
                        else if (levels.PDL && c.low <= levels.PDL * 1.003 && price > levels.PDL) { bullLevel = true; levelCrossed = 'PDL bounce'; }
                        else if (levels.PML && c.low <= levels.PML * 1.003 && price > levels.PML) { bullLevel = true; levelCrossed = 'PML bounce'; }

                        if (levels.PDL && price < levels.PDL) { bearLevel = true; levelCrossed = 'below PDL'; }
                        else if (levels.PML && price < levels.PML) { bearLevel = true; levelCrossed = 'below PML'; }
                        else if (levels.PDH && c.high >= levels.PDH * 0.998 && price < levels.PDH) { bearLevel = true; levelCrossed = 'PDH reject'; }
                        else if (levels.PMH && c.high >= levels.PMH * 0.998 && price < levels.PMH) { bearLevel = true; levelCrossed = 'PMH reject'; }
                    } else {
                        bullLevel = true; bearLevel = true; levelCrossed = 'no levels';
                    }

                    // ================================================================
                    // SCORE: 8 factors, ALL contribute, NONE required individually
                    // ================================================================
                    const bullStacked = currEma9 > currEma21 && currEma21 > currEma50;
                    const bearStacked = currEma9 < currEma21 && currEma21 < currEma50;

                    const bull_ema = currEma9 > currEma21;
                    const bull_stacked = bullStacked;
                    const bull_macd = currHist > 0;
                    const bull_rsi = currRsi > 50 && currRsi < 80;
                    const bull_bb = price < bb.basis;
                    const bull_vol = volRatio > 1.2;
                    const bull_adx = adx > 20;
                    const bull_mtf = htf.bullish;

                    const bear_ema = currEma9 < currEma21;
                    const bear_stacked = bearStacked;
                    const bear_macd = currHist < 0;
                    const bear_rsi = currRsi > 20 && currRsi < 50;
                    const bear_bb = price > bb.basis;
                    const bear_vol = volRatio > 1.2;
                    const bear_adx = adx > 20;
                    const bear_mtf = htf.bearish;

                    let bullScore = 0; const bullR = [];
                    if (bull_ema) { bullScore++; bullR.push('EMA'); }
                    if (bull_stacked) { bullScore++; bullR.push('Stack'); }
                    if (bull_macd) { bullScore++; bullR.push('MACD'); }
                    if (bull_rsi) { bullScore++; bullR.push('RSI'); }
                    if (bull_bb) { bullScore++; bullR.push('BB'); }
                    if (bull_vol) { bullScore++; bullR.push('Vol'); }
                    if (bull_adx) { bullScore++; bullR.push('ADX'); }
                    if (bull_mtf) { bullScore++; bullR.push('MTF'); }

                    let bearScore = 0; const bearR = [];
                    if (bear_ema) { bearScore++; bearR.push('EMA'); }
                    if (bear_stacked) { bearScore++; bearR.push('Stack'); }
                    if (bear_macd) { bearScore++; bearR.push('MACD'); }
                    if (bear_rsi) { bearScore++; bearR.push('RSI'); }
                    if (bear_bb) { bearScore++; bearR.push('BB'); }
                    if (bear_vol) { bearScore++; bearR.push('Vol'); }
                    if (bear_adx) { bearScore++; bearR.push('ADX'); }
                    if (bear_mtf) { bearScore++; bearR.push('MTF'); }

                    // ================================================================
                    // SIGNAL: level + score >= minConf + dominant + edge + cooldown
                    // That's it. No vol/ADX/stacked/MTF hard gates.
                    // ================================================================
                    const bullCondition = bullLevel && bullScore >= minConf && bullScore > bearScore;
                    const bearCondition = bearLevel && bearScore >= minConf && bearScore > bullScore;

                    const newBull = bullCondition && !prevBullCondition;
                    const newBear = bearCondition && !prevBearCondition;
                    const fireBull = rtMode ? newBull : (newBull && !isLastCandle);
                    const fireBear = rtMode ? newBear : (newBear && !isLastCandle);
                    const cooldownOk = (i - lastSignalBar) >= cooldown;
                    const ts = new Date(c.time * 1000).toLocaleTimeString();

                    // Debug on level bars
                    if (bullLevel || bearLevel) {
                        const dir = bullLevel ? 'BULL' : 'BEAR';
                        const score = bullLevel ? bullScore : bearScore;
                        const other = bullLevel ? bearScore : bullScore;
                        const reasons = bullLevel ? bullR : bearR;
                        const cond = bullLevel ? bullCondition : bearCondition;
                        const isNew = bullLevel ? newBull : newBear;
                        const fire = bullLevel ? fireBull : fireBear;
                        const fails = [];
                        if (score < minConf) fails.push(`score ${score}<${minConf}`);
                        if (score <= other) fails.push(`not dominant ${score}vs${other}`);
                        if (cond && !isNew) fails.push('not edge');
                        if (fire && !cooldownOk) fails.push(`cooldown ${i-lastSignalBar}/${cooldown}`);
                        if (isNew && isLastCandle && !rtMode) fails.push('last candle');

                        if (fails.length > 0) {
                            console.log(`[v13 BLOCKED] ${dir} @ ${price.toFixed(2)} | ${ts} | Lvl: ${levelCrossed} | ${score}/8 [${reasons.join(',')}] | FAIL: ${fails.join(', ')} | vol:${volRatio.toFixed(1)}x adx:${adx.toFixed(1)} rsi:${currRsi?.toFixed(0)} hist:${currHist?.toFixed(3)}`);
                        }
                        // Also log bear side if both triggered
                        if (bullLevel && bearLevel) {
                            const bFails = [];
                            if (bearScore < minConf) bFails.push(`score ${bearScore}<${minConf}`);
                            if (bearScore <= bullScore) bFails.push(`not dominant ${bearScore}vs${bullScore}`);
                            if (bearCondition && !newBear) bFails.push('not edge');
                            if (bFails.length > 0) {
                                console.log(`[v13 BLOCKED] BEAR @ ${price.toFixed(2)} | ${ts} | Lvl: ${levelCrossed} | ${bearScore}/8 [${bearR.join(',')}] | FAIL: ${bFails.join(', ')}`);
                            }
                        }
                    }

                    if (fireBull && cooldownOk) {
                        console.log(`[v13 SIGNAL] BUY @ ${price.toFixed(2)} | ${ts} | ${bullScore}/8 [${bullR.join(',')}] | Lvl: ${levelCrossed} | vol:${volRatio.toFixed(1)}x adx:${adx.toFixed(1)} rsi:${currRsi?.toFixed(0)} | SL:${(price-1.5*atr).toFixed(2)}`);
                        signals.push({
                            type: 'long', time: c.time, price, low: c.low,
                            stopLoss: price - 1.5 * atr,
                            reasons: bullR, strength: bullScore, maxStrength: maxScore,
                            levelTrigger: levelCrossed, instant: true, isNew: isLastCandle
                        });
                        lastSignalBar = i;
                    }
                    if (fireBear && cooldownOk) {
                        console.log(`[v13 SIGNAL] SELL @ ${price.toFixed(2)} | ${ts} | ${bearScore}/8 [${bearR.join(',')}] | Lvl: ${levelCrossed} | vol:${volRatio.toFixed(1)}x adx:${adx.toFixed(1)} rsi:${currRsi?.toFixed(0)} | SL:${(price+1.5*atr).toFixed(2)}`);
                        signals.push({
                            type: 'short', time: c.time, price, high: c.high,
                            stopLoss: price + 1.5 * atr,
                            reasons: bearR, strength: bearScore, maxStrength: maxScore,
                            levelTrigger: levelCrossed, instant: true, isNew: isLastCandle
                        });
                        lastSignalBar = i;
                    }

                    prevBullCondition = bullCondition;
                    prevBearCondition = bearCondition;

                    if (isLastCandle) {
                        lastBarStatus = {
                            bull: { ema: bull_ema, stacked: bull_stacked, macd: bull_macd, rsi: bull_rsi, bb: bull_bb, volume: bull_vol, adx: bull_adx, mtf: bull_mtf, level: bullLevel, gate: bull_vol && bull_adx },
                            bear: { ema: bear_ema, stacked: bear_stacked, macd: bear_macd, rsi: bear_rsi, bb: bear_bb, volume: bear_vol, adx: bear_adx, mtf: bear_mtf, level: bearLevel, gate: bear_vol && bear_adx },
                            bullScore, bearScore, maxScore,
                            levelCrossed, adxValue: adx, volSpike: bull_vol, hasLevels
                        };
                    }
                }

                console.log(`[v13] Total signals: ${signals.length}`);
                return { signals, lastBarStatus };
            };

            // Backtest scalp signals
            const backtestScalpSignals = (signals, candles) => {
                const results = signals.map(sig => {
                    const entryIdx = candles.findIndex(c => c.time === sig.time);
                    if (entryIdx === -1) return { ...sig, return5: null, return10: null };

                    const exit5 = candles[entryIdx + 5]; // ~25 min
                    const exit10 = candles[entryIdx + 10]; // ~50 min
                    const exit20 = candles[entryIdx + 20]; // ~100 min

                    const calc = (exit) => exit ? ((exit.close - sig.price) / sig.price) * 100 : null;
                    const return5 = calc(exit5);
                    const return10 = calc(exit10);
                    const return20 = calc(exit20);

                    // For longs, positive = win. For shorts, negative = win.
                    const isWin = (ret) => sig.type === 'long' ? ret > 0 : ret < 0;

                    return {
                        ...sig,
                        return5, return10, return20,
                        win5: return5 !== null ? isWin(return5) : null,
                        win10: return10 !== null ? isWin(return10) : null,
                        win20: return20 !== null ? isWin(return20) : null
                    };
                });

                // Calculate stats
                const calcWinRate = (results, key) => {
                    const valid = results.filter(r => r[key] !== null);
                    if (valid.length === 0) return { winRate: 0, avgReturn: 0, count: 0 };
                    const wins = valid.filter(r => r[key.replace('return', 'win')]).length;
                    const avgReturn = valid.reduce((s, r) => s + Math.abs(r[key]), 0) / valid.length;
                    return { winRate: (wins / valid.length) * 100, avgReturn, count: valid.length };
                };

                const longs = results.filter(r => r.type === 'long');
                const shorts = results.filter(r => r.type === 'short');

                return {
                    signals: results,
                    stats: {
                        total: results.length,
                        longs: longs.length,
                        shorts: shorts.length,
                        long5: calcWinRate(longs, 'return5'),
                        long10: calcWinRate(longs, 'return10'),
                        long20: calcWinRate(longs, 'return20'),
                        short5: calcWinRate(shorts, 'return5'),
                        short10: calcWinRate(shorts, 'return10'),
                        short20: calcWinRate(shorts, 'return20')
                    }
                };
            };

            // Fetch scalp data and analyze
            const fetchScalpData = async (ticker = scalpTicker, isRefresh = false, timeframe = null) => {
                console.log('[Scalper] fetchScalpData called:', ticker, 'isRefresh:', isRefresh);
                // Use passed timeframe or fall back to state (timeframe param avoids stale closure)
                const tf = timeframe || scalpTimeframe;

                // Only show loading and clear data on NEW scan, not on auto-refresh
                if (!isRefresh) {
                    setScalpLoading(true);
                    setScalpData(null);
                    setScalpSignals([]);
                    setScalpStats(null);
                }

                // Auto-convert common crypto symbols to Yahoo Finance format
                const cryptoMap = {
                    'BTC': 'BTC-USD', 'ETH': 'ETH-USD', 'SOL': 'SOL-USD', 'XRP': 'XRP-USD',
                    'DOGE': 'DOGE-USD', 'ADA': 'ADA-USD', 'AVAX': 'AVAX-USD', 'DOT': 'DOT-USD',
                    'MATIC': 'MATIC-USD', 'LINK': 'LINK-USD', 'UNI': 'UNI-USD', 'ATOM': 'ATOM-USD',
                    'LTC': 'LTC-USD', 'BCH': 'BCH-USD', 'NEAR': 'NEAR-USD', 'APT': 'APT-USD',
                    'ARB': 'ARB-USD', 'OP': 'OP-USD', 'FTM': 'FTM-USD', 'PEPE': 'PEPE-USD',
                    'SHIB': 'SHIB-USD', 'BONK': 'BONK-USD', 'WIF': 'WIF-USD', 'FLOKI': 'FLOKI-USD'
                };
                const yahooTicker = cryptoMap[ticker.toUpperCase()] || ticker;

                try {
                    // Determine range based on timeframe (need at least 2 days for PDH/PDL)
                    const rangeMap = { '1m': '2d', '5m': '5d', '15m': '5d', '30m': '10d', '1h': '1mo' };
                    const range = rangeMap[tf] || '5d';

                    console.log(`[Scalper] Fetching ${ticker} with interval=${tf}, range=${range}`);

                    // Fetch chart data with selected timeframe
                    const response = await fetch(`/api/yahoo?ticker=${yahooTicker}&type=chart&interval=${tf}&range=${range}`);
                    const data = await response.json();

                    if (!data.chart?.result?.[0]) {
                        console.error('No chart data');
                        setScalpLoading(false);
                        return;
                    }

                    const result = data.chart.result[0];
                    const timestamps = result.timestamp || [];
                    const quotes = result.indicators.quote[0];

                    // Format candles
                    const candles = [];
                    for (let i = 0; i < timestamps.length; i++) {
                        if (quotes.close[i] && quotes.volume[i]) {
                            candles.push({
                                time: timestamps[i],
                                open: quotes.open[i],
                                high: quotes.high[i],
                                low: quotes.low[i],
                                close: quotes.close[i],
                                volume: quotes.volume[i]
                            });
                        }
                    }

                    if (candles.length < 50) {
                        console.error('Not enough data');
                        setScalpLoading(false);
                        return;
                    }

                    // Calculate all indicators
                    const closes = candles.map(c => c.close);
                    const vwap = calcVWAP(candles);
                    const ema9 = calcEMA(closes, 9);
                    const ema21 = calcEMA(closes, 21);
                    const ema50 = calcEMA(closes, 50);
                    const rsi = calcRSI(closes, 14);
                    const macdData = calcMACD(closes);
                    const levels = calcKeyLevels(candles);

                    // v14 HYBRID: Swing detection drives arrows, confluence is table-only
                    // 1) Swing signals = chart arrows (v7 restored with lookahead)
                    const swingSignals = detectScalpSignals(candles, vwap, ema9, ema21, ema50, rsi, macdData, levels, tf);
                    console.log('[v14] Swing signals (arrows):', swingSignals.length);

                    // 2) Confluence = status table only (no arrows)
                    let confStatus = null;
                    try {
                        const confResult = detectConfluenceSignals(
                            candles, vwap, ema9, ema21, ema50, rsi, macdData, levels, tf,
                            useRealTimeRef.current, minConfluenceRef.current,
                            minBarsBetweenRef.current
                        );
                        confStatus = confResult.lastBarStatus;
                        console.log('[v14] Confluence table status updated');
                    } catch (e) {
                        console.error('[v14] Confluence table error:', e);
                    }

                    // Arrows come from swing detection ONLY
                    const allSignals = swingSignals;

                    // Calculate BB arrays for chart overlay
                    const bbData = candles.map((c, idx) => {
                        if (idx < 20) return { upper: null, lower: null, basis: null };
                        const slice = candles.slice(idx - 20, idx).map(x => x.close);
                        const basis = slice.reduce((a, b) => a + b, 0) / 20;
                        const std = Math.sqrt(slice.reduce((sum, val) => sum + Math.pow(val - basis, 2), 0) / 20);
                        return { upper: basis + 2 * std, lower: basis - 2 * std, basis };
                    });

                    // Set state
                    setScalpData({
                        candles, vwap, ema9, ema21, ema50, levels, bbData,
                        ticker: ticker.toUpperCase()
                    });
                    setScalpSignals(allSignals);
                    setScalpStats({ total: allSignals.length, realtime: useRealTimeRef.current });
                    setConfluenceStatus(confStatus);
                    setLastRefresh(new Date());
                    // Update signal log with last 5 signals (most recent first)
                    const logEntries = allSignals.slice(-5).reverse().map(s => ({
                        type: s.type, price: s.price, mode: s.mode,
                        candleTime: new Date(s.candleTimeMs).toLocaleTimeString('en-US', {hour12:false}),
                        detectionTime: new Date(s.genTime).toLocaleTimeString('en-US', {hour12:false, fractionalSecondDigits:3}),
                        delayMs: s.delayMs
                    }));
                    signalLogRef.current = logEntries;
                    setSignalLog(logEntries);

                } catch (err) {
                    console.error('Scalp fetch error:', err);
                }
                setScalpLoading(false);
            };

            // Rocket Scanner - Confluence Detection System (Zenith Lock)
            const fetchRockets = async (timeframeOverride) => {
                setLoading(true);
                const tf = timeframeOverride || rocketTimeframe;
                const isWeekly = tf === 'weekly';

                try {
                    const results = [];

                    // Timeframe-specific settings
                    const interval = isWeekly ? '1wk' : '1d';
                    const range = '1y';
                    const VOL_THRESHOLD = isWeekly ? 1.5 : 3;
                    const BIG_MOVE_THRESHOLD = isWeekly ? 5 : 5;
                    const MOMENTUM_THRESHOLD = isWeekly ? 15 : 15;
                    const MOMENTUM_LOOKBACK = isWeekly ? 4 : 5;
                    const SMA_FAST = isWeekly ? 10 : 20;
                    const SMA_SLOW = isWeekly ? 20 : 50;

                    // Fetch data for all tickers in parallel (through server proxy)
                    const promises = ROCKET_SCAN_TICKERS.map(async (ticker) => {
                        try {
                            const quoteRes = await fetch(`/api/yahoo?ticker=${ticker}&type=chart&range=${range}&interval=${interval}`);
                            const quoteData = await quoteRes.json();

                            if (!quoteData.chart?.result?.[0]) return null;

                            const result = quoteData.chart.result[0];
                            const quotes = result.indicators.quote[0];
                            const closes = quotes.close.filter(c => c != null);
                            const volumes = quotes.volume.filter(v => v != null);
                            const highs = quotes.high.filter(h => h != null);
                            const lows = quotes.low.filter(l => l != null);

                            if (closes.length < 20) return null;

                            const currentPrice = closes[closes.length - 1];
                            const prevClose = closes[closes.length - 2];
                            const currentVolume = volumes[volumes.length - 1];

                            // Calculate indicators
                            const bullishSignals = [];
                            const bearishSignals = [];

                            const timestamps = result.timestamp;
                            const periodChange = ((currentPrice - prevClose) / prevClose) * 100;
                            const periodLabel = isWeekly ? 'week' : 'day';

                            // 1. HIGH VOLUME
                            const volLookback = isWeekly ? 10 : 20;
                            const avgVolume = volumes.slice(-volLookback).reduce((a, b) => a + b, 0) / volLookback;
                            const volumeRatio = currentVolume / avgVolume;
                            if (volumeRatio >= VOL_THRESHOLD && Math.abs(periodChange) > 3) {
                                if (periodChange > 0) bullishSignals.push({ name: `Vol ${volumeRatio.toFixed(1)}x`, desc: `${volumeRatio.toFixed(1)}x avg volume` });
                                else bearishSignals.push({ name: `Vol ${volumeRatio.toFixed(1)}x`, desc: `${volumeRatio.toFixed(1)}x avg volume` });
                            }

                            // 2. RSI EXTREME - <30 or >70
                            const rsiPeriod = 14;
                            const recentCloses = closes.slice(-rsiPeriod - 1);
                            let gains = 0, losses = 0;
                            for (let i = 1; i < recentCloses.length; i++) {
                                const change = recentCloses[i] - recentCloses[i - 1];
                                if (change > 0) gains += change;
                                else losses -= change;
                            }
                            const avgGain = gains / rsiPeriod;
                            const avgLoss = losses / rsiPeriod;
                            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                            const rsi = 100 - (100 / (1 + rs));

                            if (rsi < 30 && periodChange > 2) bullishSignals.push({ name: 'RSI Oversold', desc: `RSI ${rsi.toFixed(0)} + reversal` });
                            if (rsi > 70 && periodChange < -2) bearishSignals.push({ name: 'RSI Overbought', desc: `RSI ${rsi.toFixed(0)} + reversal` });

                            // 3. GOLDEN/DEATH CROSS
                            const smaFast = closes.slice(-SMA_FAST).reduce((a, b) => a + b, 0) / SMA_FAST;
                            const smaSlow = closes.length >= SMA_SLOW ? closes.slice(-SMA_SLOW).reduce((a, b) => a + b, 0) / SMA_SLOW : null;

                            let hasGolden = false, hasDeath = false;
                            const crossLookback = isWeekly ? 3 : 5;
                            for (let d = 1; d <= crossLookback; d++) {
                                if (closes.length > SMA_SLOW + d) {
                                    const prevSmaFast = closes.slice(-SMA_FAST - d, -d).reduce((a, b) => a + b, 0) / SMA_FAST;
                                    const prevSmaSlow = closes.slice(-SMA_SLOW - d, -d).reduce((a, b) => a + b, 0) / SMA_SLOW;
                                    const currSmaFast = closes.slice(-SMA_FAST - d + 1, -d + 1 || undefined).reduce((a, b) => a + b, 0) / SMA_FAST;
                                    const currSmaSlow = closes.slice(-SMA_SLOW - d + 1, -d + 1 || undefined).reduce((a, b) => a + b, 0) / SMA_SLOW;

                                    if (currSmaFast > currSmaSlow && prevSmaFast <= prevSmaSlow) hasGolden = true;
                                    if (currSmaFast < currSmaSlow && prevSmaFast >= prevSmaSlow) hasDeath = true;
                                }
                            }

                            if (hasGolden) bullishSignals.push({ name: 'Golden Cross', desc: `${SMA_FAST}/${SMA_SLOW} SMA crossover` });
                            if (hasDeath) bearishSignals.push({ name: 'Death Cross', desc: `${SMA_FAST}/${SMA_SLOW} SMA crossover` });

                            // 4. BIG MOVE
                            if (periodChange >= BIG_MOVE_THRESHOLD) bullishSignals.push({ name: 'Big Move', desc: `+${periodChange.toFixed(1)}% this ${periodLabel}` });
                            if (periodChange <= -BIG_MOVE_THRESHOLD) bearishSignals.push({ name: 'Big Move', desc: `${periodChange.toFixed(1)}% this ${periodLabel}` });

                            // 5. STRONG MOMENTUM
                            const priceAgo = closes[closes.length - MOMENTUM_LOOKBACK - 1];
                            const momentum = priceAgo ? ((currentPrice - priceAgo) / priceAgo) * 100 : 0;
                            if (momentum >= MOMENTUM_THRESHOLD) bullishSignals.push({ name: 'Momentum', desc: `+${momentum.toFixed(0)}% in ${MOMENTUM_LOOKBACK} ${periodLabel}s` });
                            if (momentum <= -MOMENTUM_THRESHOLD) bearishSignals.push({ name: 'Momentum', desc: `${momentum.toFixed(0)}% in ${MOMENTUM_LOOKBACK} ${periodLabel}s` });

                            // 6. BREAKOUT
                            const lookbackPeriod = isWeekly ? 20 : 50;
                            const highN = Math.max(...highs.slice(-lookbackPeriod));
                            if (currentPrice > highN && volumeRatio >= 2 && periodChange >= 3) {
                                bullishSignals.push({ name: 'Breakout', desc: `New ${lookbackPeriod}-${periodLabel} high` });
                            }

                            // 7. BREAKDOWN
                            const lowN = Math.min(...lows.slice(-lookbackPeriod));
                            if (currentPrice < lowN && volumeRatio >= 2 && periodChange <= -3) {
                                bearishSignals.push({ name: 'Breakdown', desc: `New ${lookbackPeriod}-${periodLabel} low` });
                            }

                            // 8. REJECTION - High-to-Close drop
                            const periodHigh = highs[highs.length - 1];
                            const rejectPct = ((currentPrice - periodHigh) / periodHigh) * 100;
                            if (rejectPct <= -10) {
                                bearishSignals.push({ name: 'Rejection', desc: `${rejectPct.toFixed(0)}% high-to-close` });
                            }

                            // 9. RECLAIM - Low-to-Close rise
                            const periodLow = lows[lows.length - 1];
                            const reclaimPct = ((currentPrice - periodLow) / periodLow) * 100;
                            if (reclaimPct >= 10) {
                                bullishSignals.push({ name: 'Reclaim', desc: `+${reclaimPct.toFixed(0)}% low-to-close` });
                            }

                            // ROCKET DETERMINATION - Matches Indicator Suite
                            const bullScore = bullishSignals.length;
                            const bearScore = bearishSignals.length;

                            // Check for mega/super rejection/reclaim
                            const hasMegaReject = rejectPct <= -18;
                            const hasMegaReclaim = reclaimPct >= 18;
                            const hasSuperReject = rejectPct <= -12 && rejectPct > -18;
                            const hasSuperReclaim = reclaimPct >= 12 && reclaimPct < 18;

                            let rocket = null;
                            // Mega Rejection/Reclaim = rocket by itself
                            if (hasMegaReclaim) rocket = 'blue';
                            if (hasMegaReject) rocket = 'red';
                            // Golden/Death Cross + 1 signal = rocket
                            if (hasGolden && bullScore >= 2) rocket = 'blue';
                            if (hasDeath && bearScore >= 2) rocket = 'red';
                            // Super Rejection/Reclaim + 1 signal = rocket
                            if (hasSuperReclaim && bullScore >= 2) rocket = 'blue';
                            if (hasSuperReject && bearScore >= 2) rocket = 'red';
                            // Or 3+ regular signals
                            if (bullScore >= 3) rocket = 'blue';
                            if (bearScore >= 3) rocket = 'red';
                            // Strong rockets
                            if (bullScore >= 4) rocket = 'blue-strong';
                            if (bearScore >= 4) rocket = 'red-strong';

                            return {
                                ticker,
                                price: currentPrice,
                                change: periodChange,
                                volume: currentVolume,
                                volumeRatio,
                                rsi,
                                smaFast,
                                smaSlow,
                                rocket,
                                bullScore,
                                bearScore,
                                bullishSignals,
                                bearishSignals,
                                allSignals: [...bullishSignals, ...bearishSignals]
                            };
                        } catch (err) {
                            console.error(`Error fetching ${ticker}:`, err);
                            return null;
                        }
                    });

                    const allResults = await Promise.all(promises);
                    const validResults = allResults.filter(r => r !== null);

                    // Sort by rocket strength, then by signal count
                    validResults.sort((a, b) => {
                        const aScore = Math.max(a.bullScore, a.bearScore);
                        const bScore = Math.max(b.bullScore, b.bearScore);
                        return bScore - aScore;
                    });

                    setRocketData(validResults);
                    setLastRefresh(new Date());
                } catch (err) {
                    console.error('Rocket scanner error:', err);
                }
                setLoading(false);
            };

            // Load data on mount and view change
            React.useEffect(() => {
                if (activeEdgeView === 'gaps' && !gapData) fetchGaps();
                if (activeEdgeView === 'orb' && !orbData[selectedOrbTicker]) fetchOrb(selectedOrbTicker);
                if (activeEdgeView === 'momentum' && !momentumData) fetchMomentum();
                if (activeEdgeView === 'levels' && !keyLevelsData) fetchKeyLevels();
                if (activeEdgeView === 'rockets' && !rocketData) fetchRockets();
                if (activeEdgeView === 'scalper' && !scalpData) fetchScalpData(scalpTicker, false, scalpTimeframe);
            }, [activeEdgeView, selectedOrbTicker, rocketTimeframe, rocketData]);

            // Auto-refresh scalper chart every 10 seconds when on scalper tab
            const scalpRefreshRef = React.useRef(null);
            React.useEffect(() => {
                // Clear any existing interval
                if (scalpRefreshRef.current) {
                    clearInterval(scalpRefreshRef.current);
                    scalpRefreshRef.current = null;
                }

                if (activeEdgeView !== 'scalper') return;

                scalpRefreshRef.current = setInterval(() => {
                    // Check if chart exists (means we have data loaded)
                    if (scalpChartInstanceRef.current && currentChartTickerRef.current) {
                        // Use ref to get current ticker (avoids stale closure)
                        console.log('[Scalper] Auto-refreshing chart for:', currentChartTickerRef.current);
                        fetchScalpData(currentChartTickerRef.current, true, scalpTimeframe);
                    }
                }, 10000);

                return () => {
                    if (scalpRefreshRef.current) {
                        clearInterval(scalpRefreshRef.current);
                        scalpRefreshRef.current = null;
                    }
                };
            }, [activeEdgeView, scalpTicker, scalpTimeframe]); // Added scalpTimeframe

            // LIVE MODE clock - updates every second
            React.useEffect(() => {
                if (activeEdgeView !== 'scalper') return;
                const id = setInterval(() => setLiveTime(new Date()), 1000);
                return () => clearInterval(id);
            }, [activeEdgeView]);

            // Sync confluence refs to avoid stale closures in auto-refresh
            React.useEffect(() => { useRealTimeRef.current = useRealTime; }, [useRealTime]);
            React.useEffect(() => { minConfluenceRef.current = minConfluence; }, [minConfluence]);
            React.useEffect(() => { minBarsBetweenRef.current = minBarsBetween; }, [minBarsBetween]);

            // Reset chart when timeframe changes (so we get fresh chart)
            React.useEffect(() => {
                if (scalpChartInstanceRef.current) {
                    scalpChartInstanceRef.current.remove();
                    scalpChartInstanceRef.current = null;
                    scalpCandleSeriesRef.current = null;
                    scalpPdhLineRef.current = null;
                    scalpPdlLineRef.current = null;
                    scalpPmhLineRef.current = null;
                    scalpPmlLineRef.current = null;
                    scalpIsFirstRender.current = true;
                }
                // Auto-fetch when timeframe changes - use ref to get current ticker
                const ticker = currentChartTickerRef.current || 'SPY';
                fetchScalpData(ticker, false, scalpTimeframe);
            }, [scalpTimeframe]); // Only react to timeframe changes

            // Alert when new scalp signals are detected
            React.useEffect(() => {
                if (!scalpSignals.length || !scalpAlertsEnabled) return;

                const lastSignals = lastScalpSignalsRef.current;
                const lastSignalTimes = new Set(lastSignals.map(s => s.time));

                // Find new signals (ones we haven't seen before)
                const newSignals = scalpSignals.filter(s => !lastSignalTimes.has(s.time));

                // Only alert for signals in the last 30 minutes (recent, actionable)
                const thirtyMinAgo = Date.now() / 1000 - 1800;
                const recentNewSignals = newSignals.filter(s => s.time > thirtyMinAgo);

                if (recentNewSignals.length > 0 && lastSignals.length > 0) {
                    recentNewSignals.forEach(sig => {
                        const signalType = sig.type === 'long' ? 'üü¢ BUY' : 'üî¥ SELL';
                        const slText = sig.stopLoss ? ` | SL: $${sig.stopLoss.toFixed(2)}` : '';
                        const confText = sig.maxStrength ? ` | Conf: ${sig.strength}/${sig.maxStrength}` : '';
                        const message = `${signalType} SIGNAL: ${scalpTicker} @ $${sig.price.toFixed(2)}${confText}${slText}`;

                        // Play sound
                        try {
                            const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdH2Onp6YjHVoZ3WBjZOOg3RpZ3B9iI6KgXVtbnR9g4V/c2pscXd6e3ZuZ2pvc3Z2cm1qanF1dHNwbm9vcHN0c3FwcnV1c3JwcHJzdHNxcHFzc3JxcXFycnNycHFycnJycnJycnJycnFxcnJycnJycnJycXJxcnJycnJycnJycnFxcnJycnJycg==');
                            audio.volume = 0.5;
                            audio.play().catch(() => {});
                        } catch (e) {}

                        // Show toast notification
                        const toast = document.createElement('div');
                        toast.className = `fixed top-4 right-4 z-50 p-4 rounded-xl border shadow-lg animate-pulse ${
                            sig.type === 'long'
                                ? 'bg-green-900/90 border-green-500 text-green-100'
                                : 'bg-red-900/90 border-red-500 text-red-100'
                        }`;
                        toast.innerHTML = `
                            <div class="font-bold text-lg">${signalType} SIGNAL ${sig.maxStrength ? '<span class="text-sm opacity-75">' + sig.strength + '/' + sig.maxStrength + '</span>' : ''}</div>
                            <div class="text-sm">${scalpTicker} @ $${sig.price.toFixed(2)}${sig.stopLoss ? ' <span class="opacity-75">SL: $' + sig.stopLoss.toFixed(2) + '</span>' : ''}</div>
                            <div class="text-xs opacity-75 mt-1">${sig.reasons.join(' + ')}</div>
                        `;
                        document.body.appendChild(toast);
                        setTimeout(() => toast.remove(), 5000);

                        // Browser notification if permitted
                        if (Notification.permission === 'granted') {
                            new Notification(message, {
                                body: sig.reasons.join(' + '),
                                icon: sig.type === 'long' ? 'üü¢' : 'üî¥'
                            });
                        }

                        console.log(`[Scalper Alert] ${message}`);
                    });
                }

                // Update ref with current signals
                lastScalpSignalsRef.current = [...scalpSignals];
            }, [scalpSignals, scalpTicker, scalpAlertsEnabled]);

            // Save alert watchlist to localStorage
            React.useEffect(() => {
                localStorage.setItem('scalpAlertWatchlist', JSON.stringify(alertWatchlist));
            }, [alertWatchlist]);

            // Add ticker to watchlist
            const addToWatchlist = (ticker) => {
                const t = ticker.toUpperCase().trim();
                if (t && !alertWatchlist.includes(t)) {
                    setAlertWatchlist([...alertWatchlist, t]);
                }
            };

            // Remove ticker from watchlist
            const removeFromWatchlist = (ticker) => {
                setAlertWatchlist(alertWatchlist.filter(t => t !== ticker));
            };

            // Background scanner for watchlist tickers (runs every 30 seconds)
            React.useEffect(() => {
                if (!scalpAlertsEnabled || alertWatchlist.length === 0) return;

                const scanWatchlist = async () => {
                    for (const ticker of alertWatchlist) {
                        try {
                            const cryptoMap = {
                                'BTC': 'BTC-USD', 'ETH': 'ETH-USD', 'SOL': 'SOL-USD', 'XRP': 'XRP-USD',
                                'DOGE': 'DOGE-USD', 'ADA': 'ADA-USD'
                            };
                            const yahooTicker = cryptoMap[ticker] || ticker;
                            const response = await fetch(`/api/yahoo?ticker=${yahooTicker}&type=chart&interval=${scalpTimeframe}&range=2d`);
                            const data = await response.json();

                            if (!data.chart?.result?.[0]) continue;

                            const result = data.chart.result[0];
                            const timestamps = result.timestamp || [];
                            const quotes = result.indicators.quote[0];

                            const candles = [];
                            for (let i = 0; i < timestamps.length; i++) {
                                if (quotes.close[i] && quotes.volume[i]) {
                                    candles.push({
                                        time: timestamps[i],
                                        open: quotes.open[i],
                                        high: quotes.high[i],
                                        low: quotes.low[i],
                                        close: quotes.close[i],
                                        volume: quotes.volume[i]
                                    });
                                }
                            }

                            const levels = calcKeyLevels(candles);
                            const signals = detectScalpSignals(candles, levels, scalpTimeframe);

                            // Check for new signals (last 30 minutes)
                            const thirtyMinAgo = Date.now() / 1000 - 1800;
                            const recentSignals = signals.filter(s => s.time > thirtyMinAgo);

                            const lastKnown = watchlistSignalsRef.current[ticker] || [];
                            const lastTimes = new Set(lastKnown.map(s => s.time));
                            const newSignals = recentSignals.filter(s => !lastTimes.has(s.time));

                            if (newSignals.length > 0 && lastKnown.length > 0) {
                                newSignals.forEach(sig => {
                                    const signalType = sig.type === 'long' ? 'üü¢ BUY' : 'üî¥ SELL';
                                    const message = `${signalType} SIGNAL: ${ticker} @ $${sig.price.toFixed(2)}`;

                                    // Play sound
                                    try {
                                        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdH2Onp6YjHVoZ3WBjZOOg3RpZ3B9iI6KgXVtbnR9g4V/c2pscXd6e3ZuZ2pvc3Z2cm1qanF1dHNwbm9vcHN0c3FwcnV1c3JwcHJzdHNxcHFzc3JxcXFycnNycHFycnJycnJycnJycnFxcnJycnJycnJycXJxcnJycnJycnJycnFxcnJycnJycg==');
                                        audio.volume = 0.6;
                                        audio.play().catch(() => {});
                                    } catch (e) {}

                                    // Show toast
                                    const toast = document.createElement('div');
                                    toast.className = `fixed top-4 right-4 z-50 p-4 rounded-xl border shadow-lg animate-pulse ${
                                        sig.type === 'long' ? 'bg-green-900/90 border-green-500 text-green-100' : 'bg-red-900/90 border-red-500 text-red-100'
                                    }`;
                                    toast.innerHTML = `
                                        <div class="font-bold text-lg">${signalType} SIGNAL</div>
                                        <div class="text-sm">${ticker} @ $${sig.price.toFixed(2)}</div>
                                        <div class="text-xs opacity-75 mt-1">${sig.reasons.join(' + ')}</div>
                                    `;
                                    document.body.appendChild(toast);
                                    setTimeout(() => toast.remove(), 6000);

                                    // Browser notification
                                    if (Notification.permission === 'granted') {
                                        new Notification(message, { body: sig.reasons.join(' + ') });
                                    }

                                    console.log(`[Watchlist Alert] ${message}`);
                                });
                            }

                            // Update known signals for this ticker
                            watchlistSignalsRef.current[ticker] = recentSignals;

                        } catch (e) {
                            console.error(`Watchlist scan error for ${ticker}:`, e);
                        }
                    }
                };

                // Initial scan
                scanWatchlist();

                // Scan every 30 seconds
                const interval = setInterval(scanWatchlist, 30000);
                return () => clearInterval(interval);
            }, [scalpAlertsEnabled, alertWatchlist, scalpTimeframe]);

            // Market close countdown timer (updates every second)
            React.useEffect(() => {
                const updateTimer = () => {
                    const now = new Date();
                    // Market closes at 4:00 PM ET (1:00 PM PT)
                    const etOffset = -5; // EST (adjust to -4 for EDT)
                    const utcHours = now.getUTCHours();
                    const utcMins = now.getUTCMinutes();
                    const utcSecs = now.getUTCSeconds();
                    const etHours = (utcHours + etOffset + 24) % 24;

                    // Market close is 16:00 ET
                    const closeHour = 16;
                    const closeMins = 0;

                    // Calculate seconds until close
                    let secsUntilClose = ((closeHour - etHours) * 3600) + ((closeMins - utcMins) * 60) - utcSecs;

                    // If market is closed (after 4pm or weekend)
                    const dayOfWeek = now.getUTCDay();
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                    const isAfterClose = etHours >= 16;
                    const isBeforeOpen = etHours < 9 || (etHours === 9 && utcMins < 30);

                    if (isWeekend || isAfterClose || secsUntilClose < 0) {
                        setMarketCloseTime('CLOSED');
                        return;
                    }

                    if (isBeforeOpen) {
                        // Calculate time until 9:30 AM open
                        let secsUntilOpen = ((9 - etHours) * 3600) + ((30 - utcMins) * 60) - utcSecs;
                        const openHrs = Math.floor(secsUntilOpen / 3600);
                        const openMins = Math.floor((secsUntilOpen % 3600) / 60);
                        const openSecs = secsUntilOpen % 60;
                        setMarketCloseTime(`OPENS ${openHrs}:${openMins.toString().padStart(2,'0')}:${openSecs.toString().padStart(2,'0')}`);
                        return;
                    }

                    const hrs = Math.floor(secsUntilClose / 3600);
                    const mins = Math.floor((secsUntilClose % 3600) / 60);
                    const secs = secsUntilClose % 60;
                    setMarketCloseTime(`${hrs}:${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`);
                };

                updateTimer();
                const interval = setInterval(updateTimer, 1000);
                return () => clearInterval(interval);
            }, []);

            // Momentum Scanner - Find stocks moving 2%+ in last 5 mins
            const scanMomentum = async () => {
                setMomentumLoading(true);
                const tickers = ['SPY', 'QQQ', 'AAPL', 'NVDA', 'TSLA', 'AMD', 'META', 'MSFT', 'GOOGL', 'AMZN', 'COIN', 'MARA', 'RIOT', 'PLTR', 'SOFI', 'NIO', 'RIVN'];
                const results = [];

                for (const ticker of tickers) {
                    try {
                        const res = await fetch(`/api/yahoo?ticker=${ticker}&type=chart&interval=5m&range=1d`);
                        const data = await res.json();
                        if (data.chart?.result?.[0]?.indicators?.quote?.[0]) {
                            const quotes = data.chart.result[0];
                            const closes = quotes.indicators.quote[0].close.filter(c => c !== null);
                            const volumes = quotes.indicators.quote[0].volume.filter(v => v !== null);
                            if (closes.length >= 2) {
                                const current = closes[closes.length - 1];
                                const prev5 = closes[closes.length - 2]; // 5 mins ago
                                const prev30 = closes[Math.max(0, closes.length - 7)]; // ~30 mins ago
                                const change5 = ((current - prev5) / prev5) * 100;
                                const change30 = ((current - prev30) / prev30) * 100;
                                const avgVol = volumes.slice(-20).reduce((a,b) => a+b, 0) / 20;
                                const lastVol = volumes[volumes.length - 1];
                                const volSpike = lastVol / avgVol;

                                if (Math.abs(change5) >= 0.3 || Math.abs(change30) >= 1.5 || volSpike >= 2) {
                                    results.push({
                                        ticker,
                                        price: current,
                                        change5: change5.toFixed(2),
                                        change30: change30.toFixed(2),
                                        volSpike: volSpike.toFixed(1),
                                        direction: change5 > 0 ? 'up' : 'down'
                                    });
                                }
                            }
                        }
                    } catch (e) { console.error(`Momentum scan error for ${ticker}:`, e); }
                }

                // Sort by absolute 5-min change
                results.sort((a, b) => Math.abs(parseFloat(b.change5)) - Math.abs(parseFloat(a.change5)));
                setMomentumStocks(results);
                setMomentumLoading(false);
            };

            // Premarket Gapper Scanner
            const scanGappers = async () => {
                setGapperLoading(true);
                const tickers = ['SPY', 'QQQ', 'AAPL', 'NVDA', 'TSLA', 'AMD', 'META', 'MSFT', 'GOOGL', 'AMZN', 'COIN', 'MARA', 'RIOT', 'PLTR', 'SOFI', 'NIO', 'RIVN', 'SMCI', 'ARM', 'AVGO'];
                const results = [];

                for (const ticker of tickers) {
                    try {
                        const res = await fetch(`/api/yahoo?ticker=${ticker}&type=chart&interval=1d&range=5d`);
                        const data = await res.json();
                        if (data.chart?.result?.[0]?.indicators?.quote?.[0]) {
                            const quotes = data.chart.result[0];
                            const closes = quotes.indicators.quote[0].close.filter(c => c !== null);
                            const opens = quotes.indicators.quote[0].open.filter(o => o !== null);
                            if (closes.length >= 2 && opens.length >= 1) {
                                const prevClose = closes[closes.length - 2];
                                const todayOpen = opens[opens.length - 1];
                                const currentPrice = closes[closes.length - 1];
                                const gap = ((todayOpen - prevClose) / prevClose) * 100;
                                const gapFill = ((currentPrice - todayOpen) / (prevClose - todayOpen)) * 100;

                                if (Math.abs(gap) >= 0.5) {
                                    results.push({
                                        ticker,
                                        prevClose: prevClose.toFixed(2),
                                        open: todayOpen.toFixed(2),
                                        current: currentPrice.toFixed(2),
                                        gap: gap.toFixed(2),
                                        gapFill: isFinite(gapFill) ? Math.min(100, Math.max(0, gapFill)).toFixed(0) : '0',
                                        direction: gap > 0 ? 'up' : 'down'
                                    });
                                }
                            }
                        }
                    } catch (e) { console.error(`Gapper scan error for ${ticker}:`, e); }
                }

                // Sort by absolute gap size
                results.sort((a, b) => Math.abs(parseFloat(b.gap)) - Math.abs(parseFloat(a.gap)));
                setGapperStocks(results);
                setGapperLoading(false);
            };

            // IV Scanner - Analyze IV conditions for 0DTE morning plays
            const scanIV = async () => {
                setIvLoading(true);
                try {
                    const res = await fetch('/api/iv-scanner?tickers=SPY,QQQ,IWM');
                    const data = await res.json();
                    setIvData(data);
                    setIvLastScan(new Date().toLocaleTimeString());
                    console.log('[IV Scanner] Data:', data);
                } catch (e) {
                    console.error('[IV Scanner] Error:', e);
                }
                setIvLoading(false);
            };

            // Next Day Prediction - Predict open/close direction
            const scanPrediction = async () => {
                setPredictionLoading(true);
                try {
                    const res = await fetch('/api/next-day-prediction?tickers=SPY,QQQ,IWM');
                    const data = await res.json();
                    setPredictionData(data);
                    setPredictionLastScan(new Date().toLocaleTimeString());
                    console.log('[Next Day Prediction] Data:', data);
                } catch (e) {
                    console.error('[Next Day Prediction] Error:', e);
                }
                setPredictionLoading(false);
            };

            // Render scalp chart when data changes - REUSE chart to prevent flashing
            React.useEffect(() => {
                if (!scalpData || !scalpChartRef.current) return;

                let chart = scalpChartInstanceRef.current;
                let candleSeries = scalpCandleSeriesRef.current;
                let isNewChart = false;

                // Only create chart if it doesn't exist
                if (!chart) {
                    isNewChart = true;
                    scalpIsFirstRender.current = true;
                    chart = LightweightCharts.createChart(scalpChartRef.current, {
                        autoSize: true,
                        height: 500,
                        layout: {
                            background: { type: 'solid', color: '#1a1a2e' },
                            textColor: '#d1d5db',
                        },
                        grid: {
                            vertLines: { color: '#2d2d44' },
                            horzLines: { color: '#2d2d44' },
                        },
                        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                        rightPriceScale: { borderColor: '#4b5563' },
                        leftPriceScale: { visible: true, borderColor: '#4b5563' },
                        localization: {
                            timeFormatter: (timestamp) => {
                                const date = new Date(timestamp * 1000);
                                const dateStr = date.toLocaleDateString('en-US', {
                                    timeZone: 'America/Los_Angeles',
                                    month: 'short',
                                    day: 'numeric'
                                });
                                const timeStr = date.toLocaleTimeString('en-US', {
                                    timeZone: 'America/Los_Angeles',
                                    hour: 'numeric',
                                    minute: '2-digit',
                                    hour12: true
                                });
                                return `${dateStr} ${timeStr}`;
                            }
                        },
                        timeScale: {
                            borderColor: '#4b5563',
                            timeVisible: true,
                            secondsVisible: false,
                            barSpacing: 6,
                            minBarSpacing: 1,
                        },
                    });
                    scalpChartInstanceRef.current = chart;

                    // Add candlestick series
                    candleSeries = chart.addCandlestickSeries({
                        upColor: '#22c55e',
                        downColor: '#ef4444',
                        borderUpColor: '#22c55e',
                        borderDownColor: '#ef4444',
                        wickUpColor: '#22c55e',
                        wickDownColor: '#ef4444',
                    });
                    scalpCandleSeriesRef.current = candleSeries;

                    // Add key level lines (priceScaleId: 'left' puts labels on left side)
                    scalpPdhLineRef.current = chart.addLineSeries({
                        color: '#ef4444', lineWidth: 1, lineStyle: 2,
                        priceScaleId: 'left', lastValueVisible: true, priceLineVisible: false,
                        title: 'PDH'
                    });
                    scalpPdlLineRef.current = chart.addLineSeries({
                        color: '#22c55e', lineWidth: 1, lineStyle: 2,
                        priceScaleId: 'left', lastValueVisible: true, priceLineVisible: false,
                        title: 'PDL'
                    });
                    scalpPmhLineRef.current = chart.addLineSeries({
                        color: '#f97316', lineWidth: 1, lineStyle: 1,
                        priceScaleId: 'left', lastValueVisible: true, priceLineVisible: false,
                        title: 'PMH'
                    });
                    scalpPmlLineRef.current = chart.addLineSeries({
                        color: '#14b8a6', lineWidth: 1, lineStyle: 1,
                        priceScaleId: 'left', lastValueVisible: true, priceLineVisible: false,
                        title: 'PML'
                    });

                    // EMA overlay lines
                    scalpEma9LineRef.current = chart.addLineSeries({
                        color: '#3b82f6', lineWidth: 1, priceLineVisible: false,
                        lastValueVisible: false, title: 'EMA9'
                    });
                    scalpEma21LineRef.current = chart.addLineSeries({
                        color: '#f97316', lineWidth: 1, priceLineVisible: false,
                        lastValueVisible: false, title: 'EMA21'
                    });
                    scalpEma50LineRef.current = chart.addLineSeries({
                        color: 'rgba(255,255,255,0.5)', lineWidth: 2, priceLineVisible: false,
                        lastValueVisible: false, title: 'EMA50'
                    });

                    // Bollinger Band overlay lines
                    scalpBbUpperRef.current = chart.addLineSeries({
                        color: 'rgba(156,163,175,0.4)', lineWidth: 1, lineStyle: 2,
                        priceLineVisible: false, lastValueVisible: false
                    });
                    scalpBbLowerRef.current = chart.addLineSeries({
                        color: 'rgba(156,163,175,0.4)', lineWidth: 1, lineStyle: 2,
                        priceLineVisible: false, lastValueVisible: false
                    });
                    scalpBbBasisRef.current = chart.addLineSeries({
                        color: 'rgba(156,163,175,0.2)', lineWidth: 1, lineStyle: 1,
                        priceLineVisible: false, lastValueVisible: false
                    });

                    // Handle resize
                    const handleResize = () => {
                        if (scalpChartRef.current && chart) {
                            chart.applyOptions({ width: scalpChartRef.current.clientWidth });
                        }
                    };
                    window.addEventListener('resize', handleResize);
                }

                // Update candle data (this preserves zoom/scroll!)
                candleSeries.setData(scalpData.candles);

                // Update key levels
                if (scalpData.levels.PDH && scalpPdhLineRef.current) {
                    scalpPdhLineRef.current.setData(scalpData.candles.map(c => ({ time: c.time, value: scalpData.levels.PDH })));
                }
                if (scalpData.levels.PDL && scalpPdlLineRef.current) {
                    scalpPdlLineRef.current.setData(scalpData.candles.map(c => ({ time: c.time, value: scalpData.levels.PDL })));
                }
                if (scalpData.levels.PMH && scalpPmhLineRef.current) {
                    scalpPmhLineRef.current.setData(scalpData.candles.map(c => ({ time: c.time, value: scalpData.levels.PMH })));
                }
                if (scalpData.levels.PML && scalpPmlLineRef.current) {
                    scalpPmlLineRef.current.setData(scalpData.candles.map(c => ({ time: c.time, value: scalpData.levels.PML })));
                }


                // Update EMA/BB overlays
                if (showOverlays && scalpData.ema9) {
                    const times = scalpData.candles.map(c => c.time);
                    const mapLine = (arr) => arr.map((v, i) => v ? { time: times[i], value: v } : null).filter(Boolean);
                    scalpEma9LineRef.current?.setData(mapLine(scalpData.ema9));
                    scalpEma21LineRef.current?.setData(mapLine(scalpData.ema21));
                    scalpEma50LineRef.current?.setData(mapLine(scalpData.ema50));
                } else {
                    scalpEma9LineRef.current?.setData([]);
                    scalpEma21LineRef.current?.setData([]);
                    scalpEma50LineRef.current?.setData([]);
                }
                if (showOverlays && scalpData.bbData) {
                    const times = scalpData.candles.map(c => c.time);
                    const mapBB = (key) => scalpData.bbData.map((b, i) => b[key] ? { time: times[i], value: b[key] } : null).filter(Boolean);
                    scalpBbUpperRef.current?.setData(mapBB('upper'));
                    scalpBbLowerRef.current?.setData(mapBB('lower'));
                    scalpBbBasisRef.current?.setData(mapBB('basis'));
                } else {
                    scalpBbUpperRef.current?.setData([]);
                    scalpBbLowerRef.current?.setData([]);
                    scalpBbBasisRef.current?.setData([]);
                }

                // Update signal markers (score labels off by default for clean chart)
                const markers = scalpSignals.map(sig => ({
                    time: sig.time,
                    position: sig.type === 'long' ? 'belowBar' : 'aboveBar',
                    color: sig.type === 'long' ? '#22c55e' : '#ef4444',
                    shape: sig.type === 'long' ? 'arrowUp' : 'arrowDown',
                    text: sig.mode || 'LA',
                    size: 1,
                }));
                candleSeries.setMarkers(markers);

                // Add session markers (vertical lines at key times)
                if (sessionMarkersEnabled && scalpData.candles.length > 0) {
                    // Remove old session lines
                    sessionLinesRef.current.forEach(line => {
                        try { chart.removeSeries(line); } catch(e) {}
                    });
                    sessionLinesRef.current = [];

                    // Get unique days in the data
                    const days = [...new Set(scalpData.candles.map(c => new Date(c.time * 1000).toDateString()))];

                    // Session times in ET (hours, minutes)
                    const sessionTimes = [
                        { h: 9, m: 30, label: 'OPEN', color: '#3b82f6' },      // Market open
                        { h: 10, m: 0, label: '10AM', color: '#f59e0b' },       // Reversal zone
                        { h: 11, m: 30, label: 'LUNCH', color: '#6b7280' },     // Lunch chop
                        { h: 15, m: 0, label: 'PWR HR', color: '#8b5cf6' },     // Power hour
                    ];

                    const priceRange = Math.max(...scalpData.candles.map(c => c.high)) - Math.min(...scalpData.candles.map(c => c.low));
                    const minPrice = Math.min(...scalpData.candles.map(c => c.low));
                    const maxPrice = Math.max(...scalpData.candles.map(c => c.high));

                    days.forEach(dayStr => {
                        sessionTimes.forEach(session => {
                            // Create date in ET timezone
                            const dayDate = new Date(dayStr);
                            const etDate = new Date(dayDate.getFullYear(), dayDate.getMonth(), dayDate.getDate(), session.h, session.m, 0);
                            // Adjust for ET offset (rough approximation - ET is UTC-5)
                            const timestamp = Math.floor(etDate.getTime() / 1000) + (5 * 3600); // Add 5 hours to get from local to ET

                            // Find closest candle to this timestamp
                            const closestCandle = scalpData.candles.reduce((prev, curr) =>
                                Math.abs(curr.time - timestamp) < Math.abs(prev.time - timestamp) ? curr : prev
                            );

                            // Only show marker if within 15 mins of actual session time
                            if (Math.abs(closestCandle.time - timestamp) < 900) {
                                const line = chart.addLineSeries({
                                    color: session.color,
                                    lineWidth: 1,
                                    lineStyle: 2, // Dashed
                                    priceLineVisible: false,
                                    lastValueVisible: false,
                                });
                                // Draw vertical-ish line by using two points at same time
                                line.setData([
                                    { time: closestCandle.time, value: minPrice },
                                    { time: closestCandle.time, value: maxPrice }
                                ]);
                                sessionLinesRef.current.push(line);
                            }
                        });
                    });
                }

                // Only fit content on FIRST render, not on updates
                if (scalpIsFirstRender.current) {
                    chart.timeScale().fitContent();
                    scalpIsFirstRender.current = false;
                }
            }, [scalpData, scalpSignals, sessionMarkersEnabled, showOverlays]);

            return (
                <div className="space-y-4">
                    {/* Header */}
                    <div className="flex items-center justify-between">
                        <div>
                            <h2 className="text-lg font-bold flex items-center gap-2">
                                ‚ö° Market Edge
                                <span className="text-xs bg-green-500/20 text-green-400 px-2 py-0.5 rounded-full">BETA</span>
                            </h2>
                            <p className="text-xs text-gray-500">Find setups ‚Ä¢ Know levels ‚Ä¢ Trade smarter</p>
                        </div>
                        {lastRefresh && (
                            <span className="text-xs text-gray-500">
                                Updated {lastRefresh.toLocaleTimeString()}
                            </span>
                        )}
                    </div>

                    {/* Edge View Tabs */}
                    <div className="flex gap-1 bg-gray-800/50 p-1 rounded-xl">
                        {[
                            { id: 'iv', label: 'üìà IV', desc: '0DTE IV Scanner' },
                            { id: 'predict', label: 'üîÆ Predict', desc: 'Next Day Prob' },
                            { id: 'rockets', label: 'üöÄ Rockets', desc: 'Confluence signals' },
                            { id: 'scalper', label: '‚ö° Scalper', desc: '5-min signals' },
                            { id: 'gaps', label: 'üìä Gaps', desc: 'Pre-market gaps' },
                            { id: 'orb', label: 'üìà ORB/IB', desc: 'Opening Range' },
                            { id: 'momentum', label: 'üöÄ Movers', desc: 'Big moves' }
                        ].map(view => (
                            <button
                                key={view.id}
                                onClick={() => setActiveEdgeView(view.id)}
                                className={`flex-1 py-2 px-2 rounded-lg text-xs font-medium transition-colors ${
                                    activeEdgeView === view.id
                                        ? view.id === 'rockets' ? 'bg-gradient-to-r from-blue-500 to-red-500 text-white'
                                        : view.id === 'iv' ? 'bg-gradient-to-r from-yellow-500 to-orange-500 text-white'
                                        : view.id === 'predict' ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white'
                                        : 'bg-green-600 text-white'
                                        : 'text-gray-400 hover:text-white hover:bg-gray-700'
                                }`}
                            >
                                {view.label}
                            </button>
                        ))}
                    </div>

                    {/* IV Scanner View - 0DTE Morning Play Analysis */}
                    {activeEdgeView === 'iv' && (
                        <div className="space-y-3">
                            {/* Header */}
                            <div className="flex items-center justify-between">
                                <div>
                                    <span className="text-sm font-semibold">0DTE IV Scanner</span>
                                    <p className="text-xs text-gray-500">Morning IV conditions for SPY/QQQ/IWM</p>
                                </div>
                                <div className="flex gap-2 items-center">
                                    {ivLastScan && <span className="text-xs text-gray-500">Last: {ivLastScan}</span>}
                                    <button
                                        onClick={scanIV}
                                        disabled={ivLoading}
                                        className="px-3 py-1.5 bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-400 hover:to-orange-400 rounded-lg text-xs font-semibold disabled:opacity-50"
                                    >
                                        {ivLoading ? '‚è≥ Scanning...' : 'üîç Scan IV'}
                                    </button>
                                </div>
                            </div>

                            {/* VIX Context Card */}
                            {ivData?.vix && (
                                <div className="bg-gray-800/50 rounded-xl p-3">
                                    <div className="flex items-center justify-between mb-2">
                                        <span className="text-xs font-semibold text-gray-400">VIX Context</span>
                                        <div className="flex gap-1">
                                            <span className={`text-xs px-2 py-0.5 rounded ${
                                                ivData.vix.trend === 'RISING' ? 'bg-red-500/20 text-red-400' :
                                                ivData.vix.trend === 'FALLING' ? 'bg-green-500/20 text-green-400' :
                                                'bg-gray-500/20 text-gray-400'
                                            }`}>
                                                {ivData.vix.trend === 'RISING' ? 'üìà Rising' :
                                                 ivData.vix.trend === 'FALLING' ? 'üìâ Falling' : '‚ûñ Flat'}
                                            </span>
                                            <span className={`text-xs px-2 py-0.5 rounded ${
                                                ivData.vix.elevated === 'HIGH' ? 'bg-red-500/20 text-red-400' :
                                                ivData.vix.elevated === 'LOW' ? 'bg-green-500/20 text-green-400' :
                                                'bg-gray-500/20 text-gray-400'
                                            }`}>
                                                {ivData.vix.elevated === 'HIGH' ? '‚ö†Ô∏è Elevated' :
                                                 ivData.vix.elevated === 'LOW' ? 'üò¥ Depressed' : '‚ûñ Normal'}
                                            </span>
                                        </div>
                                    </div>
                                    <div className="grid grid-cols-3 gap-2 text-center">
                                        <div>
                                            <div className="text-lg font-bold text-white">{ivData.vix.current?.toFixed(2)}</div>
                                            <div className="text-xs text-gray-500">Current</div>
                                        </div>
                                        <div>
                                            <div className="text-lg font-bold text-gray-400">{ivData.vix.avg5d?.toFixed(2)}</div>
                                            <div className="text-xs text-gray-500">5-Day Avg</div>
                                        </div>
                                        <div>
                                            <div className={`text-lg font-bold ${ivData.vix.deviation > 0 ? 'text-red-400' : 'text-green-400'}`}>
                                                {ivData.vix.deviation > 0 ? '+' : ''}{ivData.vix.deviation?.toFixed(1)}%
                                            </div>
                                            <div className="text-xs text-gray-500">Deviation</div>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* Pre-Market Range Card */}
                            {ivData?.premarketRange && (
                                <div className="bg-gray-800/50 rounded-xl p-3">
                                    <div className="flex items-center justify-between mb-2">
                                        <span className="text-xs font-semibold text-gray-400">SPY Pre-Market</span>
                                        <div className="flex gap-1">
                                            <span className={`text-xs px-2 py-0.5 rounded font-bold ${
                                                ivData.premarketRange.direction === 'GREEN' ? 'bg-green-500/20 text-green-400' :
                                                ivData.premarketRange.direction === 'RED' ? 'bg-red-500/20 text-red-400' :
                                                'bg-gray-500/20 text-gray-400'
                                            }`}>
                                                {ivData.premarketRange.direction === 'GREEN' ? `üìà +${ivData.premarketRange.change?.toFixed(2)}%` :
                                                 ivData.premarketRange.direction === 'RED' ? `üìâ ${ivData.premarketRange.change?.toFixed(2)}%` :
                                                 '‚ûñ Flat'}
                                            </span>
                                            <span className={`text-xs px-2 py-0.5 rounded ${
                                                ivData.premarketRange.verdict === 'LARGE_MOVE' ? 'bg-orange-500/20 text-orange-400' :
                                                ivData.premarketRange.verdict === 'COILED' ? 'bg-purple-500/20 text-purple-400' :
                                                'bg-gray-500/20 text-gray-400'
                                            }`}>
                                                {ivData.premarketRange.verdict === 'LARGE_MOVE' ? 'üî• Big Move' :
                                                 ivData.premarketRange.verdict === 'COILED' ? 'üéØ Coiled' : '‚ûñ Normal'}
                                            </span>
                                        </div>
                                    </div>
                                    <div className="grid grid-cols-4 gap-2 text-center">
                                        <div>
                                            <div className="text-sm font-bold text-gray-400">${ivData.premarketRange.prevClose?.toFixed(2)}</div>
                                            <div className="text-xs text-gray-500">Prev Close</div>
                                        </div>
                                        <div>
                                            <div className="text-sm font-bold text-green-400">${ivData.premarketRange.high?.toFixed(2)}</div>
                                            <div className="text-xs text-gray-500">High</div>
                                        </div>
                                        <div>
                                            <div className="text-sm font-bold text-red-400">${ivData.premarketRange.low?.toFixed(2)}</div>
                                            <div className="text-xs text-gray-500">Low</div>
                                        </div>
                                        <div>
                                            <div className="text-sm font-bold text-white">${ivData.premarketRange.range?.toFixed(2)}</div>
                                            <div className="text-xs text-gray-500">Range</div>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* Ticker Analysis Cards */}
                            {ivData?.tickers && Object.entries(ivData.tickers).map(([ticker, data]) => (
                                <div key={ticker} className="bg-gray-800/50 rounded-xl p-3">
                                    {/* Direction Call - Big and prominent */}
                                    <div className={`mb-3 p-3 rounded-xl text-center ${
                                        data.direction === 'CALLS' || data.direction === 'LEAN_CALLS'
                                            ? 'bg-gradient-to-r from-green-500/20 to-emerald-500/20 border border-green-500/30'
                                            : data.direction === 'PUTS' || data.direction === 'LEAN_PUTS'
                                            ? 'bg-gradient-to-r from-red-500/20 to-rose-500/20 border border-red-500/30'
                                            : 'bg-gray-700/30 border border-gray-600/30'
                                    }`}>
                                        <div className="text-2xl font-bold mb-1">
                                            {data.direction === 'CALLS' ? 'üìû CALLS' :
                                             data.direction === 'LEAN_CALLS' ? 'üìû Lean CALLS' :
                                             data.direction === 'PUTS' ? 'üîª PUTS' :
                                             data.direction === 'LEAN_PUTS' ? 'üîª Lean PUTS' :
                                             '‚öñÔ∏è NEUTRAL'}
                                        </div>
                                        <div className="text-xs text-gray-400">
                                            Direction Confidence: {data.directionConfidence}/10
                                        </div>
                                    </div>

                                    <div className="flex items-center justify-between mb-3">
                                        <div className="flex items-center gap-2">
                                            <span className="text-lg font-bold">{ticker}</span>
                                            <span className="text-sm text-gray-400">${data.price?.toFixed(2)}</span>
                                            {data.atmStrike && <span className="text-xs text-gray-500">ATM: ${data.atmStrike}</span>}
                                        </div>
                                        <div className={`px-3 py-1 rounded-lg text-sm font-bold ${
                                            data.verdict === 'IV_CRUSH_LIKELY' ? 'bg-red-500/20 text-red-400' :
                                            data.verdict === 'IV_EXPANSION_LIKELY' ? 'bg-green-500/20 text-green-400' :
                                            data.verdict === 'WAIT' ? 'bg-yellow-500/20 text-yellow-400' :
                                            'bg-gray-500/20 text-gray-400'
                                        }`}>
                                            {data.verdict === 'IV_CRUSH_LIKELY' ? 'üìâ IV CRUSH' :
                                             data.verdict === 'IV_EXPANSION_LIKELY' ? 'üìà IV EXPAND' :
                                             data.verdict === 'WAIT' ? '‚è∏Ô∏è WAIT' : '‚ûñ NEUTRAL'}
                                        </div>
                                    </div>

                                    {data.error ? (
                                        <div className="text-xs text-red-400">{data.error}</div>
                                    ) : (
                                        <>
                                            {/* IV Data Grid */}
                                            <div className="grid grid-cols-4 gap-2 text-center mb-3">
                                                <div className="bg-gray-900/50 rounded-lg p-2">
                                                    <div className="text-sm font-bold text-white">{data.zeroDteIV || 'N/A'}</div>
                                                    <div className="text-xs text-gray-500">0DTE IV</div>
                                                </div>
                                                <div className="bg-gray-900/50 rounded-lg p-2">
                                                    <div className="text-sm font-bold text-gray-400">{data.sevenDteIV || 'N/A'}</div>
                                                    <div className="text-xs text-gray-500">7DTE IV</div>
                                                </div>
                                                <div className="bg-gray-900/50 rounded-lg p-2">
                                                    <div className={`text-sm font-bold ${
                                                        data.termStructureVerdict === 'ELEVATED' ? 'text-red-400' :
                                                        data.termStructureVerdict === 'INVERTED' ? 'text-green-400' : 'text-gray-400'
                                                    }`}>{data.termStructure || 'N/A'}</div>
                                                    <div className="text-xs text-gray-500">Term Struct</div>
                                                </div>
                                                <div className="bg-gray-900/50 rounded-lg p-2">
                                                    <div className={`text-sm font-bold ${
                                                        data.spreadVerdict === 'WIDE' ? 'text-red-400' :
                                                        data.spreadVerdict === 'TIGHT' ? 'text-green-400' : 'text-gray-400'
                                                    }`}>{data.bidAskSpread || 'N/A'}</div>
                                                    <div className="text-xs text-gray-500">Spread</div>
                                                </div>
                                            </div>

                                            {/* Direction Signals */}
                                            {data.directionSignals && data.directionSignals.length > 0 && (
                                                <div className="mb-3">
                                                    <div className="text-xs text-gray-400 mb-2">Direction Signals:</div>
                                                    <div className="flex flex-wrap gap-1">
                                                        {data.directionSignals.map((sig, i) => (
                                                            <span
                                                                key={i}
                                                                className={`text-xs px-2 py-0.5 rounded ${
                                                                    sig.bias === 'bullish' ? 'bg-green-500/20 text-green-400' :
                                                                    sig.bias === 'bearish' ? 'bg-red-500/20 text-red-400' :
                                                                    'bg-gray-500/20 text-gray-400'
                                                                }`}
                                                            >
                                                                {sig.signal}
                                                            </span>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}

                                            {/* Quick Stats Row */}
                                            <div className="grid grid-cols-4 gap-1 text-center text-xs mb-3">
                                                <div className="bg-gray-900/50 rounded p-1.5">
                                                    <div className={`font-bold ${
                                                        parseFloat(data.rsi) < 30 ? 'text-green-400' :
                                                        parseFloat(data.rsi) > 70 ? 'text-red-400' : 'text-gray-300'
                                                    }`}>{data.rsi || '-'}</div>
                                                    <div className="text-gray-500">RSI</div>
                                                </div>
                                                <div className="bg-gray-900/50 rounded p-1.5">
                                                    <div className={`font-bold ${
                                                        data.trend === 'BULLISH' ? 'text-green-400' :
                                                        data.trend === 'BEARISH' ? 'text-red-400' : 'text-gray-300'
                                                    }`}>{data.trend === 'BULLISH' ? '‚Üë' : data.trend === 'BEARISH' ? '‚Üì' : '‚Üí'}</div>
                                                    <div className="text-gray-500">Trend</div>
                                                </div>
                                                <div className="bg-gray-900/50 rounded p-1.5">
                                                    <div className={`font-bold ${data.closeVsVwap === 'ABOVE' ? 'text-green-400' : 'text-red-400'}`}>
                                                        {data.closeVsVwap === 'ABOVE' ? '‚Üë' : '‚Üì'}
                                                    </div>
                                                    <div className="text-gray-500">VWAP</div>
                                                </div>
                                                <div className="bg-gray-900/50 rounded p-1.5">
                                                    <div className={`font-bold ${data.consecutiveRed > 0 ? 'text-red-400' : data.consecutiveGreen > 0 ? 'text-green-400' : 'text-gray-300'}`}>
                                                        {data.consecutiveRed > 0 ? `-${data.consecutiveRed}` : data.consecutiveGreen > 0 ? `+${data.consecutiveGreen}` : '0'}
                                                    </div>
                                                    <div className="text-gray-500">Streak</div>
                                                </div>
                                            </div>

                                            {/* IV Confidence Bar */}
                                            <div className="flex items-center gap-2 mb-2">
                                                <span className="text-xs text-gray-500">IV Confidence:</span>
                                                <div className="flex-1 bg-gray-700 rounded-full h-2">
                                                    <div
                                                        className={`h-2 rounded-full ${
                                                            data.confidence >= 7 ? 'bg-green-500' :
                                                            data.confidence >= 5 ? 'bg-yellow-500' : 'bg-red-500'
                                                        }`}
                                                        style={{ width: `${(data.confidence || 0) * 10}%` }}
                                                    />
                                                </div>
                                                <span className="text-xs font-bold">{data.confidence}/10</span>
                                            </div>

                                            {/* Notes */}
                                            {data.notes && data.notes.length > 0 && (
                                                <div className="space-y-1">
                                                    {data.notes.map((note, i) => (
                                                        <div key={i} className="text-xs text-gray-400 flex items-center gap-1">
                                                            <span>üí°</span> {note}
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </>
                                    )}
                                </div>
                            ))}

                            {/* Empty State */}
                            {!ivData && !ivLoading && (
                                <div className="text-center py-8 text-gray-500">
                                    <div className="text-3xl mb-2">üìà</div>
                                    <div className="text-sm">Hit <span className="font-bold text-yellow-400">Scan IV</span> to analyze morning conditions</div>
                                    <div className="text-xs mt-2">Best used between 6:30-6:45am (market open)</div>
                                </div>
                            )}

                            {/* Loading State */}
                            {ivLoading && (
                                <div className="text-center py-8">
                                    <div className="text-3xl mb-2 animate-pulse">‚è≥</div>
                                    <div className="text-sm text-gray-400">Scanning IV conditions...</div>
                                </div>
                            )}

                            {/* Info Card */}
                            <div className="bg-yellow-500/10 border border-yellow-500/20 rounded-xl p-3 text-xs text-yellow-400/80">
                                <div className="font-semibold mb-1">üìä How to Read This:</div>
                                <ul className="space-y-1 text-yellow-400/60">
                                    <li>‚Ä¢ <strong>CALLS/PUTS</strong> = Direction based on VIX trend, pre-market, RSI, VWAP, streak</li>
                                    <li>‚Ä¢ <strong>IV EXPAND</strong> = VIX low + coiled range ‚Üí let winners run longer</li>
                                    <li>‚Ä¢ <strong>IV CRUSH</strong> = VIX elevated + big move ‚Üí take quick profits</li>
                                    <li>‚Ä¢ <strong>VIX Falling</strong> = Fear fading ‚Üí bullish for calls</li>
                                    <li>‚Ä¢ <strong>VIX Rising</strong> = Fear rising ‚Üí bearish, puts favored</li>
                                    <li>‚Ä¢ <strong>Pre-market Green</strong> = Momentum into open ‚Üí calls</li>
                                    <li>‚Ä¢ <strong>Pre-market Red</strong> = Weak open expected ‚Üí puts</li>
                                </ul>
                            </div>
                        </div>
                    )}

                    {/* Next Day Prediction View */}
                    {activeEdgeView === 'predict' && (
                        <div className="space-y-3">
                            {/* Header */}
                            <div className="flex items-center justify-between">
                                <div>
                                    <span className="text-sm font-semibold">Next Day Prediction</span>
                                    <p className="text-xs text-gray-500">Open/Close probability based on patterns</p>
                                </div>
                                <div className="flex gap-2 items-center">
                                    {predictionLastScan && <span className="text-xs text-gray-500">Last: {predictionLastScan}</span>}
                                    <button
                                        onClick={scanPrediction}
                                        disabled={predictionLoading}
                                        className="px-3 py-1.5 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-400 hover:to-pink-400 rounded-lg text-xs font-semibold disabled:opacity-50"
                                    >
                                        {predictionLoading ? '‚è≥ Analyzing...' : 'üîÆ Predict'}
                                    </button>
                                </div>
                            </div>

                            {/* Ticker Prediction Cards */}
                            {predictionData?.tickers && Object.entries(predictionData.tickers).map(([ticker, data]) => (
                                <div key={ticker} className="bg-gray-800/50 rounded-xl p-3">
                                    {data.error ? (
                                        <div className="text-xs text-red-400">{data.error}</div>
                                    ) : (
                                        <>
                                            {/* Header with ticker and today's action */}
                                            <div className="flex items-center justify-between mb-3">
                                                <div className="flex items-center gap-2">
                                                    <span className="text-lg font-bold">{ticker}</span>
                                                    <span className="text-sm text-gray-400">${data.price}</span>
                                                    <span className={`text-xs px-2 py-0.5 rounded ${
                                                        data.todayColor === 'GREEN' ? 'bg-green-500/20 text-green-400' :
                                                        data.todayColor === 'RED' ? 'bg-red-500/20 text-red-400' :
                                                        'bg-gray-500/20 text-gray-400'
                                                    }`}>
                                                        {data.dayChange} today
                                                    </span>
                                                </div>
                                                <span className={`text-xs px-2 py-0.5 rounded font-semibold ${
                                                    data.confidence === 'HIGH' ? 'bg-green-500/20 text-green-400' :
                                                    data.confidence === 'MEDIUM' ? 'bg-yellow-500/20 text-yellow-400' :
                                                    'bg-gray-500/20 text-gray-400'
                                                }`}>
                                                    {data.historicalMatches} matches ({data.confidence})
                                                </span>
                                            </div>

                                            {/* Prediction Cards - Open & Close */}
                                            <div className="grid grid-cols-2 gap-3 mb-3">
                                                {/* Open Prediction */}
                                                <div className={`p-3 rounded-lg ${
                                                    data.prediction.open.prediction === 'GAP UP' ? 'bg-green-500/10 border border-green-500/30' :
                                                    data.prediction.open.prediction === 'GAP DOWN' ? 'bg-red-500/10 border border-red-500/30' :
                                                    'bg-gray-700/50 border border-gray-600/30'
                                                }`}>
                                                    <div className="text-xs text-gray-400 mb-1">Tomorrow's Open</div>
                                                    <div className={`text-xl font-bold ${
                                                        data.prediction.open.prediction === 'GAP UP' ? 'text-green-400' :
                                                        data.prediction.open.prediction === 'GAP DOWN' ? 'text-red-400' :
                                                        'text-gray-400'
                                                    }`}>
                                                        {data.prediction.open.prediction === 'GAP UP' ? 'üìà' :
                                                         data.prediction.open.prediction === 'GAP DOWN' ? 'üìâ' : '‚ûñ'}
                                                        {' '}{data.prediction.open.prediction}
                                                    </div>
                                                    <div className="flex items-center gap-2 mt-2">
                                                        <div className="flex-1 bg-gray-700 rounded-full h-2 overflow-hidden">
                                                            <div className="h-2 bg-green-500 rounded-l" style={{ width: `${data.prediction.open.gapUp}%` }}></div>
                                                        </div>
                                                    </div>
                                                    <div className="flex justify-between text-xs mt-1">
                                                        <span className="text-green-400">‚Üë {data.prediction.open.gapUp}%</span>
                                                        <span className="text-red-400">‚Üì {data.prediction.open.gapDown}%</span>
                                                    </div>
                                                </div>

                                                {/* Close Prediction */}
                                                <div className={`p-3 rounded-lg ${
                                                    data.prediction.close.prediction === 'GREEN' ? 'bg-green-500/10 border border-green-500/30' :
                                                    data.prediction.close.prediction === 'RED' ? 'bg-red-500/10 border border-red-500/30' :
                                                    'bg-gray-700/50 border border-gray-600/30'
                                                }`}>
                                                    <div className="text-xs text-gray-400 mb-1">Tomorrow's Close</div>
                                                    <div className={`text-xl font-bold ${
                                                        data.prediction.close.prediction === 'GREEN' ? 'text-green-400' :
                                                        data.prediction.close.prediction === 'RED' ? 'text-red-400' :
                                                        'text-gray-400'
                                                    }`}>
                                                        {data.prediction.close.prediction === 'GREEN' ? 'üü¢' :
                                                         data.prediction.close.prediction === 'RED' ? 'üî¥' : '‚ö™'}
                                                        {' '}{data.prediction.close.prediction}
                                                    </div>
                                                    <div className="flex items-center gap-2 mt-2">
                                                        <div className="flex-1 bg-gray-700 rounded-full h-2 overflow-hidden">
                                                            <div className="h-2 bg-green-500 rounded-l" style={{ width: `${data.prediction.close.green}%` }}></div>
                                                        </div>
                                                    </div>
                                                    <div className="flex justify-between text-xs mt-1">
                                                        <span className="text-green-400">üü¢ {data.prediction.close.green}%</span>
                                                        <span className="text-red-400">üî¥ {data.prediction.close.red}%</span>
                                                    </div>
                                                </div>
                                            </div>

                                            {/* Signals Grid */}
                                            <div className="mb-3">
                                                <div className="text-xs text-gray-400 mb-2">Signals Detected:</div>
                                                <div className="flex flex-wrap gap-1">
                                                    {data.signals.map((signal, i) => (
                                                        <span
                                                            key={i}
                                                            className={`text-xs px-2 py-0.5 rounded ${
                                                                signal.bias === 'bullish' ? 'bg-green-500/20 text-green-400' :
                                                                signal.bias === 'bearish' ? 'bg-red-500/20 text-red-400' :
                                                                'bg-gray-500/20 text-gray-400'
                                                            }`}
                                                        >
                                                            {signal.signal} {signal.value && `(${signal.value})`}
                                                        </span>
                                                    ))}
                                                </div>
                                            </div>

                                            {/* Quick Stats Row */}
                                            <div className="grid grid-cols-5 gap-1 text-center text-xs">
                                                <div className="bg-gray-900/50 rounded p-1.5">
                                                    <div className={`font-bold ${
                                                        parseFloat(data.rsi) < 30 ? 'text-green-400' :
                                                        parseFloat(data.rsi) > 70 ? 'text-red-400' : 'text-gray-300'
                                                    }`}>{data.rsi}</div>
                                                    <div className="text-gray-500">RSI</div>
                                                </div>
                                                <div className="bg-gray-900/50 rounded p-1.5">
                                                    <div className="font-bold text-gray-300">{data.volumeRatio}</div>
                                                    <div className="text-gray-500">Vol</div>
                                                </div>
                                                <div className="bg-gray-900/50 rounded p-1.5">
                                                    <div className={`font-bold ${data.consecutiveRed > 0 ? 'text-red-400' : data.consecutiveGreen > 0 ? 'text-green-400' : 'text-gray-300'}`}>
                                                        {data.consecutiveRed > 0 ? `-${data.consecutiveRed}` : data.consecutiveGreen > 0 ? `+${data.consecutiveGreen}` : '0'}
                                                    </div>
                                                    <div className="text-gray-500">Streak</div>
                                                </div>
                                                <div className="bg-gray-900/50 rounded p-1.5">
                                                    <div className="font-bold text-gray-300">{data.candlePattern !== 'none' ? data.candlePattern.split('_')[0] : '-'}</div>
                                                    <div className="text-gray-500">Pattern</div>
                                                </div>
                                                <div className="bg-gray-900/50 rounded p-1.5">
                                                    <div className={`font-bold ${data.closeAboveVwap ? 'text-green-400' : 'text-red-400'}`}>
                                                        {data.closeAboveVwap ? '‚Üë' : '‚Üì'}
                                                    </div>
                                                    <div className="text-gray-500">VWAP</div>
                                                </div>
                                            </div>

                                            {/* Recent Similar Matches */}
                                            {data.recentMatches && data.recentMatches.length > 0 && (
                                                <div className="mt-3 pt-3 border-t border-gray-700">
                                                    <div className="text-xs text-gray-400 mb-2">Recent Similar Setups:</div>
                                                    <div className="space-y-1">
                                                        {data.recentMatches.slice(0, 3).map((match, i) => (
                                                            <div key={i} className="flex justify-between text-xs bg-gray-900/30 rounded px-2 py-1">
                                                                <span className="text-gray-500">{match.date}</span>
                                                                <span className="text-gray-400">Gap: {match.nextDayGap}</span>
                                                                <span className={match.nextDayClose === 'GREEN' ? 'text-green-400' : 'text-red-400'}>
                                                                    {match.nextDayClose} {match.nextDayMove}
                                                                </span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                        </>
                                    )}
                                </div>
                            ))}

                            {/* Empty State */}
                            {!predictionData && !predictionLoading && (
                                <div className="text-center py-8 text-gray-500">
                                    <div className="text-3xl mb-2">üîÆ</div>
                                    <div className="text-sm">Hit <span className="font-bold text-purple-400">Predict</span> to analyze next day probability</div>
                                    <div className="text-xs mt-2">Uses 6 months of historical pattern matching</div>
                                </div>
                            )}

                            {/* Loading State */}
                            {predictionLoading && (
                                <div className="text-center py-8">
                                    <div className="text-3xl mb-2 animate-pulse">üîÆ</div>
                                    <div className="text-sm text-gray-400">Analyzing historical patterns...</div>
                                </div>
                            )}

                            {/* Disclaimer */}
                            <div className="bg-purple-500/10 border border-purple-500/20 rounded-xl p-3 text-xs text-purple-400/80">
                                <div className="font-semibold mb-1">‚ö†Ô∏è How This Works:</div>
                                <ul className="space-y-1 text-purple-400/60">
                                    <li>‚Ä¢ Finds similar setups in the last 6 months (RSI, trend, streak, move size)</li>
                                    <li>‚Ä¢ Shows what happened the NEXT day in those cases</li>
                                    <li>‚Ä¢ Not a crystal ball - probabilities shift with more data</li>
                                    <li>‚Ä¢ Best used alongside IV scanner for morning plays</li>
                                </ul>
                            </div>
                        </div>
                    )}

                    {/* Rocket Scanner View */}
                    {activeEdgeView === 'rockets' && (
                        <div className="space-y-3">
                            {/* Header with Timeframe & Scan Button */}
                            <div className="flex items-center justify-between">
                                <div>
                                    <span className="text-sm font-semibold">Rocket Scanner</span>
                                    <p className="text-xs text-gray-500">Confluence Detection ‚Ä¢ 9 Indicators</p>
                                </div>
                                <div className="flex gap-2 items-center">
                                    {/* Timeframe Selector - Like Indicator Suite */}
                                    <div className="flex bg-gray-800 rounded-lg p-0.5">
                                        {['daily', 'weekly'].map(tf => (
                                            <button
                                                key={tf}
                                                onClick={() => {
                                                    setRocketTimeframe(tf);
                                                    setRocketData(null);
                                                    fetchRockets(tf);
                                                }}
                                                className={`px-2 py-1 text-xs font-semibold rounded transition-colors ${
                                                    rocketTimeframe === tf
                                                        ? 'bg-blue-600 text-white'
                                                        : 'text-gray-400 hover:text-white'
                                                }`}
                                            >
                                                {tf === 'daily' ? 'D' : 'W'}
                                            </button>
                                        ))}
                                    </div>
                                    <button
                                        onClick={() => setShowBacktest(!showBacktest)}
                                        className="text-xs px-2 py-1 bg-purple-600/20 text-purple-400 hover:bg-purple-600/30 rounded-lg"
                                    >
                                        üìä
                                    </button>
                                    <button
                                        onClick={fetchRockets}
                                        disabled={loading}
                                        className="text-xs px-3 py-1 bg-gradient-to-r from-blue-600 to-cyan-500 hover:from-blue-500 hover:to-cyan-400 rounded-lg font-semibold"
                                    >
                                        {loading ? '‚è≥' : 'üîÑ'}
                                    </button>
                                </div>
                            </div>

                            {/* Signal Row - Startup.io Style */}
                            {rocketData && (
                                <div className="bg-gray-900 rounded-xl p-3 border border-gray-700">
                                    <div className="text-xs text-gray-500 mb-2 font-semibold">SIGNAL ROW</div>
                                    <div className="flex flex-wrap gap-2">
                                        {rocketData.map(stock => (
                                            <div
                                                key={stock.ticker}
                                                className={`px-2 py-1 rounded-lg text-xs font-semibold flex items-center gap-1 ${
                                                    stock.rocket
                                                        ? stock.rocket.includes('blue')
                                                            ? 'bg-blue-500/30 text-blue-300 border border-blue-500/50'
                                                            : 'bg-red-500/30 text-red-300 border border-red-500/50'
                                                        : stock.bullScore > stock.bearScore
                                                            ? 'bg-gray-800 text-gray-400 border border-green-500/20'
                                                            : stock.bearScore > stock.bullScore
                                                                ? 'bg-gray-800 text-gray-400 border border-red-500/20'
                                                                : 'bg-gray-800 text-gray-500 border border-gray-700'
                                                }`}
                                            >
                                                {stock.rocket ? (
                                                    <span style={stock.rocket.includes('red') ? {transform: 'rotate(180deg)', display: 'inline-block'} : {}}>
                                                        üöÄ
                                                    </span>
                                                ) : (
                                                    <span className={stock.bullScore > stock.bearScore ? 'text-green-500' : stock.bearScore > stock.bullScore ? 'text-red-500' : 'text-gray-600'}>
                                                        ‚óÜ
                                                    </span>
                                                )}
                                                {stock.ticker}
                                            </div>
                                        ))}
                                    </div>
                                    <div className="flex gap-4 mt-2 text-xs text-gray-500">
                                        <span>üöÄ = Active Rocket (3+ signals)</span>
                                        <span className="text-green-500">‚óÜ</span><span>= Bullish Lean</span>
                                        <span className="text-red-500">‚óÜ</span><span>= Bearish Lean</span>
                                    </div>
                                </div>
                            )}

                            {/* Backtest Panel */}
                            {showBacktest && (
                                <div className="bg-purple-500/10 border border-purple-500/30 rounded-xl p-4">
                                    <div className="flex items-center justify-between mb-3">
                                        <div className="text-sm font-semibold text-purple-400">üìä Backtest Rocket Scanner</div>
                                        <button onClick={() => setShowBacktest(false)} className="text-gray-400 hover:text-white">√ó</button>
                                    </div>

                                    {/* Backtest Input */}
                                    <div className="flex gap-2 mb-3">
                                        <input
                                            type="text"
                                            placeholder="Enter ticker (e.g. LPTH)"
                                            className="flex-1 px-3 py-2 bg-gray-800 border border-gray-600 rounded-lg text-sm"
                                            id="backtestTicker"
                                            defaultValue="SPY"
                                        />
                                        <button
                                            onClick={() => {
                                                const ticker = document.getElementById('backtestTicker').value.toUpperCase();
                                                runBacktest(ticker);
                                            }}
                                            disabled={backtestLoading}
                                            className="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded-lg text-sm font-semibold disabled:opacity-50"
                                        >
                                            {backtestLoading ? 'Testing...' : 'Run Backtest'}
                                        </button>
                                    </div>

                                    {/* Backtest Results */}
                                    {backtestLoading && (
                                        <div className="text-center py-4 text-gray-400 text-sm">
                                            Analyzing 1 year of historical data...
                                        </div>
                                    )}

                                    {backtestResults && !backtestResults.error && (
                                        <div className="space-y-3">
                                            {/* Summary */}
                                            <div className="grid grid-cols-3 gap-2 text-center">
                                                <div className="bg-gray-800/50 rounded-lg p-2">
                                                    <div className="text-lg font-bold">{backtestResults.totalSignals}</div>
                                                    <div className="text-xs text-gray-400">Total Signals</div>
                                                </div>
                                                <div className="bg-blue-500/20 rounded-lg p-2">
                                                    <div className="text-lg font-bold text-blue-400">{backtestResults.blueCount}</div>
                                                    <div className="text-xs text-gray-400">üöÄ Blue</div>
                                                </div>
                                                <div className="bg-red-500/20 rounded-lg p-2">
                                                    <div className="text-lg font-bold text-red-400">{backtestResults.redCount}</div>
                                                    <div className="text-xs text-gray-400">üöÄ Red</div>
                                                </div>
                                            </div>

                                            {/* Blue Rocket Performance */}
                                            {backtestResults.blueCount > 0 && (
                                                <div className="bg-blue-500/10 rounded-lg p-3">
                                                    <div className="text-xs font-semibold text-blue-400 mb-2">üöÄ Blue Rocket Performance</div>
                                                    <div className="grid grid-cols-3 gap-2 text-xs">
                                                        <div>
                                                            <div className="text-gray-400">1 Day</div>
                                                            <div className={backtestResults.blue.day1.winRate >= 50 ? 'text-green-400' : 'text-red-400'}>
                                                                {backtestResults.blue.day1.winRate.toFixed(0)}% win
                                                            </div>
                                                            <div className="text-gray-500">{backtestResults.blue.day1.avgReturn >= 0 ? '+' : ''}{backtestResults.blue.day1.avgReturn.toFixed(2)}% avg</div>
                                                        </div>
                                                        <div>
                                                            <div className="text-gray-400">5 Days</div>
                                                            <div className={backtestResults.blue.day5.winRate >= 50 ? 'text-green-400' : 'text-red-400'}>
                                                                {backtestResults.blue.day5.winRate.toFixed(0)}% win
                                                            </div>
                                                            <div className="text-gray-500">{backtestResults.blue.day5.avgReturn >= 0 ? '+' : ''}{backtestResults.blue.day5.avgReturn.toFixed(2)}% avg</div>
                                                        </div>
                                                        <div>
                                                            <div className="text-gray-400">10 Days</div>
                                                            <div className={backtestResults.blue.day10.winRate >= 50 ? 'text-green-400' : 'text-red-400'}>
                                                                {backtestResults.blue.day10.winRate.toFixed(0)}% win
                                                            </div>
                                                            <div className="text-gray-500">{backtestResults.blue.day10.avgReturn >= 0 ? '+' : ''}{backtestResults.blue.day10.avgReturn.toFixed(2)}% avg</div>
                                                        </div>
                                                    </div>
                                                </div>
                                            )}

                                            {/* Red Rocket Performance */}
                                            {backtestResults.redCount > 0 && (
                                                <div className="bg-red-500/10 rounded-lg p-3">
                                                    <div className="text-xs font-semibold text-red-400 mb-2" style={{display: 'flex', alignItems: 'center', gap: '4px'}}>
                                                        <span style={{transform: 'rotate(180deg)', display: 'inline-block'}}>üöÄ</span> Red Rocket Performance
                                                    </div>
                                                    <div className="grid grid-cols-3 gap-2 text-xs">
                                                        <div>
                                                            <div className="text-gray-400">1 Day</div>
                                                            <div className={backtestResults.red.day1.winRate >= 50 ? 'text-green-400' : 'text-red-400'}>
                                                                {backtestResults.red.day1.winRate.toFixed(0)}% win
                                                            </div>
                                                            <div className="text-gray-500">{backtestResults.red.day1.avgReturn >= 0 ? '+' : ''}{backtestResults.red.day1.avgReturn.toFixed(2)}% avg</div>
                                                        </div>
                                                        <div>
                                                            <div className="text-gray-400">5 Days</div>
                                                            <div className={backtestResults.red.day5.winRate >= 50 ? 'text-green-400' : 'text-red-400'}>
                                                                {backtestResults.red.day5.winRate.toFixed(0)}% win
                                                            </div>
                                                            <div className="text-gray-500">{backtestResults.red.day5.avgReturn >= 0 ? '+' : ''}{backtestResults.red.day5.avgReturn.toFixed(2)}% avg</div>
                                                        </div>
                                                        <div>
                                                            <div className="text-gray-400">10 Days</div>
                                                            <div className={backtestResults.red.day10.winRate >= 50 ? 'text-green-400' : 'text-red-400'}>
                                                                {backtestResults.red.day10.winRate.toFixed(0)}% win
                                                            </div>
                                                            <div className="text-gray-500">{backtestResults.red.day10.avgReturn >= 0 ? '+' : ''}{backtestResults.red.day10.avgReturn.toFixed(2)}% avg</div>
                                                        </div>
                                                    </div>
                                                </div>
                                            )}

                                            {/* Recent Signals */}
                                            {backtestResults.recentSignals?.length > 0 && (
                                                <div>
                                                    <div className="text-xs text-gray-400 mb-2">Recent Signals (last 10)</div>
                                                    <div className="space-y-1 max-h-40 overflow-y-auto">
                                                        {backtestResults.recentSignals.map((sig, idx) => (
                                                            <div key={idx} className="flex items-center justify-between text-xs bg-gray-800/50 rounded px-2 py-1">
                                                                <div className="flex items-center gap-2">
                                                                    <span style={sig.type === 'red' ? {transform: 'rotate(180deg)', display: 'inline-block'} : {}}>üöÄ</span>
                                                                    <span>{sig.date}</span>
                                                                    <span className="text-gray-500">${sig.price.toFixed(2)}</span>
                                                                </div>
                                                                <div className="flex gap-2">
                                                                    <span className={sig.return5D >= 0 ? 'text-green-400' : 'text-red-400'}>
                                                                        5D: {sig.return5D?.toFixed(1)}%
                                                                    </span>
                                                                    <span className={sig.win5D ? 'text-green-400' : 'text-red-400'}>
                                                                        {sig.win5D ? '‚úì' : '‚úó'}
                                                                    </span>
                                                                </div>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    )}

                                    {backtestResults?.error && (
                                        <div className="text-red-400 text-sm text-center py-2">
                                            Error: {backtestResults.error}
                                        </div>
                                    )}

                                    <div className="text-xs text-gray-500 mt-2">
                                        Tests 1 year of historical data. Win = price moved in predicted direction.
                                    </div>
                                </div>
                            )}

                            {/* Add Custom Ticker - Compact */}
                            <div className="flex items-center gap-2 bg-gray-800/30 rounded-lg p-2">
                                <span className="text-xs text-gray-500">Add:</span>
                                <input
                                    type="text"
                                    value={newTickerInput}
                                    onChange={(e) => setNewTickerInput(e.target.value.toUpperCase())}
                                    onKeyDown={(e) => e.key === 'Enter' && addCustomTicker(newTickerInput)}
                                    placeholder="TICKER"
                                    className="w-20 px-2 py-1 bg-gray-700 border border-gray-600 rounded text-sm text-center focus:border-blue-500 focus:outline-none"
                                    maxLength={5}
                                />
                                <button
                                    onClick={() => addCustomTicker(newTickerInput)}
                                    className="px-3 py-1 bg-blue-600 hover:bg-blue-500 rounded text-xs font-semibold"
                                >
                                    + Add & Scan
                                </button>
                                <div className="flex-1 flex flex-wrap gap-1 ml-2">
                                    {customRocketTickers.map(ticker => (
                                        <span
                                            key={ticker}
                                            className="inline-flex items-center gap-1 px-1.5 py-0.5 bg-cyan-500/20 text-cyan-400 rounded text-xs"
                                        >
                                            {ticker}
                                            <button
                                                onClick={() => removeCustomTicker(ticker)}
                                                className="hover:text-red-400"
                                            >
                                                √ó
                                            </button>
                                        </span>
                                    ))}
                                </div>
                                <span className="text-xs text-gray-500">{ROCKET_SCAN_TICKERS.length} total</span>
                            </div>

                            {loading && !rocketData ? (
                                <div className="text-center py-8 text-gray-500">
                                    <div className="text-2xl mb-2">üöÄ</div>
                                    Scanning {ROCKET_SCAN_TICKERS.length} tickers for confluence...
                                </div>
                            ) : rocketData ? (
                                <div className="space-y-2">
                                    {/* Rocket Alerts - Only show stocks with rockets */}
                                    {rocketData.filter(s => s.rocket).length > 0 && (
                                        <div className="mb-4">
                                            <div className="text-xs text-gray-400 mb-2 font-semibold">üö® ACTIVE ROCKETS</div>
                                            <div className="space-y-2">
                                                {rocketData.filter(s => s.rocket).map(stock => (
                                                    <div
                                                        key={stock.ticker}
                                                        onClick={() => openChartView(stock.ticker)}
                                                        className={`p-4 rounded-xl border cursor-pointer hover:scale-[1.01] transition-transform ${
                                                            stock.rocket.includes('blue')
                                                                ? 'bg-blue-500/10 border-blue-500/50 hover:border-blue-400'
                                                                : 'bg-red-500/10 border-red-500/50 hover:border-red-400'
                                                        }`}
                                                    >
                                                        <div className="flex items-center justify-between mb-2">
                                                            <div className="flex items-center gap-2">
                                                                <span
                                                                    className={`text-2xl ${stock.rocket.includes('strong') ? 'animate-pulse' : ''}`}
                                                                    style={stock.rocket.includes('red') ? {transform: 'rotate(180deg)', display: 'inline-block'} : {}}
                                                                >
                                                                    üöÄ
                                                                </span>
                                                                <div>
                                                                    <div className="font-bold text-lg">{stock.ticker}</div>
                                                                    <div className={`text-xs ${stock.rocket.includes('blue') ? 'text-blue-400' : 'text-red-400'}`}>
                                                                        {stock.rocket.includes('strong') ? 'STRONG ' : ''}
                                                                        {stock.rocket.includes('blue') ? 'BULLISH' : 'BEARISH'} CONFLUENCE
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            <div className="text-right">
                                                                <div className="font-bold">${stock.price.toFixed(2)}</div>
                                                                <div className={`text-sm ${stock.change >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                                    {stock.change >= 0 ? '+' : ''}{stock.change.toFixed(2)}%
                                                                </div>
                                                            </div>
                                                        </div>
                                                        {/* Signal Breakdown */}
                                                        <div className="grid grid-cols-2 gap-1 mt-2">
                                                            {(stock.rocket.includes('blue') ? stock.bullishSignals : stock.bearishSignals).map((signal, idx) => (
                                                                <div key={idx} className="text-xs bg-gray-800/50 px-2 py-1 rounded flex items-center gap-1">
                                                                    <span className={stock.rocket.includes('blue') ? 'text-blue-400' : 'text-red-400'}>‚úì</span>
                                                                    {signal.name}
                                                                </div>
                                                            ))}
                                                        </div>
                                                        {/* Quick Stats */}
                                                        <div className="flex gap-4 mt-3 text-xs text-gray-400">
                                                            <span>RSI: {stock.rsi.toFixed(0)}</span>
                                                            <span>Vol: {stock.volumeRatio.toFixed(1)}x</span>
                                                            <span>Signals: {Math.max(stock.bullScore, stock.bearScore)}</span>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    )}

                                    {/* All Scanned Stocks - TradingView Style */}
                                    <div className="text-xs text-gray-400 mb-2 font-semibold">INDICATOR DASHBOARD ({rocketData.length} tickers) - Click for chart</div>
                                    <div className="space-y-2 max-h-96 overflow-y-auto">
                                        {rocketData.map(stock => (
                                            <div
                                                key={stock.ticker}
                                                onClick={() => openChartView(stock.ticker)}
                                                className={`p-3 rounded-xl border cursor-pointer hover:scale-[1.01] transition-transform ${
                                                    stock.rocket
                                                        ? stock.rocket.includes('blue')
                                                            ? 'bg-blue-500/10 border-blue-500/40 hover:border-blue-400'
                                                            : 'bg-red-500/10 border-red-500/40 hover:border-red-400'
                                                        : 'bg-gray-800/50 border-gray-700/50 hover:border-gray-500'
                                                }`}
                                            >
                                                {/* Header Row */}
                                                <div className="flex items-center justify-between mb-2">
                                                    <div className="flex items-center gap-2">
                                                        {stock.rocket ? (
                                                            <span
                                                                className={`text-xl ${stock.rocket.includes('strong') ? 'animate-pulse' : ''}`}
                                                                style={stock.rocket.includes('red') ? {transform: 'rotate(180deg)', display: 'inline-block'} : {}}
                                                            >
                                                                üöÄ
                                                            </span>
                                                        ) : (
                                                            <span className="text-xl text-gray-600">‚óØ</span>
                                                        )}
                                                        <span className="font-bold text-base">{stock.ticker}</span>
                                                        <span className="text-gray-400 text-sm">${stock.price.toFixed(2)}</span>
                                                        <span className="text-xs text-gray-500">üìà</span>
                                                    </div>
                                                    <div className="flex items-center gap-2">
                                                        <span className={`font-semibold ${stock.change >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                            {stock.change >= 0 ? '+' : ''}{stock.change.toFixed(2)}%
                                                        </span>
                                                        <div className="flex gap-1 text-xs">
                                                            <span className="bg-blue-500/30 text-blue-400 px-1.5 py-0.5 rounded">{stock.bullScore}‚Üë</span>
                                                            <span className="bg-red-500/30 text-red-400 px-1.5 py-0.5 rounded">{stock.bearScore}‚Üì</span>
                                                        </div>
                                                    </div>
                                                </div>

                                                {/* Indicator Grid - TradingView Style */}
                                                <div className="grid grid-cols-4 gap-1 text-xs">
                                                    {/* RSI */}
                                                    <div className={`px-2 py-1 rounded text-center ${
                                                        stock.rsi < 30 ? 'bg-green-500/30 text-green-400' :
                                                        stock.rsi > 70 ? 'bg-red-500/30 text-red-400' :
                                                        'bg-gray-700/50 text-gray-400'
                                                    }`}>
                                                        <div className="font-semibold">RSI</div>
                                                        <div>{stock.rsi.toFixed(0)}</div>
                                                    </div>

                                                    {/* Volume */}
                                                    <div className={`px-2 py-1 rounded text-center ${
                                                        stock.volumeRatio > 2
                                                            ? stock.change >= 0 ? 'bg-green-500/30 text-green-400' : 'bg-red-500/30 text-red-400'
                                                            : 'bg-gray-700/50 text-gray-400'
                                                    }`}>
                                                        <div className="font-semibold">VOL</div>
                                                        <div>{stock.volumeRatio.toFixed(1)}x</div>
                                                    </div>

                                                    {/* SMA Trend */}
                                                    <div className={`px-2 py-1 rounded text-center ${
                                                        stock.sma20 > stock.sma50 ? 'bg-green-500/30 text-green-400' : 'bg-red-500/30 text-red-400'
                                                    }`}>
                                                        <div className="font-semibold">TREND</div>
                                                        <div>{stock.sma20 > stock.sma50 ? '‚Üë Bull' : '‚Üì Bear'}</div>
                                                    </div>

                                                    {/* Signal Strength */}
                                                    <div className={`px-2 py-1 rounded text-center ${
                                                        Math.max(stock.bullScore, stock.bearScore) >= 4 ? 'bg-purple-500/30 text-purple-400' :
                                                        Math.max(stock.bullScore, stock.bearScore) >= 3 ? 'bg-yellow-500/30 text-yellow-400' :
                                                        Math.max(stock.bullScore, stock.bearScore) >= 2 ? 'bg-blue-500/30 text-blue-400' :
                                                        'bg-gray-700/50 text-gray-400'
                                                    }`}>
                                                        <div className="font-semibold">STR</div>
                                                        <div>{Math.max(stock.bullScore, stock.bearScore)}/8</div>
                                                    </div>
                                                </div>

                                                {/* Active Signals */}
                                                {(stock.bullScore > 0 || stock.bearScore > 0) && (
                                                    <div className="flex flex-wrap gap-1 mt-2">
                                                        {stock.bullishSignals.map((sig, idx) => (
                                                            <span key={`bull-${idx}`} className="text-xs bg-green-500/20 text-green-400 px-1.5 py-0.5 rounded">
                                                                {sig.name}
                                                            </span>
                                                        ))}
                                                        {stock.bearishSignals.map((sig, idx) => (
                                                            <span key={`bear-${idx}`} className="text-xs bg-red-500/20 text-red-400 px-1.5 py-0.5 rounded">
                                                                {sig.name}
                                                            </span>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                    </div>

                                    {rocketData.filter(s => s.rocket).length === 0 && (
                                        <div className="text-center py-4 text-gray-500 text-sm">
                                            No rockets detected right now. Check back later or add more tickers.
                                        </div>
                                    )}
                                </div>
                            ) : (
                                <div className="text-center py-8 text-gray-500">
                                    Click Scan to detect confluence signals
                                </div>
                            )}

                            {/* Info */}
                            <div className="bg-gray-800/30 rounded-lg p-3 text-xs text-gray-500">
                                <div className="font-semibold mb-1">How Rockets Work:</div>
                                <div>Scans for confluence of: Volume Surge, RSI, SMA Bounces, Golden/Death Cross, Gaps, 52W Highs/Lows, Momentum, Breakouts</div>
                                <div className="mt-1">üöÄ Blue Rocket = 3+ bullish signals aligned (launching up!)</div>
                                <div><span style={{transform: 'rotate(180deg)', display: 'inline-block'}}>üöÄ</span> Red Rocket = 3+ bearish signals aligned (crash landing)</div>
                            </div>

                            {/* Chart Modal with TradingView */}
                            {selectedChartTicker && (
                                <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
                                    <div className="bg-gray-900 rounded-2xl w-full max-w-4xl max-h-[90vh] overflow-hidden border border-gray-700">
                                        {/* Modal Header */}
                                        <div className="flex items-center justify-between p-4 border-b border-gray-700">
                                            <div className="flex items-center gap-3">
                                                <span className="text-2xl">üìà</span>
                                                <div>
                                                    <div className="font-bold text-xl">{selectedChartTicker}</div>
                                                    <div className="text-xs text-gray-400">Rocket Signal History</div>
                                                </div>
                                            </div>
                                            <button
                                                onClick={() => setSelectedChartTicker(null)}
                                                className="text-gray-400 hover:text-white text-2xl px-2"
                                            >
                                                √ó
                                            </button>
                                        </div>

                                        {/* Lightweight Chart with Rocket Markers */}
                                        <div className="h-80 bg-gray-900 relative">
                                            <RocketChart ticker={selectedChartTicker} signals={chartSignalHistory} timeframe={rocketTimeframe} />
                                        </div>

                                        {/* Signal Timeline - Visual representation */}
                                        <div className="px-4 py-2 bg-gray-800 border-t border-gray-700">
                                            <div className="text-xs text-gray-400 mb-2">ROCKET SIGNALS ON CHART (Look for these dates)</div>
                                            {chartSignalHistory && chartSignalHistory.length > 0 ? (
                                                <div className="flex gap-2 overflow-x-auto pb-2">
                                                    {chartSignalHistory.slice().reverse().map((sig, idx) => (
                                                        <div
                                                            key={idx}
                                                            className={`flex-shrink-0 px-3 py-2 rounded-lg text-center ${
                                                                sig.type === 'blue'
                                                                    ? 'bg-blue-500/30 border border-blue-500'
                                                                    : 'bg-red-500/30 border border-red-500'
                                                            }`}
                                                        >
                                                            <span
                                                                className="text-2xl block"
                                                                style={sig.type === 'red' ? {transform: 'rotate(180deg)', display: 'inline-block'} : {}}
                                                            >
                                                                üöÄ
                                                            </span>
                                                            <div className="text-xs font-bold mt-1">{sig.date}</div>
                                                            <div className="text-xs text-gray-400">${sig.price.toFixed(2)}</div>
                                                        </div>
                                                    ))}
                                                </div>
                                            ) : chartSignalHistory ? (
                                                <div className="text-gray-500 text-sm py-2">No signals in the last 6 months</div>
                                            ) : (
                                                <div className="text-gray-500 text-sm py-2">Loading signals...</div>
                                            )}
                                        </div>

                                        {/* Detailed Signal History */}
                                        <div className="p-4 max-h-40 overflow-y-auto">
                                            <div className="text-sm font-semibold mb-3 flex items-center gap-2">
                                                üìã Signal Details
                                            </div>

                                            {chartSignalHistory && chartSignalHistory.length > 0 && (
                                                <div className="space-y-2">
                                                    {chartSignalHistory.slice().reverse().map((sig, idx) => (
                                                        <div
                                                            key={idx}
                                                            className={`flex items-center justify-between p-2 rounded-lg ${
                                                                sig.type === 'blue' ? 'bg-blue-500/10' : 'bg-red-500/10'
                                                            }`}
                                                        >
                                                            <div className="flex items-center gap-2">
                                                                <span
                                                                    className="text-lg"
                                                                    style={sig.type === 'red' ? {transform: 'rotate(180deg)', display: 'inline-block'} : {}}
                                                                >
                                                                    üöÄ
                                                                </span>
                                                                <span className="font-semibold">{sig.date}</span>
                                                                <span className="text-gray-400">${sig.price.toFixed(2)}</span>
                                                            </div>
                                                            <div className="flex items-center gap-2">
                                                                <div className="flex gap-1">
                                                                    {sig.signals.map((s, i) => (
                                                                        <span
                                                                            key={i}
                                                                            className={`text-xs px-1.5 py-0.5 rounded ${
                                                                                sig.type === 'blue' ? 'bg-blue-500/30 text-blue-300' : 'bg-red-500/30 text-red-300'
                                                                            }`}
                                                                        >
                                                                            {s}
                                                                        </span>
                                                                    ))}
                                                                </div>
                                                                <span className={`text-xs font-semibold ${sig.type === 'blue' ? 'text-blue-400' : 'text-red-400'}`}>
                                                                    {sig.type === 'blue' ? 'BULLISH' : 'BEARISH'}
                                                                </span>
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>

                                        {/* Quick Actions */}
                                        <div className="p-4 border-t border-gray-700 flex gap-2">
                                            <button
                                                onClick={() => {
                                                    document.getElementById('backtestTicker').value = selectedChartTicker;
                                                    runBacktest(selectedChartTicker);
                                                    setSelectedChartTicker(null);
                                                    setShowBacktest(true);
                                                }}
                                                className="flex-1 py-2 bg-purple-600 hover:bg-purple-500 rounded-lg text-sm font-semibold"
                                            >
                                                üìä Run Full Backtest
                                            </button>
                                            <button
                                                onClick={() => window.open(`https://www.tradingview.com/chart/?symbol=${selectedChartTicker}`, '_blank')}
                                                className="flex-1 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm font-semibold"
                                            >
                                                üîó Open in TradingView
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {/* Scalper View - 5-Min Day Trade Signals */}
                    {activeEdgeView === 'scalper' && (
                        <div className="space-y-3">
                            {/* Header with Ticker Input */}
                            <div className="flex items-center justify-between gap-2">
                                <div>
                                    <span className="text-sm font-semibold">‚ö° Scalp Scanner</span>
                                    <p className="text-xs text-gray-500">Confluence Scalper Pro ‚Ä¢ 8 Factors</p>
                                </div>
                                <div className="flex gap-2 items-center flex-wrap">
                                    <div className="flex items-center gap-1">
                                        <span className="text-xs text-yellow-400 font-semibold">CHART:</span>
                                        <input
                                            id="scalp-ticker-input"
                                            type="text"
                                            defaultValue="SPY"
                                            style={{textTransform: 'uppercase'}}
                                            placeholder="TICKER"
                                            maxLength={5}
                                            className="w-20 px-2 py-1 text-sm bg-gray-900 border-2 border-yellow-500 rounded-lg text-center font-mono font-bold text-yellow-400"
                                        />
                                    </div>
                                    {/* Timeframe selector */}
                                    <div className="flex bg-gray-800 rounded-lg overflow-hidden border border-gray-600">
                                        {['1m', '5m', '15m'].map(tf => (
                                            <button
                                                key={tf}
                                                onClick={() => setScalpTimeframe(tf)}
                                                className={`px-2 py-1 text-xs font-semibold transition-colors ${
                                                    scalpTimeframe === tf
                                                        ? 'bg-yellow-600 text-white'
                                                        : 'text-gray-400 hover:text-white hover:bg-gray-700'
                                                }`}
                                            >
                                                {tf}
                                            </button>
                                        ))}
                                    </div>
                                    <button
                                        onClick={() => { const input = document.getElementById('scalp-ticker-input'); const ticker = input?.value?.toUpperCase()?.trim() || 'SPY'; currentChartTickerRef.current = ticker; fetchScalpData(ticker, false, scalpTimeframe); }}
                                        disabled={scalpLoading}
                                        className="text-xs px-3 py-1 bg-gradient-to-r from-yellow-600 to-orange-500 hover:from-yellow-500 hover:to-orange-400 rounded-lg font-semibold"
                                    >
                                        {scalpLoading ? '‚è≥' : 'üîç Scan'}
                                    </button>
                                    <button
                                        onClick={() => setScalpAlertsEnabled(!scalpAlertsEnabled)}
                                        className={`text-xs px-2 py-1 rounded-lg font-semibold transition-colors ${
                                            scalpAlertsEnabled
                                                ? 'bg-green-600 hover:bg-green-500 text-white'
                                                : 'bg-gray-700 hover:bg-gray-600 text-gray-400'
                                        }`}
                                        title={scalpAlertsEnabled ? 'Alerts ON - Click to disable' : 'Alerts OFF - Click to enable'}
                                    >
                                        {scalpAlertsEnabled ? 'üîî' : 'üîï'}
                                    </button>
                                    <button
                                        onClick={() => setSessionMarkersEnabled(!sessionMarkersEnabled)}
                                        className={`text-xs px-2 py-1 rounded-lg font-semibold transition-colors ${
                                            sessionMarkersEnabled
                                                ? 'bg-blue-600 hover:bg-blue-500 text-white'
                                                : 'bg-gray-700 hover:bg-gray-600 text-gray-400'
                                        }`}
                                        title={sessionMarkersEnabled ? 'Session lines ON' : 'Session lines OFF'}
                                    >
                                        üìç
                                    </button>
                                    <button
                                        onClick={() => setShowConfluenceSettings(!showConfluenceSettings)}
                                        className={`text-xs px-2 py-1 rounded-lg font-semibold transition-colors ${
                                            showConfluenceSettings
                                                ? 'bg-yellow-600 hover:bg-yellow-500 text-white'
                                                : 'bg-gray-700 hover:bg-gray-600 text-gray-400'
                                        }`}
                                        title="Confluence Settings"
                                    >
                                        ‚öôÔ∏è
                                    </button>
                                </div>
                            </div>

                            {/* Confluence Settings Panel */}
                            {showConfluenceSettings && (
                                <div className="bg-gray-800/80 rounded-lg p-3 border border-yellow-600/50 space-y-3">
                                    <div className="text-xs font-semibold text-green-400">v7 PURE + TIMING</div>
                                    <div className="text-xs text-gray-400 space-y-1">
                                        <div>Primary trigger: <span className="text-yellow-300">Level breakout/rejection required</span></div>
                                        <div>8 factors: EMA Cross, Stacked EMAs, MACD Flip, RSI Cross, BB Bounce, Vol Spike, ADX &gt; 25, 15m MTF</div>
                                    </div>

                                    <div className="border-t border-gray-700 pt-2">
                                        <div className="text-xs font-semibold text-red-400 mb-1">HARD GATES (always enforced, non-toggleable)</div>
                                        <div className="text-xs text-gray-500">Volume Spike + ADX &gt; 25 + MTF Agreement + Stacked EMAs + Level Event</div>
                                    </div>

                                    <div className="border-t border-gray-700 pt-2 flex gap-3 items-center flex-wrap">
                                        <label className="flex items-center gap-1 text-xs text-gray-300">
                                            Min Score:
                                            <select value={minConfluence} onChange={e => setMinConfluence(+e.target.value)}
                                                className="bg-gray-900 border border-gray-600 rounded px-1 py-0.5 text-xs text-yellow-400">
                                                {[2,3,4,5,6,7,8].map(n => <option key={n} value={n}>{n}</option>)}
                                            </select>
                                        </label>
                                        <label className="flex items-center gap-1 text-xs text-gray-300">
                                            Cooldown:
                                            <select value={minBarsBetween} onChange={e => setMinBarsBetween(+e.target.value)}
                                                className="bg-gray-900 border border-gray-600 rounded px-1 py-0.5 text-xs text-yellow-400">
                                                {[15,20,25,30,40,50].map(n => <option key={n} value={n}>{n} bars</option>)}
                                            </select>
                                        </label>
                                        <label className="flex items-center gap-2 text-xs">
                                            <input type="checkbox" checked={useRealTime}
                                                onChange={() => setUseRealTime(!useRealTime)} className="rounded" />
                                            <span className={useRealTime ? 'text-yellow-300' : 'text-gray-500'}>Real-Time</span>
                                        </label>
                                    </div>

                                    <div className="border-t border-gray-700 pt-2 flex gap-3 items-center flex-wrap">
                                        <label className="flex items-center gap-2 text-xs">
                                            <input type="checkbox" checked={showConfluenceTable}
                                                onChange={() => setShowConfluenceTable(!showConfluenceTable)} className="rounded" />
                                            <span className="text-gray-300">Table</span>
                                        </label>
                                        <label className="flex items-center gap-2 text-xs">
                                            <input type="checkbox" checked={showOverlays}
                                                onChange={() => setShowOverlays(!showOverlays)} className="rounded" />
                                            <span className="text-gray-300">EMA/BB</span>
                                        </label>
                                    </div>
                                </div>
                            )}

                            {/* Confluence Status Table */}
                            {showConfluenceTable && confluenceStatus && (
                                <div className="bg-gray-800/50 rounded-lg p-3 border border-gray-700">
                                    <div className="flex items-center justify-between mb-2">
                                        <span className="text-xs font-semibold text-yellow-400">CONFLUENCE STATUS</span>
                                        <div className="flex gap-3">
                                            <span className={`text-xs font-mono font-bold ${confluenceStatus.bullScore >= minConfluence ? 'text-green-400' : 'text-gray-500'}`}>
                                                BULL: {confluenceStatus.bullScore}/{confluenceStatus.maxScore}
                                            </span>
                                            <span className={`text-xs font-mono font-bold ${confluenceStatus.bearScore >= minConfluence ? 'text-red-400' : 'text-gray-500'}`}>
                                                BEAR: {confluenceStatus.bearScore}/{confluenceStatus.maxScore}
                                            </span>
                                        </div>
                                    </div>
                                    <table className="w-full text-xs">
                                        <thead>
                                            <tr className="text-gray-500 border-b border-gray-700">
                                                <th className="text-left py-1">Indicator</th>
                                                <th className="text-center py-1 text-green-400">Bull</th>
                                                <th className="text-center py-1 text-red-400">Bear</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {[
                                                ['EMA Trend', 'ema', true],
                                                ['Stacked EMAs', 'stacked', true],
                                                ['MACD+Signal', 'macd', true],
                                                ['RSI Zone', 'rsi', true],
                                                ['BB Position', 'bb', true],
                                                ['Vol > 1.2x', 'volume', true],
                                                ['ADX > 15', 'adx', true],
                                                ['15m MTF', 'mtf', true],
                                                ['Level', 'level', true],
                                                ['Gate', 'gate', true],
                                            ].map(([label, key, enabled]) => (
                                                <tr key={key} className="border-b border-gray-700/50">
                                                    <td className={`py-1 ${enabled ? 'text-gray-300' : 'text-gray-600 line-through'}`}>{label}</td>
                                                    <td className="text-center">
                                                        <span className={confluenceStatus.bull[key] && enabled ? 'text-green-400' : 'text-gray-600'}>
                                                            {confluenceStatus.bull[key] && enabled ? '‚úì' : '‚úó'}
                                                        </span>
                                                    </td>
                                                    <td className="text-center">
                                                        <span className={confluenceStatus.bear[key] && enabled ? 'text-red-400' : 'text-gray-600'}>
                                                            {confluenceStatus.bear[key] && enabled ? '‚úì' : '‚úó'}
                                                        </span>
                                                    </td>
                                                </tr>
                                            ))}
                                            <tr className="font-bold">
                                                <td className="py-1 text-white">SCORE</td>
                                                <td className={`text-center ${confluenceStatus.bullScore >= minConfluence ? 'text-green-400' : 'text-gray-500'}`}>
                                                    {confluenceStatus.bullScore}/{confluenceStatus.maxScore}
                                                </td>
                                                <td className={`text-center ${confluenceStatus.bearScore >= minConfluence ? 'text-red-400' : 'text-gray-500'}`}>
                                                    {confluenceStatus.bearScore}/{confluenceStatus.maxScore}
                                                </td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            )}

                            {/* Market Timer + Quick Scanners Row */}
                            <div className="grid grid-cols-3 gap-2">
                                {/* Market Close Timer */}
                                <div className="p-2 bg-gray-800/50 rounded-lg border border-gray-700 text-center">
                                    <div className="text-xs text-gray-500">Until Close</div>
                                    <div className={`text-lg font-mono font-bold ${
                                        marketCloseTime === 'CLOSED' ? 'text-red-400' :
                                        marketCloseTime.startsWith('OPENS') ? 'text-yellow-400' :
                                        marketCloseTime.startsWith('0:') ? 'text-red-400 animate-pulse' : 'text-green-400'
                                    }`}>
                                        {marketCloseTime || '--:--:--'}
                                    </div>
                                </div>

                                {/* Momentum Scanner Button */}
                                <button
                                    onClick={scanMomentum}
                                    disabled={momentumLoading}
                                    className="p-2 bg-gradient-to-r from-orange-600/20 to-red-600/20 hover:from-orange-600/40 hover:to-red-600/40 rounded-lg border border-orange-500/30 text-center transition-colors"
                                >
                                    <div className="text-xs text-orange-400 font-semibold">
                                        {momentumLoading ? '‚è≥' : 'üî•'} Momentum
                                    </div>
                                    <div className="text-xs text-gray-400">
                                        {momentumStocks.length > 0 ? `${momentumStocks.length} movers` : 'Scan now'}
                                    </div>
                                </button>

                                {/* Gapper Scanner Button */}
                                <button
                                    onClick={scanGappers}
                                    disabled={gapperLoading}
                                    className="p-2 bg-gradient-to-r from-purple-600/20 to-blue-600/20 hover:from-purple-600/40 hover:to-blue-600/40 rounded-lg border border-purple-500/30 text-center transition-colors"
                                >
                                    <div className="text-xs text-purple-400 font-semibold">
                                        {gapperLoading ? '‚è≥' : 'üìä'} Gappers
                                    </div>
                                    <div className="text-xs text-gray-400">
                                        {gapperStocks.length > 0 ? `${gapperStocks.length} gaps` : 'Scan now'}
                                    </div>
                                </button>
                            </div>

                            {/* Alert Watchlist - HIDDEN FOR NOW (confusing UI)
                            <div className="bg-gray-800/50 rounded-lg p-2 border border-gray-700">
                                <div className="flex items-center justify-between mb-2">
                                    <div className="text-xs text-green-400 font-semibold">üîî ALERT WATCHLIST</div>
                                    <span className="text-xs text-gray-500">{alertWatchlist.length} tickers</span>
                                </div>
                                <div className="flex gap-2 mb-2">
                                    <input
                                        type="text"
                                        value={watchlistInput}
                                        onChange={(e) => setWatchlistInput(e.target.value.toUpperCase())}
                                        onKeyDown={(e) => {
                                            if (e.key === 'Enter') {
                                                addToWatchlist(watchlistInput);
                                                setWatchlistInput('');
                                            }
                                        }}
                                        placeholder="+ add to alerts..."
                                        maxLength={5}
                                        className="flex-1 px-2 py-1 text-xs bg-gray-900 border border-green-600/50 rounded font-mono text-green-400"
                                    />
                                    <button
                                        onClick={() => { addToWatchlist(watchlistInput); setWatchlistInput(''); }}
                                        className="px-2 py-1 text-xs bg-green-600 hover:bg-green-500 rounded font-semibold"
                                    >
                                        + Add
                                    </button>
                                    <button
                                        onClick={() => addToWatchlist(scalpTicker)}
                                        className="px-2 py-1 text-xs bg-blue-600 hover:bg-blue-500 rounded font-semibold"
                                        title="Add current chart ticker"
                                    >
                                        + {scalpTicker}
                                    </button>
                                </div>
                                {alertWatchlist.length > 0 ? (
                                    <div className="flex flex-wrap gap-1">
                                        {alertWatchlist.map(ticker => (
                                            <div
                                                key={ticker}
                                                className="flex items-center gap-1 px-2 py-1 bg-green-900/30 border border-green-500/30 rounded text-xs"
                                            >
                                                <span className="font-mono font-bold text-green-400">{ticker}</span>
                                                <button
                                                    onClick={() => removeFromWatchlist(ticker)}
                                                    className="text-red-400 hover:text-red-300 font-bold"
                                                >
                                                    √ó
                                                </button>
                                            </div>
                                        ))}
                                    </div>
                                ) : (
                                    <div className="text-xs text-gray-500 text-center py-2">
                                        Add tickers to get alerted on their signals
                                    </div>
                                )}
                                <div className="text-xs text-gray-500 mt-2 text-center">
                                    Scans every 30 sec ‚Ä¢ Alerts only for watchlist tickers
                                </div>
                            </div>
                            */}

                            {/* Momentum Results */}
                            {momentumStocks.length > 0 && (
                                <div className="bg-orange-900/20 rounded-lg p-2 border border-orange-500/30">
                                    <div className="text-xs text-orange-400 font-semibold mb-2">üî• MOMENTUM MOVERS</div>
                                    <div className="grid grid-cols-2 gap-1 max-h-32 overflow-y-auto">
                                        {momentumStocks.slice(0, 8).map((stock, idx) => (
                                            <div
                                                key={idx}
                                                onClick={() => { setScalpTicker(stock.ticker); fetchScalpData(stock.ticker, false, scalpTimeframe); }}
                                                className={`p-1.5 rounded cursor-pointer hover:bg-gray-700/50 ${
                                                    stock.direction === 'up' ? 'bg-green-900/30' : 'bg-red-900/30'
                                                }`}
                                            >
                                                <div className="flex justify-between items-center">
                                                    <span className="text-xs font-bold">{stock.ticker}</span>
                                                    <span className={`text-xs font-mono ${stock.direction === 'up' ? 'text-green-400' : 'text-red-400'}`}>
                                                        {stock.direction === 'up' ? '+' : ''}{stock.change5}%
                                                    </span>
                                                </div>
                                                <div className="text-xs text-gray-500">
                                                    30m: {stock.change30}% | Vol: {stock.volSpike}x
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Gapper Results */}
                            {gapperStocks.length > 0 && (
                                <div className="bg-purple-900/20 rounded-lg p-2 border border-purple-500/30">
                                    <div className="text-xs text-purple-400 font-semibold mb-2">üìä GAP PLAYS</div>
                                    <div className="grid grid-cols-2 gap-1 max-h-32 overflow-y-auto">
                                        {gapperStocks.slice(0, 8).map((stock, idx) => (
                                            <div
                                                key={idx}
                                                onClick={() => { setScalpTicker(stock.ticker); fetchScalpData(stock.ticker, false, scalpTimeframe); }}
                                                className={`p-1.5 rounded cursor-pointer hover:bg-gray-700/50 ${
                                                    stock.direction === 'up' ? 'bg-green-900/30' : 'bg-red-900/30'
                                                }`}
                                            >
                                                <div className="flex justify-between items-center">
                                                    <span className="text-xs font-bold">{stock.ticker}</span>
                                                    <span className={`text-xs font-mono ${stock.direction === 'up' ? 'text-green-400' : 'text-red-400'}`}>
                                                        {stock.direction === 'up' ? '+' : ''}{stock.gap}%
                                                    </span>
                                                </div>
                                                <div className="text-xs text-gray-500">
                                                    Fill: {stock.gapFill}% | ${stock.current}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}


                            {/* Key Levels Display */}
                            {scalpData?.levels && Object.keys(scalpData.levels).length > 0 && (
                                <div className="grid grid-cols-4 gap-2 text-xs">
                                    {scalpData.levels.PDH && (
                                        <div className="p-2 bg-red-900/20 border border-red-500/30 rounded-lg text-center">
                                            <div className="text-gray-500">PDH</div>
                                            <div className="text-red-400 font-mono">${scalpData.levels.PDH.toFixed(2)}</div>
                                        </div>
                                    )}
                                    {scalpData.levels.PDL && (
                                        <div className="p-2 bg-green-900/20 border border-green-500/30 rounded-lg text-center">
                                            <div className="text-gray-500">PDL</div>
                                            <div className="text-green-400 font-mono">${scalpData.levels.PDL.toFixed(2)}</div>
                                        </div>
                                    )}
                                    {scalpData.levels.PMH && (
                                        <div className="p-2 bg-orange-900/20 border border-orange-500/30 rounded-lg text-center">
                                            <div className="text-gray-500">PMH</div>
                                            <div className="text-orange-400 font-mono">${scalpData.levels.PMH.toFixed(2)}</div>
                                        </div>
                                    )}
                                    {scalpData.levels.PML && (
                                        <div className="p-2 bg-cyan-900/20 border border-cyan-500/30 rounded-lg text-center">
                                            <div className="text-gray-500">PML</div>
                                            <div className="text-cyan-400 font-mono">${scalpData.levels.PML.toFixed(2)}</div>
                                        </div>
                                    )}
                                </div>
                            )}

                            {/* LIVE MODE Indicator */}
                            {scalpData && (() => {
                                const tfMinutes = scalpTimeframe === '1m' ? 1 : scalpTimeframe === '5m' ? 5 : 15;
                                const now = liveTime;
                                const etNow = new Date(now.toLocaleString('en-US', {timeZone: 'America/New_York'}));
                                const mins = etNow.getMinutes();
                                const secs = etNow.getSeconds();
                                const elapsed = (mins % tfMinutes) * 60 + secs;
                                const remaining = tfMinutes * 60 - elapsed;
                                const remMin = Math.floor(remaining / 60);
                                const remSec = remaining % 60;
                                const isMarketOpen = etNow.getHours() >= 9 && (etNow.getHours() < 16 || (etNow.getHours() === 9 && etNow.getMinutes() >= 30));
                                return (
                                    <div className="bg-gray-800/80 rounded-xl p-2 border border-green-500/50 flex items-center justify-between text-xs">
                                        <div className="flex items-center gap-2">
                                            <span className="w-2 h-2 rounded-full bg-green-500 animate-pulse inline-block"></span>
                                            <span className="text-green-400 font-bold">LIVE MODE</span>
                                            <span className="text-gray-400">{etNow.toLocaleTimeString('en-US', {hour12:false})} ET</span>
                                            <span className={isMarketOpen ? 'text-green-400' : 'text-red-400'}>{isMarketOpen ? 'MARKET OPEN' : 'MARKET CLOSED'}</span>
                                        </div>
                                        <div className="flex items-center gap-3">
                                            <span className="text-yellow-400">Next candle: {remMin}:{String(remSec).padStart(2,'0')}</span>
                                            <span className="text-cyan-400">Watching for signals...</span>
                                        </div>
                                    </div>
                                );
                            })()}

                            {/* Chart Container - ALWAYS rendered to prevent DOM destruction */}
                            <div className="bg-gray-900 rounded-xl p-2 border border-gray-700">
                                {scalpData && (
                                    <div className="flex justify-between items-center mb-2">
                                        <span className="text-sm font-bold">{scalpData.ticker} - {scalpTimeframe}</span>
                                        <span className="text-xs text-gray-500">{scalpData.candles?.length || 0} candles</span>
                                    </div>
                                )}
                                <div
                                    ref={scalpChartRef}
                                    style={{ height: '500px', width: '100%', display: scalpData ? 'block' : 'none' }}
                                />
                                {!scalpData && !scalpLoading && (
                                    <div className="text-center py-12 text-gray-500">
                                        <div className="text-3xl mb-2">üìà</div>
                                        Enter a ticker and click Scan to load chart with signals
                                    </div>
                                )}
                                {scalpLoading && !scalpData && (
                                    <div className="text-center py-12 text-gray-500">
                                        <div className="text-3xl mb-2">‚ö°</div>
                                        Loading 5-min data for {scalpTicker}...
                                    </div>
                                )}
                            </div>

                            {/* Last 5 Signals Log */}
                            {signalLog.length > 0 && (
                                <div className="bg-gray-800/60 rounded-xl p-2 border border-gray-600">
                                    <div className="text-xs text-gray-400 font-semibold mb-1">SIGNAL TIMING LOG (last 5)</div>
                                    <div className="space-y-1 font-mono text-xs">
                                        {signalLog.map((s, i) => (
                                            <div key={i} className={`flex justify-between ${s.type === 'long' ? 'text-green-400' : 'text-red-400'}`}>
                                                <span>{s.type === 'long' ? 'BUY' : 'SELL'} @ {s.price.toFixed(2)}</span>
                                                <span className="text-gray-500">Candle: {s.candleTime}</span>
                                                <span className="text-gray-500">Detected: {s.detectionTime}</span>
                                                <span className={s.delayMs < 60000 ? 'text-cyan-400' : 'text-yellow-400'}>Delay: {s.delayMs}ms</span>
                                                <span className={`px-1 rounded ${s.mode === 'RT' ? 'bg-yellow-600/30 text-yellow-400' : 'bg-gray-600/30 text-gray-400'}`}>{s.mode}</span>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Signal Mode Indicator */}
                            {scalpStats && (
                                <div className="bg-gray-800/50 rounded-xl p-3 border border-cyan-600">
                                    <div className="text-xs text-cyan-400 font-semibold flex items-center gap-2">
                                        <span className="animate-pulse">‚ö°</span> CONFLUENCE SCALPER PRO
                                        <span className={`px-1.5 py-0.5 rounded text-xs ${useRealTime ? 'bg-yellow-600/30 text-yellow-400' : 'bg-gray-600/30 text-gray-400'}`}>
                                            {useRealTime ? 'REAL-TIME' : 'CONFIRMED'}
                                        </span>
                                    </div>
                                    <div className="text-xs text-gray-400 mt-1">
                                        {scalpStats.total} signals | Min: {minConfluence}/8 | Cooldown: {minBarsBetween} bars | Level-triggered
                                    </div>
                                    <div className="text-xs text-gray-500 mt-1">
                                        v7 PURE + timing verification | LA=lookahead confirmed, RT=near-live candle
                                    </div>
                                </div>
                            )}

                            {/* Recent Signals List */}
                            {scalpSignals.length > 0 && (
                                <div className="bg-gray-800/50 rounded-xl p-3 border border-gray-700">
                                    <div className="text-xs text-gray-400 mb-2 font-semibold">üö® RECENT SIGNALS ({scalpSignals.length} total)</div>
                                    <div className="space-y-2 max-h-48 overflow-y-auto">
                                        {scalpSignals.slice(-15).reverse().map((sig, idx) => (
                                            <div
                                                key={idx}
                                                className={`p-2 rounded-lg border text-xs ${
                                                    sig.type === 'long'
                                                        ? 'bg-green-900/20 border-green-500/30'
                                                        : 'bg-red-900/20 border-red-500/30'
                                                }`}
                                            >
                                                <div className="flex justify-between items-center">
                                                    <span className={`font-bold ${sig.type === 'long' ? 'text-green-400' : 'text-red-400'}`}>
                                                        {sig.type === 'long' ? 'üü¢ LONG' : 'üî¥ SHORT'} @ ${sig.price.toFixed(2)}
                                                    </span>
                                                    <span className="text-gray-500">
                                                        {new Date(sig.time * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                                    </span>
                                                </div>
                                                <div className="text-gray-400 mt-1">
                                                    <span className="text-yellow-400 font-bold">[{sig.strength}/{sig.maxStrength || '?'}]</span> {sig.reasons.join(' + ')}
                                                    {sig.stopLoss && (
                                                        <span className="ml-2 text-gray-500">SL: ${sig.stopLoss.toFixed(2)}</span>
                                                    )}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Info Box */}
                            <div className="p-3 bg-yellow-500/10 border border-yellow-500/30 rounded-xl text-xs text-yellow-300">
                                üí° <strong>Confluence Scalper Pro:</strong> 8-factor scoring (EMA Cross, Trend, MACD, RSI, BB, Volume, ADX, MTF).
                                Signals fire on edge detection (first bar condition flips). SL = 1.5x ATR. Click ‚öôÔ∏è to customize.
                            </div>
                        </div>
                    )}

                    {/* Gap Scanner View */}
                    {activeEdgeView === 'gaps' && (
                        <div className="space-y-3">
                            <div className="flex items-center justify-between">
                                <span className="text-sm font-semibold">Today's Gaps</span>
                                <button
                                    onClick={fetchGaps}
                                    disabled={loading}
                                    className="text-xs px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded-lg"
                                >
                                    {loading ? '...' : 'üîÑ Refresh'}
                                </button>
                            </div>

                            {loading && !gapData ? (
                                <div className="text-center py-8 text-gray-500">Scanning for gaps...</div>
                            ) : gapData?.gaps?.length > 0 ? (
                                <>
                                    {/* Gap Up */}
                                    <div className="space-y-2">
                                        <div className="text-xs text-green-400 font-semibold">üìà Gap UP</div>
                                        {gapData.gaps.filter(g => g.gapDirection === 'UP').slice(0, 8).map(gap => (
                                            <div key={gap.ticker} className="p-3 bg-green-900/20 border border-green-500/30 rounded-xl">
                                                <div className="flex justify-between items-center">
                                                    <div>
                                                        <span className="font-bold text-lg">{gap.ticker}</span>
                                                        <span className="ml-2 text-green-400 font-semibold">+{gap.gapPercent}%</span>
                                                    </div>
                                                    <div className="text-right text-xs">
                                                        <div className="text-gray-400">Fill: {gap.gapFillPercent}%</div>
                                                        <div className={gap.gapFilled ? 'text-yellow-400' : 'text-gray-500'}>
                                                            {gap.gapFilled ? '‚úì Filled' : 'Open'}
                                                        </div>
                                                    </div>
                                                </div>
                                                <div className="text-xs text-gray-500 mt-1">
                                                    Prev: ${gap.prevClose} ‚Üí Open: ${gap.open} ‚Üí Now: ${gap.current}
                                                </div>
                                            </div>
                                        ))}
                                        {gapData.gaps.filter(g => g.gapDirection === 'UP').length === 0 && (
                                            <div className="text-xs text-gray-500 p-3">No gap ups today</div>
                                        )}
                                    </div>

                                    {/* Gap Down */}
                                    <div className="space-y-2">
                                        <div className="text-xs text-red-400 font-semibold">üìâ Gap DOWN</div>
                                        {gapData.gaps.filter(g => g.gapDirection === 'DOWN').slice(0, 8).map(gap => (
                                            <div key={gap.ticker} className="p-3 bg-red-900/20 border border-red-500/30 rounded-xl">
                                                <div className="flex justify-between items-center">
                                                    <div>
                                                        <span className="font-bold text-lg">{gap.ticker}</span>
                                                        <span className="ml-2 text-red-400 font-semibold">{gap.gapPercent}%</span>
                                                    </div>
                                                    <div className="text-right text-xs">
                                                        <div className="text-gray-400">Fill: {gap.gapFillPercent}%</div>
                                                        <div className={gap.gapFilled ? 'text-yellow-400' : 'text-gray-500'}>
                                                            {gap.gapFilled ? '‚úì Filled' : 'Open'}
                                                        </div>
                                                    </div>
                                                </div>
                                                <div className="text-xs text-gray-500 mt-1">
                                                    Prev: ${gap.prevClose} ‚Üí Open: ${gap.open} ‚Üí Now: ${gap.current}
                                                </div>
                                            </div>
                                        ))}
                                        {gapData.gaps.filter(g => g.gapDirection === 'DOWN').length === 0 && (
                                            <div className="text-xs text-gray-500 p-3">No gap downs today</div>
                                        )}
                                    </div>
                                </>
                            ) : (
                                <div className="text-center py-8 text-gray-500">No significant gaps found</div>
                            )}

                            <div className="p-3 bg-blue-500/10 border border-blue-500/30 rounded-xl text-xs text-blue-300">
                                üí° <strong>Gap Fill Strategy:</strong> Gaps tend to fill ~70% of the time. Watch for price to return to previous close.
                            </div>
                        </div>
                    )}

                    {/* ORB/IB View */}
                    {activeEdgeView === 'orb' && (
                        <div className="space-y-3">
                            {/* Ticker Selector */}
                            <div className="flex flex-wrap gap-1">
                                {ORB_TICKERS.map(ticker => (
                                    <button
                                        key={ticker}
                                        onClick={() => {
                                            setSelectedOrbTicker(ticker);
                                            if (!orbData[ticker]) fetchOrb(ticker);
                                        }}
                                        className={`px-3 py-1 rounded-lg text-xs font-medium transition-colors ${
                                            selectedOrbTicker === ticker
                                                ? 'bg-green-600 text-white'
                                                : 'bg-gray-700 text-gray-400 hover:bg-gray-600'
                                        }`}
                                    >
                                        {ticker}
                                    </button>
                                ))}
                            </div>

                            {orbData[selectedOrbTicker] ? (
                                <div className="space-y-3">
                                    {/* Current Price */}
                                    <div className="p-4 bg-gray-800/50 rounded-xl text-center">
                                        <div className="text-xs text-gray-500 mb-1">{selectedOrbTicker} Current</div>
                                        <div className="text-3xl font-bold">${orbData[selectedOrbTicker].currentPrice}</div>
                                    </div>

                                    {/* ORB Levels */}
                                    <div className="p-4 bg-purple-900/20 border border-purple-500/30 rounded-xl">
                                        <div className="flex justify-between items-center mb-3">
                                            <span className="font-semibold text-purple-300">ORB (15 min)</span>
                                            <span className={`text-xs px-2 py-1 rounded ${
                                                orbData[selectedOrbTicker].orb?.status?.includes('ABOVE') ? 'bg-green-500/30 text-green-300' :
                                                orbData[selectedOrbTicker].orb?.status?.includes('BELOW') ? 'bg-red-500/30 text-red-300' :
                                                'bg-gray-500/30 text-gray-300'
                                            }`}>
                                                {orbData[selectedOrbTicker].orb?.status}
                                            </span>
                                        </div>
                                        <div className="grid grid-cols-3 gap-2 text-center text-sm">
                                            <div>
                                                <div className="text-xs text-gray-500">High</div>
                                                <div className="text-green-400 font-mono">${orbData[selectedOrbTicker].orb?.high}</div>
                                            </div>
                                            <div>
                                                <div className="text-xs text-gray-500">Range</div>
                                                <div className="text-gray-300 font-mono">${orbData[selectedOrbTicker].orb?.range}</div>
                                            </div>
                                            <div>
                                                <div className="text-xs text-gray-500">Low</div>
                                                <div className="text-red-400 font-mono">${orbData[selectedOrbTicker].orb?.low}</div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* IB Levels */}
                                    <div className="p-4 bg-blue-900/20 border border-blue-500/30 rounded-xl">
                                        <div className="flex justify-between items-center mb-3">
                                            <span className="font-semibold text-blue-300">IB (1 hour)</span>
                                            <span className={`text-xs px-2 py-1 rounded ${
                                                orbData[selectedOrbTicker].ib?.status?.includes('ABOVE') ? 'bg-green-500/30 text-green-300' :
                                                orbData[selectedOrbTicker].ib?.status?.includes('BELOW') ? 'bg-red-500/30 text-red-300' :
                                                'bg-gray-500/30 text-gray-300'
                                            }`}>
                                                {orbData[selectedOrbTicker].ib?.status}
                                            </span>
                                        </div>
                                        <div className="grid grid-cols-3 gap-2 text-center text-sm">
                                            <div>
                                                <div className="text-xs text-gray-500">High</div>
                                                <div className="text-green-400 font-mono">${orbData[selectedOrbTicker].ib?.high}</div>
                                            </div>
                                            <div>
                                                <div className="text-xs text-gray-500">Range</div>
                                                <div className="text-gray-300 font-mono">${orbData[selectedOrbTicker].ib?.range}</div>
                                            </div>
                                            <div>
                                                <div className="text-xs text-gray-500">Low</div>
                                                <div className="text-red-400 font-mono">${orbData[selectedOrbTicker].ib?.low}</div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Pre-Market Levels */}
                                    {orbData[selectedOrbTicker].preMarket && (
                                        <div className="p-3 bg-gray-800/50 rounded-xl">
                                            <div className="text-xs text-gray-500 mb-2">Pre-Market Range</div>
                                            <div className="flex justify-between text-sm">
                                                <span>High: <span className="text-green-400">${orbData[selectedOrbTicker].preMarket.high}</span></span>
                                                <span>Low: <span className="text-red-400">${orbData[selectedOrbTicker].preMarket.low}</span></span>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            ) : (
                                <div className="text-center py-8 text-gray-500">Loading {selectedOrbTicker} levels...</div>
                            )}

                            <div className="p-3 bg-purple-500/10 border border-purple-500/30 rounded-xl text-xs text-purple-300">
                                üí° <strong>ORB Strategy:</strong> Break above ORB High = bullish, below ORB Low = bearish. IB break = stronger signal.
                            </div>
                        </div>
                    )}

                    {/* Momentum View */}
                    {activeEdgeView === 'momentum' && (
                        <div className="space-y-3">
                            <div className="flex items-center justify-between">
                                <span className="text-sm font-semibold">Big Movers Today</span>
                                <button
                                    onClick={fetchMomentum}
                                    disabled={loading}
                                    className="text-xs px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded-lg"
                                >
                                    {loading ? '...' : 'üîÑ Refresh'}
                                </button>
                            </div>

                            {loading && !momentumData ? (
                                <div className="text-center py-8 text-gray-500">Scanning for movers...</div>
                            ) : momentumData ? (
                                <div className="grid grid-cols-2 gap-3">
                                    {/* Gainers */}
                                    <div className="space-y-2">
                                        <div className="text-xs text-green-400 font-semibold">üöÄ Gainers</div>
                                        {momentumData.gainers?.slice(0, 6).map(stock => (
                                            <div key={stock.ticker} className="p-2 bg-green-900/20 border border-green-500/30 rounded-lg">
                                                <div className="flex justify-between items-center">
                                                    <span className="font-bold">{stock.ticker}</span>
                                                    <span className="text-green-400 text-sm">+{stock.change}%</span>
                                                </div>
                                                <div className="text-xs text-gray-500">${stock.price} ‚Ä¢ {stock.relativeVolume} vol</div>
                                            </div>
                                        ))}
                                    </div>

                                    {/* Losers */}
                                    <div className="space-y-2">
                                        <div className="text-xs text-red-400 font-semibold">üíÄ Losers</div>
                                        {momentumData.losers?.slice(0, 6).map(stock => (
                                            <div key={stock.ticker} className="p-2 bg-red-900/20 border border-red-500/30 rounded-lg">
                                                <div className="flex justify-between items-center">
                                                    <span className="font-bold">{stock.ticker}</span>
                                                    <span className="text-red-400 text-sm">{stock.change}%</span>
                                                </div>
                                                <div className="text-xs text-gray-500">${stock.price} ‚Ä¢ {stock.relativeVolume} vol</div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ) : (
                                <div className="text-center py-8 text-gray-500">No big movers found</div>
                            )}

                            <div className="p-3 bg-orange-500/10 border border-orange-500/30 rounded-xl text-xs text-orange-300">
                                üí° <strong>Volume Matters:</strong> Relative volume 2x+ indicates institutional interest. Watch for continuation.
                            </div>
                        </div>
                    )}

                    {/* Key Levels View */}
                    {activeEdgeView === 'levels' && (
                        <div className="space-y-3">
                            <div className="flex items-center justify-between">
                                <span className="text-sm font-semibold">Key Levels & Pivots</span>
                                <button
                                    onClick={fetchKeyLevels}
                                    disabled={loading}
                                    className="text-xs px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded-lg"
                                >
                                    {loading ? '...' : 'üîÑ Refresh'}
                                </button>
                            </div>

                            {loading && !keyLevelsData ? (
                                <div className="text-center py-8 text-gray-500">Loading levels...</div>
                            ) : keyLevelsData?.levels?.length > 0 ? (
                                <div className="space-y-3">
                                    {keyLevelsData.levels.map(item => (
                                        <div key={item.ticker} className="p-4 bg-gray-800/50 border border-gray-700 rounded-xl">
                                            <div className="flex justify-between items-center mb-3">
                                                <span className="font-bold text-lg">{item.ticker}</span>
                                                <span className="text-xl font-mono">${item.currentPrice}</span>
                                            </div>

                                            {/* Pivot Points */}
                                            <div className="grid grid-cols-5 gap-1 text-center text-xs mb-3">
                                                <div className="p-2 bg-red-900/30 rounded">
                                                    <div className="text-gray-500">S2</div>
                                                    <div className="text-red-400 font-mono">{item.pivots?.s2}</div>
                                                </div>
                                                <div className="p-2 bg-red-900/20 rounded">
                                                    <div className="text-gray-500">S1</div>
                                                    <div className="text-red-300 font-mono">{item.pivots?.s1}</div>
                                                </div>
                                                <div className="p-2 bg-yellow-900/30 rounded">
                                                    <div className="text-gray-500">Pivot</div>
                                                    <div className="text-yellow-400 font-mono">{item.pivots?.pivot}</div>
                                                </div>
                                                <div className="p-2 bg-green-900/20 rounded">
                                                    <div className="text-gray-500">R1</div>
                                                    <div className="text-green-300 font-mono">{item.pivots?.r1}</div>
                                                </div>
                                                <div className="p-2 bg-green-900/30 rounded">
                                                    <div className="text-gray-500">R2</div>
                                                    <div className="text-green-400 font-mono">{item.pivots?.r2}</div>
                                                </div>
                                            </div>

                                            {/* Previous Day */}
                                            <div className="flex justify-between text-xs text-gray-500">
                                                <span>Prev High: <span className="text-green-400">${item.prevDay?.high}</span></span>
                                                <span>Prev Low: <span className="text-red-400">${item.prevDay?.low}</span></span>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            ) : (
                                <div className="text-center py-8 text-gray-500">No level data available</div>
                            )}

                            <div className="p-3 bg-yellow-500/10 border border-yellow-500/30 rounded-xl text-xs text-yellow-300">
                                üí° <strong>Pivot Strategy:</strong> Price above pivot = bullish bias. R1/R2 = resistance targets. S1/S2 = support targets.
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Trade Replay Chart Component
        const TradeReplayChart = ({ trade }) => {
            const chartContainerRef = React.useRef(null);
            const [chartData, setChartData] = React.useState(null);
            const [loading, setLoading] = React.useState(true);
            const [error, setError] = React.useState(null);
            const chartRef = React.useRef(null);
            const [selectedInterval, setSelectedInterval] = React.useState('5m'); // Default to 5m

            const TIMEFRAME_OPTIONS = [
                { value: '1m', label: '1m' },
                { value: '5m', label: '5m' },
                { value: '15m', label: '15m' },
                { value: '1h', label: '1H' },
                { value: '1d', label: '1D' }
            ];

            const loadChartData = async (interval) => {
                if (!trade || !trade.ticker || !trade.entryDate) {
                    setError('Missing trade data');
                    setLoading(false);
                    return;
                }

                setLoading(true);
                setError(null);

                // Clean up existing chart
                if (chartRef.current) {
                    chartRef.current.remove();
                    chartRef.current = null;
                }

                try {
                    const data = await fetchTradeChartData(
                        trade.ticker,
                        trade.entryDate,
                        trade.exitDate || trade.entryDate,
                        interval
                    );

                    if (data && data.candlestickData.length > 0) {
                        setChartData(data);
                    } else {
                        setError('No chart data available');
                    }
                } catch (err) {
                    setError('Failed to load chart');
                }
                setLoading(false);
            };

            React.useEffect(() => {
                loadChartData(selectedInterval);
            }, [trade?.id]);

            // Reload when interval changes
            const handleIntervalChange = (newInterval) => {
                setSelectedInterval(newInterval);
                loadChartData(newInterval);
            };

            React.useEffect(() => {
                if (!chartData || !chartContainerRef.current || chartRef.current) return;

                // Clean up any existing chart
                if (chartRef.current) {
                    chartRef.current.remove();
                    chartRef.current = null;
                }

                try {
                    const chart = LightweightCharts.createChart(chartContainerRef.current, {
                        width: chartContainerRef.current.clientWidth,
                        height: 250,
                        layout: {
                            background: { type: 'solid', color: 'transparent' },
                            textColor: '#9ca3af'
                        },
                        grid: {
                            vertLines: { color: '#374151', style: 1 },
                            horzLines: { color: '#374151', style: 1 }
                        },
                        crosshair: {
                            mode: LightweightCharts.CrosshairMode.Normal
                        },
                        rightPriceScale: {
                            borderColor: '#374151'
                        },
                        timeScale: {
                            borderColor: '#374151',
                            timeVisible: true,
                            secondsVisible: false
                        }
                    });

                    chartRef.current = chart;

                    const candlestickSeries = chart.addCandlestickSeries({
                        upColor: '#22c55e',
                        downColor: '#ef4444',
                        borderDownColor: '#ef4444',
                        borderUpColor: '#22c55e',
                        wickDownColor: '#ef4444',
                        wickUpColor: '#22c55e'
                    });

                    candlestickSeries.setData(chartData.candlestickData);

                    // Add markers for entries and exits
                    const markers = [];

                    // Helper: find nearest candle to a given timestamp
                    const findNearestCandle = (timestamp) => {
                        const targetTime = new Date(timestamp).getTime() / 1000;
                        return chartData.candlestickData.reduce((nearest, candle) => {
                            if (!nearest) return candle;
                            return Math.abs(candle.time - targetTime) < Math.abs(nearest.time - targetTime) ? candle : nearest;
                        }, null);
                    };

                    // Check if trade has multiple entries array
                    if (trade.entries && trade.entries.length > 0) {
                        // Multiple entries - show each one
                        trade.entries.forEach((entry, idx) => {
                            const candle = findNearestCandle(entry.date);
                            if (candle) {
                                const isFirstEntry = idx === 0;
                                markers.push({
                                    time: candle.time,
                                    position: trade.side === 'long' ? 'belowBar' : 'aboveBar',
                                    color: isFirstEntry ? '#3b82f6' : '#60a5fa', // Darker blue for first, lighter for adds
                                    shape: trade.side === 'long' ? 'arrowUp' : 'arrowDown',
                                    text: isFirstEntry
                                        ? `Entry $${entry.price.toFixed(2)} (${entry.quantity})`
                                        : `Add $${entry.price.toFixed(2)} (${entry.quantity})`
                                });
                            }
                        });
                    } else {
                        // Legacy single entry
                        const entryCandle = findNearestCandle(trade.entryDate);
                        if (entryCandle) {
                            markers.push({
                                time: entryCandle.time,
                                position: trade.side === 'long' ? 'belowBar' : 'aboveBar',
                                color: '#3b82f6',
                                shape: trade.side === 'long' ? 'arrowUp' : 'arrowDown',
                                text: 'Entry $' + trade.entryPrice?.toFixed(2)
                            });
                        }
                    }

                    // Check if trade has multiple exits array
                    if (trade.exits && trade.exits.length > 0) {
                        // Multiple exits - show each one
                        trade.exits.forEach((exit, idx) => {
                            const candle = findNearestCandle(exit.date);
                            if (candle) {
                                const isLastExit = idx === trade.exits.length - 1;
                                // Determine if this exit was profitable (compare to avg entry)
                                const avgEntry = trade.entryPrice || trade.entries?.[0]?.price || 0;
                                const isProfit = trade.side === 'long' ? exit.price > avgEntry : exit.price < avgEntry;
                                markers.push({
                                    time: candle.time,
                                    position: trade.side === 'long' ? 'aboveBar' : 'belowBar',
                                    color: isProfit ? '#22c55e' : '#ef4444',
                                    shape: 'circle',
                                    text: isLastExit
                                        ? `Exit $${exit.price.toFixed(2)} (${exit.quantity})`
                                        : `Trim $${exit.price.toFixed(2)} (${exit.quantity})`
                                });
                            }
                        });
                    } else if (trade.exitPrice) {
                        // Legacy single exit
                        const exitCandle = findNearestCandle(trade.exitDate);
                        if (exitCandle) {
                            const isProfit = (trade.pnl || 0) >= 0;
                            markers.push({
                                time: exitCandle.time,
                                position: trade.side === 'long' ? 'aboveBar' : 'belowBar',
                                color: isProfit ? '#22c55e' : '#ef4444',
                                shape: 'circle',
                                text: 'Exit $' + trade.exitPrice?.toFixed(2)
                            });
                        }
                    }

                    // Sort markers by time to ensure proper display
                    markers.sort((a, b) => a.time - b.time);

                    if (markers.length > 0) {
                        candlestickSeries.setMarkers(markers);
                    }

                    // Fit content
                    chart.timeScale().fitContent();

                    // Handle resize
                    const handleResize = () => {
                        if (chartContainerRef.current && chartRef.current) {
                            chartRef.current.applyOptions({ width: chartContainerRef.current.clientWidth });
                        }
                    };

                    window.addEventListener('resize', handleResize);

                    return () => {
                        window.removeEventListener('resize', handleResize);
                        if (chartRef.current) {
                            chartRef.current.remove();
                            chartRef.current = null;
                        }
                    };
                } catch (err) {
                    console.error('Error creating chart:', err);
                    setError('Chart rendering failed');
                }
            }, [chartData]);

            // Cleanup on unmount
            React.useEffect(() => {
                return () => {
                    if (chartRef.current) {
                        chartRef.current.remove();
                        chartRef.current = null;
                    }
                };
            }, []);

            if (loading) {
                return (
                    <div className="bg-gray-800/50 rounded-xl p-4">
                        <div className="text-sm font-semibold mb-2">Trade Replay</div>
                        <div className="h-[250px] flex items-center justify-center">
                            <div className="text-gray-500">Loading chart...</div>
                        </div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="bg-gray-800/50 rounded-xl p-4">
                        <div className="text-sm font-semibold mb-2">Trade Replay</div>
                        <div className="h-[100px] flex items-center justify-center">
                            <div className="text-gray-500 text-sm">{error}</div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="bg-gray-800/50 rounded-xl p-4">
                    <div className="flex justify-between items-center mb-2">
                        <div className="text-sm font-semibold">Trade Replay</div>
                        <div className="flex items-center gap-1">
                            {TIMEFRAME_OPTIONS.map(tf => (
                                <button
                                    key={tf.value}
                                    onClick={() => handleIntervalChange(tf.value)}
                                    className={`px-2 py-1 text-xs rounded transition-colors ${
                                        selectedInterval === tf.value
                                            ? 'bg-blue-600 text-white'
                                            : 'bg-gray-700 text-gray-400 hover:bg-gray-600'
                                    }`}
                                >
                                    {tf.label}
                                </button>
                            ))}
                        </div>
                    </div>
                    <div ref={chartContainerRef} className="rounded-lg overflow-hidden" />
                </div>
            );
        };

        // Position Detail Modal
        const PositionDetailModal = ({ position, onClose, onDelete, onUpdate, onLogToJournal }) => {
            const [showAddForm, setShowAddForm] = React.useState(false);
            const [showTrimForm, setShowTrimForm] = React.useState(false);
            const [showCloseForm, setShowCloseForm] = React.useState(false);
            const [addPrice, setAddPrice] = React.useState('');
            const [addQuantity, setAddQuantity] = React.useState('');
            const [addNote, setAddNote] = React.useState('');
            const [trimPrice, setTrimPrice] = React.useState('');
            const [trimQuantity, setTrimQuantity] = React.useState('');
            const [trimNote, setTrimNote] = React.useState('');
            const [closePrice, setClosePrice] = React.useState('');
            const [closeNote, setCloseNote] = React.useState('');

            if (!position) return null;

            console.log(`[Modal] Position ${position.ticker}: livePrice=${position.livePrice}, currentPrice=${position.currentPrice}`);
            const currentPrice = position.livePrice || position.currentPrice;
            const multiplier = position.type === 'option' ? 100 : 1; // Options = 100 shares per contract
            const pnl = (currentPrice - position.entryPrice) * position.quantity * multiplier;
            const pnlPercent = ((currentPrice - position.entryPrice) / position.entryPrice * 100);
            const isProfit = pnl >= 0;
            const daysToExpiry = position.expiration ? getDaysToExpiry(position.expiration) : null;
            const grade = getTradeGrade(position);
            const totalValue = currentPrice * position.quantity * multiplier;
            const costBasis = position.entryPrice * position.quantity * multiplier;

            // Handle adding to position
            const handleAddToPosition = () => {
                const price = parseFloat(addPrice);
                const qty = parseInt(addQuantity);
                if (!price || !qty || qty <= 0) return;

                // Create new entry record
                const newEntry = {
                    price,
                    quantity: qty,
                    date: new Date().toISOString(),
                    note: addNote || `Added ${qty} @ $${price.toFixed(2)}`
                };

                // Get existing entries or create from initial position
                const existingEntries = position.entries || [{
                    price: position.entryPrice,
                    quantity: position.quantity,
                    date: position.entryDate || new Date().toISOString(),
                    note: 'Initial entry'
                }];

                const updatedEntries = [...existingEntries, newEntry];

                // Calculate new average entry price
                const totalCost = updatedEntries.reduce((sum, e) => sum + (e.price * e.quantity), 0);
                const totalQty = updatedEntries.reduce((sum, e) => sum + e.quantity, 0);
                const newAvgPrice = totalCost / totalQty;

                // Update position
                onUpdate({
                    ...position,
                    entries: updatedEntries,
                    entryPrice: newAvgPrice,
                    quantity: totalQty
                });

                // Reset form
                setAddPrice('');
                setAddQuantity('');
                setAddNote('');
                setShowAddForm(false);
            };

            // Handle trimming position
            const handleTrimPosition = () => {
                const price = parseFloat(trimPrice);
                const qty = parseInt(trimQuantity);
                if (!price || !qty || qty <= 0 || qty > position.quantity) return;

                // Create new exit record
                const newExit = {
                    price,
                    quantity: qty,
                    date: new Date().toISOString(),
                    note: trimNote || `Trimmed ${qty} @ $${price.toFixed(2)}`
                };

                // Get existing exits or start fresh
                const existingExits = position.exits || [];
                const updatedExits = [...existingExits, newExit];

                // Calculate remaining quantity
                const remainingQty = position.quantity - qty;

                if (remainingQty <= 0) {
                    // Fully closed - could move to journal here
                    alert('Position fully closed! You can delete it or log to journal.');
                }

                // Update position
                onUpdate({
                    ...position,
                    exits: updatedExits,
                    quantity: remainingQty
                });

                // Reset form
                setTrimPrice('');
                setTrimQuantity('');
                setTrimNote('');
                setShowTrimForm(false);
            };

            return (
                <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                    <div className="bg-gray-900 border border-gray-700 rounded-2xl w-full max-w-md max-h-[90vh] overflow-y-auto">
                        <div className="p-6">
                            {/* Header */}
                            <div className="flex justify-between items-start mb-6">
                                <div>
                                    <div className="flex items-center gap-2 mb-2">
                                        <span className="text-3xl font-bold">{position.ticker}</span>
                                        <span className={`text-sm px-3 py-1 rounded-full font-semibold ${
                                            position.type === 'option' ? 'bg-purple-500/30 text-purple-300 border border-purple-500' :
                                            position.type === 'crypto' ? 'bg-orange-500/30 text-orange-300 border border-orange-500' :
                                            'bg-blue-500/30 text-blue-300 border border-blue-500'
                                        }`}>
                                            {position.type === 'option' ? 'üìú OPTION' : position.type === 'crypto' ? 'ü™ô CRYPTO' : 'üìä STOCK'}
                                        </span>
                                    </div>
                                    {position.type === 'option' && (
                                        <div className="text-purple-400 font-semibold">
                                            ${position.strike} {position.optionType?.toUpperCase()}
                                        </div>
                                    )}
                                </div>
                                <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl">&times;</button>
                            </div>

                            {/* AI Grade */}
                            <div className={`p-4 rounded-xl mb-4 ${
                                grade.score >= 7 ? 'bg-green-500/20 border border-green-500/50' :
                                grade.score >= 5 ? 'bg-yellow-500/20 border border-yellow-500/50' :
                                grade.score >= 3 ? 'bg-orange-500/20 border border-orange-500/50' :
                                'bg-red-500/20 border border-red-500/50'
                            }`}>
                                <div className="flex items-center justify-between">
                                    <span className="text-lg font-bold">AI Grade: {grade.emoji} {grade.score}/10</span>
                                    <span className={grade.color}>{grade.label}</span>
                                </div>
                                <p className="text-sm text-gray-300 mt-2 italic">{grade.reason}</p>
                            </div>

                            {/* P&L Section */}
                            <div className={`p-4 rounded-xl mb-4 ${isProfit ? 'bg-green-500/10 border border-green-500/30' : 'bg-red-500/10 border border-red-500/30'}`}>
                                <div className="text-center">
                                    <div className={`text-4xl font-bold ${isProfit ? 'text-green-400' : 'text-red-400'}`}>
                                        {isProfit ? '+' : ''}{pnlPercent.toFixed(2)}%
                                    </div>
                                    <div className={`text-lg ${isProfit ? 'text-green-400' : 'text-red-400'}`}>
                                        {isProfit ? '+' : ''}${pnl.toFixed(2)}
                                    </div>
                                </div>
                            </div>

                            {/* Position Details */}
                            <div className="space-y-3 mb-4">
                                <div className="flex justify-between p-3 bg-gray-800 rounded-lg">
                                    <span className="text-gray-400">Quantity</span>
                                    <span className="font-semibold">{position.quantity} {position.type === 'option' ? 'contracts' : position.type === 'crypto' ? 'coins' : 'shares'}</span>
                                </div>
                                <div className="flex justify-between p-3 bg-gray-800 rounded-lg">
                                    <span className="text-gray-400">Entry Price</span>
                                    <span className="font-semibold">${position.entryPrice.toFixed(2)}</span>
                                </div>
                                <div className="flex justify-between p-3 bg-gray-800 rounded-lg">
                                    <span className="text-gray-400">Current Price</span>
                                    <span className="font-semibold">${currentPrice.toFixed(2)}</span>
                                </div>
                                <div className="flex justify-between p-3 bg-gray-800 rounded-lg">
                                    <span className="text-gray-400">Cost Basis</span>
                                    <span className="font-semibold">${costBasis.toFixed(2)}</span>
                                </div>
                                <div className="flex justify-between p-3 bg-gray-800 rounded-lg">
                                    <span className="text-gray-400">Current Value</span>
                                    <span className="font-semibold">${totalValue.toFixed(2)}</span>
                                </div>
                                {position.type === 'option' && daysToExpiry !== null && (
                                    <div className={`flex justify-between p-3 rounded-lg ${daysToExpiry <= 7 ? 'bg-red-500/20 border border-red-500' : daysToExpiry <= 30 ? 'bg-yellow-500/20 border border-yellow-500' : 'bg-gray-800'}`}>
                                        <span className="text-gray-400">Expiration</span>
                                        <span className={`font-semibold ${daysToExpiry <= 7 ? 'text-red-400' : daysToExpiry <= 30 ? 'text-yellow-400' : ''}`}>
                                            {formatExpirationDate(position.expiration)} {daysToExpiry <= 7 ? '‚ö†Ô∏è' : ''}
                                        </span>
                                    </div>
                                )}
                                {position.type !== 'option' && (
                                    <div className="flex justify-between p-3 bg-gray-800 rounded-lg">
                                        <span className="text-gray-400">Expiration</span>
                                        <span className="text-green-400 font-semibold">‚àû No expiry</span>
                                    </div>
                                )}
                                {position.momentum && (
                                    <div className={`flex justify-between p-3 rounded-lg ${
                                        position.momentum === 'ripping' ? 'bg-green-500/20 border border-green-500' :
                                        position.momentum === 'bleeding' ? 'bg-red-500/20 border border-red-500' :
                                        'bg-gray-800'
                                    }`}>
                                        <span className="text-gray-400">Momentum</span>
                                        <span className="font-semibold">
                                            {position.momentum === 'ripping' && 'üî• RIPPING'}
                                            {position.momentum === 'uptrend' && 'üìà Uptrend'}
                                            {position.momentum === 'bleeding' && 'üíÄ BLEEDING'}
                                            {position.momentum === 'downtrend' && 'üìâ Downtrend'}
                                            {position.momentum === 'flat' && 'üòê Flat'}
                                        </span>
                                    </div>
                                )}
                            </div>

                            {/* Scaling Buttons */}
                            <div className="flex gap-2 mb-3">
                                <button
                                    onClick={() => { setShowAddForm(!showAddForm); setShowTrimForm(false); }}
                                    className={`flex-1 py-2 rounded-xl font-semibold transition-colors text-sm ${showAddForm ? 'bg-blue-600' : 'bg-blue-600/30 hover:bg-blue-600/50 border border-blue-500'}`}
                                >
                                    ‚ûï Add to Position
                                </button>
                                <button
                                    onClick={() => { setShowTrimForm(!showTrimForm); setShowAddForm(false); }}
                                    className={`flex-1 py-2 rounded-xl font-semibold transition-colors text-sm ${showTrimForm ? 'bg-green-600' : 'bg-green-600/30 hover:bg-green-600/50 border border-green-500'}`}
                                >
                                    ‚úÇÔ∏è Trim Position
                                </button>
                            </div>

                            {/* Add to Position Form */}
                            {showAddForm && (
                                <div className="p-4 bg-blue-500/10 border border-blue-500/30 rounded-xl mb-3">
                                    <div className="text-sm font-semibold text-blue-400 mb-3">‚ûï Add to {position.ticker}</div>
                                    <div className="grid grid-cols-2 gap-2 mb-2">
                                        <div>
                                            <label className="text-xs text-gray-400">Price</label>
                                            <input
                                                type="number"
                                                step="0.01"
                                                value={addPrice}
                                                onChange={(e) => setAddPrice(e.target.value)}
                                                placeholder={currentPrice.toFixed(2)}
                                                className="w-full p-2 bg-gray-800 border border-gray-600 rounded-lg text-sm"
                                            />
                                        </div>
                                        <div>
                                            <label className="text-xs text-gray-400">Quantity</label>
                                            <input
                                                type="number"
                                                value={addQuantity}
                                                onChange={(e) => setAddQuantity(e.target.value)}
                                                placeholder="Shares"
                                                className="w-full p-2 bg-gray-800 border border-gray-600 rounded-lg text-sm"
                                            />
                                        </div>
                                    </div>
                                    <div className="mb-3">
                                        <label className="text-xs text-gray-400">Note (optional)</label>
                                        <input
                                            type="text"
                                            value={addNote}
                                            onChange={(e) => setAddNote(e.target.value)}
                                            placeholder="e.g., Adding on dip to support"
                                            className="w-full p-2 bg-gray-800 border border-gray-600 rounded-lg text-sm"
                                        />
                                    </div>
                                    <button
                                        onClick={handleAddToPosition}
                                        disabled={!addPrice || !addQuantity}
                                        className="w-full py-2 bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg font-semibold text-sm"
                                    >
                                        Confirm Add
                                    </button>
                                </div>
                            )}

                            {/* Trim Position Form */}
                            {showTrimForm && (
                                <div className="p-4 bg-green-500/10 border border-green-500/30 rounded-xl mb-3">
                                    <div className="text-sm font-semibold text-green-400 mb-3">‚úÇÔ∏è Trim {position.ticker}</div>
                                    <div className="text-xs text-gray-400 mb-2">Current position: {position.quantity} {position.type === 'option' ? 'contracts' : 'shares'}</div>
                                    <div className="grid grid-cols-2 gap-2 mb-2">
                                        <div>
                                            <label className="text-xs text-gray-400">Exit Price</label>
                                            <input
                                                type="number"
                                                step="0.01"
                                                value={trimPrice}
                                                onChange={(e) => setTrimPrice(e.target.value)}
                                                placeholder={currentPrice.toFixed(2)}
                                                className="w-full p-2 bg-gray-800 border border-gray-600 rounded-lg text-sm"
                                            />
                                        </div>
                                        <div>
                                            <label className="text-xs text-gray-400">Quantity to Sell</label>
                                            <input
                                                type="number"
                                                value={trimQuantity}
                                                onChange={(e) => setTrimQuantity(e.target.value)}
                                                placeholder={`Max: ${position.quantity}`}
                                                max={position.quantity}
                                                className="w-full p-2 bg-gray-800 border border-gray-600 rounded-lg text-sm"
                                            />
                                        </div>
                                    </div>
                                    <div className="mb-3">
                                        <label className="text-xs text-gray-400">Note (optional)</label>
                                        <input
                                            type="text"
                                            value={trimNote}
                                            onChange={(e) => setTrimNote(e.target.value)}
                                            placeholder="e.g., Taking profit at resistance"
                                            className="w-full p-2 bg-gray-800 border border-gray-600 rounded-lg text-sm"
                                        />
                                    </div>
                                    <button
                                        onClick={handleTrimPosition}
                                        disabled={!trimPrice || !trimQuantity || parseInt(trimQuantity) > position.quantity}
                                        className="w-full py-2 bg-green-600 hover:bg-green-500 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg font-semibold text-sm"
                                    >
                                        Confirm Trim
                                    </button>
                                </div>
                            )}

                            {/* Scaling History (if exists) */}
                            {(position.entries?.length > 1 || position.exits?.length > 0) && (
                                <div className="p-3 bg-gray-800/50 rounded-xl mb-3">
                                    <div className="text-xs font-semibold text-gray-400 mb-2">üìä Scaling History</div>
                                    {position.entries?.length > 0 && (
                                        <div className="mb-2">
                                            <div className="text-xs text-blue-400 mb-1">Entries:</div>
                                            {position.entries.map((e, i) => (
                                                <div key={i} className="text-xs text-gray-300 flex justify-between">
                                                    <span>{i === 0 ? 'üéØ' : '‚ûï'} ${e.price.toFixed(2)} √ó {e.quantity}</span>
                                                    <span className="text-gray-500">{new Date(e.date).toLocaleDateString()}</span>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    {position.exits?.length > 0 && (
                                        <div>
                                            <div className="text-xs text-green-400 mb-1">Exits:</div>
                                            {position.exits.map((e, i) => (
                                                <div key={i} className="text-xs text-gray-300 flex justify-between">
                                                    <span>‚úÇÔ∏è ${e.price.toFixed(2)} √ó {e.quantity}</span>
                                                    <span className="text-gray-500">{new Date(e.date).toLocaleDateString()}</span>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            )}

                            {/* Close & Log Form */}
                            {showCloseForm && (
                                <div className="p-4 bg-purple-500/10 border border-purple-500/30 rounded-xl mb-3">
                                    <div className="text-sm font-semibold text-purple-400 mb-3">üìù Close & Log to Journal</div>
                                    <div className="grid grid-cols-2 gap-2 mb-2">
                                        <div>
                                            <label className="text-xs text-gray-400">Exit Price</label>
                                            <input
                                                type="number"
                                                step="0.01"
                                                value={closePrice}
                                                onChange={(e) => setClosePrice(e.target.value)}
                                                placeholder={currentPrice?.toFixed(2) || '0.00'}
                                                className="w-full p-2 bg-gray-800 border border-gray-600 rounded-lg text-sm"
                                            />
                                        </div>
                                        <div>
                                            <label className="text-xs text-gray-400">Remaining Qty</label>
                                            <input
                                                type="text"
                                                value={position.quantity}
                                                disabled
                                                className="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-sm text-gray-400"
                                            />
                                        </div>
                                    </div>
                                    <div className="mb-3">
                                        <label className="text-xs text-gray-400">Notes (optional)</label>
                                        <input
                                            type="text"
                                            value={closeNote}
                                            onChange={(e) => setCloseNote(e.target.value)}
                                            placeholder="e.g., Hit target, stopped out, etc."
                                            className="w-full p-2 bg-gray-800 border border-gray-600 rounded-lg text-sm"
                                        />
                                    </div>
                                    <button
                                        onClick={() => {
                                            const exitPrice = parseFloat(closePrice) || currentPrice;
                                            if (!exitPrice) return;

                                            // Build entries array (use existing or create from initial)
                                            const entries = position.entries || [{
                                                price: position.entryPrice,
                                                quantity: position.quantity + (position.exits?.reduce((sum, e) => sum + e.quantity, 0) || 0),
                                                date: position.entryDate || new Date().toISOString(),
                                                note: 'Initial entry'
                                            }];

                                            // Build exits array (add final exit)
                                            const existingExits = position.exits || [];
                                            const finalExit = {
                                                price: exitPrice,
                                                quantity: position.quantity,
                                                date: new Date().toISOString(),
                                                note: closeNote || 'Final exit'
                                            };
                                            const exits = [...existingExits, finalExit];

                                            // Calculate total P&L
                                            const totalBought = entries.reduce((sum, e) => sum + (e.price * e.quantity), 0);
                                            const totalSold = exits.reduce((sum, e) => sum + (e.price * e.quantity), 0);
                                            const multiplier = position.type === 'option' ? 100 : 1;
                                            const totalPnl = (totalSold - totalBought) * multiplier;

                                            // Calculate average entry/exit
                                            const totalEntryQty = entries.reduce((sum, e) => sum + e.quantity, 0);
                                            const avgEntry = totalBought / totalEntryQty;
                                            const totalExitQty = exits.reduce((sum, e) => sum + e.quantity, 0);
                                            const avgExit = totalSold / totalExitQty;

                                            // Create journal entry
                                            const journalEntry = {
                                                id: Date.now(),
                                                ticker: position.ticker,
                                                side: position.side || 'long',
                                                assetType: position.type || 'stock',
                                                tradeStyle: 'day',
                                                entryPrice: avgEntry,
                                                exitPrice: avgExit,
                                                quantity: totalEntryQty,
                                                entryDate: entries[0].date,
                                                exitDate: new Date().toISOString(),
                                                entries: entries,
                                                exits: exits,
                                                pnl: totalPnl,
                                                fees: 0,
                                                setup: 'manual',
                                                mistakes: ['none'],
                                                emotionBefore: 'neutral',
                                                emotionAfter: totalPnl >= 0 ? 'confident' : 'neutral',
                                                followedPlan: true,
                                                riskAmount: 0,
                                                notes: closeNote || `Closed ${position.ticker} position`,
                                                // Option specific fields
                                                ...(position.type === 'option' && {
                                                    strike: position.strike,
                                                    optionType: position.optionType,
                                                    expiration: position.expiration
                                                })
                                            };

                                            // Log to journal and delete position
                                            onLogToJournal(journalEntry);
                                            onDelete(position.id);
                                            onClose();
                                        }}
                                        className="w-full py-2 bg-purple-600 hover:bg-purple-500 rounded-lg font-semibold text-sm"
                                    >
                                        ‚úÖ Close & Log to Journal
                                    </button>
                                </div>
                            )}

                            {/* Action Buttons */}
                            <div className="flex gap-3">
                                <button
                                    onClick={onClose}
                                    className="flex-1 py-3 bg-gray-700 hover:bg-gray-600 rounded-xl font-semibold transition-colors"
                                >
                                    Back
                                </button>
                                <button
                                    onClick={() => {
                                        setShowCloseForm(!showCloseForm);
                                        setShowAddForm(false);
                                        setShowTrimForm(false);
                                        setClosePrice(currentPrice?.toFixed(2) || '');
                                    }}
                                    className={`flex-1 py-3 rounded-xl font-semibold transition-colors ${showCloseForm ? 'bg-purple-600' : 'bg-purple-600/80 hover:bg-purple-600'}`}
                                >
                                    üìù Close & Log
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Talk Me Down Modal (or Pump Me Up in Send It Mode)
        const TalkMeDownModal = ({ isOpen, onClose, positions, personality = 'homie', tradingMode = 'standard' }) => {
            const [step, setStep] = useState('emotion');
            const [selectedEmotion, setSelectedEmotion] = useState(null);
            const [selectedPosition, setSelectedPosition] = useState(null);
            const [aiResponse, setAiResponse] = useState('');
            const [customMessage, setCustomMessage] = useState('');

            const isPumpMode = tradingMode === 'aggressive';

            // Different emotions for Pump Me Up mode
            const pumpEmotions = [
                { id: 'confidence', label: 'üöÄ Need a confidence boost', desc: 'Remind me I\'m that guy' },
                { id: 'hesitating', label: 'ü§î Hesitating on entry', desc: 'I see a play but I\'m being a coward' },
                { id: 'doubting', label: 'üò§ Doubting my thesis', desc: 'I did the DD but need reassurance' },
                { id: 'winner', label: 'üí∞ Riding a winner', desc: 'I\'m up big, hype me to hold' },
                { id: 'sizing', label: 'üìà Should I size up?', desc: 'Thinking about going bigger' },
                { id: 'lfg', label: 'üî• Just need some LFG energy', desc: 'PUMP ME UP!' }
            ];

            const emotions = isPumpMode ? pumpEmotions : [
                { id: 'panic', label: 'üò∞ Want to panic sell', desc: 'I\'m scared and want out' },
                { id: 'greedy', label: 'üò® Want to take profit too early', desc: 'I\'m up but scared of giving it back' },
                { id: 'baghold', label: 'üíéüôå Holding a loser too long', desc: 'Down bad but ego won\'t let me sell' },
                { id: 'average', label: 'üìâ Should I average down/up?', desc: 'Thinking about adding to my position' },
                { id: 'revenge', label: 'üò§ Want to revenge trade', desc: 'Just took a loss, need to make it back' },
                { id: 'fomo', label: 'ü§ë Chasing FOMO', desc: 'Stock is ripping without me' }
            ];

            // Hype responses for Pump Me Up mode
            const getPumpResponse = (emotion, position) => {
                const ticker = position?.ticker || 'this play';
                const pnl = position?.pnlPercent || 0;

                const responses = {
                    confidence: [
                        `You've done the work. You've seen the setup. ${ticker} is YOUR trade. Champions don't second-guess themselves. SEND IT! üöÄ`,
                        `Remember: Fortune favors the bold. You're not here to play it safe - you're here to WIN. ${ticker} is calling your name. LET'S GO!`,
                        `You know what separates the winners from everyone else? They EXECUTE when they see opportunity. This is your moment. SEND IT! üí™`
                    ],
                    hesitating: [
                        `Hesitation is the killer of gains. You see the play, you know the play, NOW TAKE THE PLAY! ${ticker} isn't going to wait for you!`,
                        `Every moment you hesitate, someone else is taking YOUR profits. The setup is there. Trust your gut. ENTER NOW! üéØ`,
                        `"The best time to plant a tree was 20 years ago. The second best time is NOW." Stop thinking, start doing. LFGGG! üöÄ`
                    ],
                    doubting: [
                        `You did the DD. You know this company. You know the catalyst. Trust the PROCESS! ${ticker} is going to make you proud. üíé`,
                        `Doubt kills more dreams than failure ever will. Your thesis is SOLID. The market just hasn't caught up yet. HOLD THE LINE!`,
                        `Warren Buffett held Coca-Cola for decades when people doubted him. Your conviction will be rewarded. STAY STRONG! ü¶ç`
                    ],
                    winner: [
                        `YOU'RE UP ${pnl > 0 ? pnl.toFixed(1) + '%' : 'BIG'} ON ${ticker}! This is what we TRAINED for! Let it RIDE! Winners let their winners RUN! üèÜ`,
                        `This is YOUR trade. YOUR moment. Don't you DARE cut this winner short! The best traders let profits run. HOLD STRONG! üí∞`,
                        `${ticker} is PRINTING! You called it, you're living it. This is just the BEGINNING! Diamond hands activated! üíéüôå`
                    ],
                    sizing: [
                        `You see it, you believe it, NOW SIZE INTO IT! Conviction without size is just a hobby. Make it COUNT! üìà`,
                        `The best traders SIZE UP on their A+ setups. If ${ticker} is your conviction play, BACK IT UP! Go big or go home! üé∞`,
                        `"Bet big when you have the edge." You've found your edge. Time to CAPITALIZE! üöÄ`
                    ],
                    lfg: [
                        `LFGGGGG! üöÄüöÄüöÄ You're a TRADER! You're a WINNER! The market is YOUR playground! NOW GO GET THOSE TENDIES!`,
                        `Today is YOUR day! You've got the skills, you've got the conviction, you've got the FIRE! LET'S GOOOOO! üî•üî•üî•`,
                        `Champions show up EVERY DAY ready to WIN! You're not here to participate - you're here to DOMINATE! SEND IT! üí™üöÄ`
                    ]
                };

                const emotionResponses = responses[emotion] || responses.lfg;
                return emotionResponses[Math.floor(Math.random() * emotionResponses.length)];
            };

            const handleEmotionSelect = (emotion) => {
                setSelectedEmotion(emotion);
                setStep('position');
            };

            const handlePositionSelect = (position) => {
                setSelectedPosition(position);
                setAiResponse(isPumpMode ? getPumpResponse(selectedEmotion, position) : getAIResponse(selectedEmotion, position, personality));
                setStep('response');
            };

            const handleClose = () => {
                setStep('emotion');
                setSelectedEmotion(null);
                setSelectedPosition(null);
                setAiResponse('');
                onClose();
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                    <div className="bg-gray-900 border border-gray-700 rounded-2xl w-full max-w-lg max-h-[90vh] overflow-y-auto">
                        <div className="p-6">
                            <div className="flex justify-between items-center mb-6">
                                <h2 className="text-2xl font-bold">
                                    {step === 'emotion' && (isPumpMode ? 'üöÄ PUMP ME UP!' : 'üß† The Voice of Logic')}
                                    {step === 'position' && 'üìä Which Position?'}
                                    {step === 'response' && (isPumpMode ? 'üî• LFG!' : 'üí¨ AI Buddy Says...')}
                                </h2>
                                <button onClick={handleClose} className="text-gray-400 hover:text-white text-2xl">&times;</button>
                            </div>

                            {step === 'emotion' && (
                                <div className="space-y-3">
                                    <p className="text-gray-400 mb-4">What's going on? Talk to me.</p>
                                    {emotions.map(emotion => (
                                        <button
                                            key={emotion.id}
                                            onClick={() => handleEmotionSelect(emotion.id)}
                                            className="w-full p-4 text-left bg-gray-800 hover:bg-gray-700 border border-gray-700 hover:border-blue-500 rounded-xl transition-all"
                                        >
                                            <div className="font-semibold">{emotion.label}</div>
                                            <div className="text-sm text-gray-400">{emotion.desc}</div>
                                        </button>
                                    ))}
                                    <div className="pt-4">
                                        <textarea
                                            value={customMessage}
                                            onChange={(e) => setCustomMessage(e.target.value)}
                                            onKeyDown={(e) => {
                                                if (e.key === 'Enter' && !e.shiftKey && customMessage.trim()) {
                                                    e.preventDefault();
                                                    setAiResponse(getCustomAIResponse(customMessage, positions, personality));
                                                    setStep('response');
                                                }
                                            }}
                                            placeholder="Or tell me what's on your mind..."
                                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-xl text-white placeholder-gray-500 focus:border-blue-500 focus:outline-none"
                                            rows={3}
                                        />
                                        {customMessage.trim() && (
                                            <button
                                                onClick={() => {
                                                    setAiResponse(getCustomAIResponse(customMessage, positions, personality));
                                                    setStep('response');
                                                }}
                                                className="w-full mt-2 py-2 bg-blue-600 hover:bg-blue-500 rounded-xl font-semibold transition-colors"
                                            >
                                                üß† Get AI Response
                                            </button>
                                        )}
                                    </div>
                                </div>
                            )}

                            {step === 'position' && (
                                <div className="space-y-3">
                                    <p className="text-gray-400 mb-4">Which position are you worried about?</p>
                                    {positions.map(position => (
                                        <button
                                            key={position.id}
                                            onClick={() => handlePositionSelect(position)}
                                            className="w-full p-4 text-left bg-gray-800 hover:bg-gray-700 border border-gray-700 hover:border-blue-500 rounded-xl transition-all"
                                        >
                                            <div className="flex justify-between">
                                                <span className="font-semibold">{position.ticker}</span>
                                                <span className={(((position.livePrice || position.currentPrice) - position.entryPrice) >= 0) ? 'text-green-400' : 'text-red-400'}>
                                                    {(((position.livePrice || position.currentPrice) - position.entryPrice) / position.entryPrice * 100).toFixed(1)}%
                                                </span>
                                            </div>
                                            <div className="text-sm text-gray-400">
                                                {position.type === 'option' ? `${position.optionType} $${position.strike} ‚Ä¢ ${formatExpirationDate(position.expiration)}` : position.type}
                                            </div>
                                        </button>
                                    ))}
                                    <button
                                        onClick={() => handlePositionSelect(null)}
                                        className="w-full p-4 text-left bg-gray-800 hover:bg-gray-700 border border-gray-700 hover:border-blue-500 rounded-xl transition-all"
                                    >
                                        <div className="font-semibold">ü§∑ General anxiety / no specific position</div>
                                    </button>
                                </div>
                            )}

                            {step === 'response' && (
                                <div>
                                    <div className="bg-gray-800 border border-gray-700 rounded-xl p-4 mb-6">
                                        <pre className="whitespace-pre-wrap text-sm leading-relaxed font-sans">
                                            {aiResponse}
                                        </pre>
                                    </div>
                                    <div className="flex gap-3">
                                        <button
                                            onClick={handleClose}
                                            className="flex-1 py-3 bg-green-600 hover:bg-green-500 rounded-xl font-semibold transition-colors"
                                        >
                                            üí™ Stick to the Plan
                                        </button>
                                        <button
                                            onClick={() => setStep('emotion')}
                                            className="flex-1 py-3 bg-gray-700 hover:bg-gray-600 rounded-xl font-semibold transition-colors"
                                        >
                                            üí¨ Talk More
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Add Position Modal
        const AddPositionModal = ({ isOpen, onClose, onAdd, journalEntries = [], journalStats = {}, settings = {}, lastLossTime = null, lockout = {}, onLockout, positions = [] }) => {
            const [formData, setFormData] = useState({
                ticker: '',
                type: 'stock',
                optionType: 'call',
                strike: '',
                expiration: '',
                entryPrice: '',
                quantity: '',
                strategy: 'swing'
            });
            const [aiRating, setAiRating] = useState(null);
            const [ratingLoading, setRatingLoading] = useState(false);
            const [preTradeWarning, setPreTradeWarning] = useState(null);
            const [showWarningModal, setShowWarningModal] = useState(false);
            const [pendingSubmit, setPendingSubmit] = useState(null);

            // Auto-populate state
            const [stockPrice, setStockPrice] = useState(null);
            const [stockLoading, setStockLoading] = useState(false);
            const [stockError, setStockError] = useState(null);
            const [optionsChain, setOptionsChain] = useState(null);
            const [optionsLoading, setOptionsLoading] = useState(false);
            const [optionsError, setOptionsError] = useState(null);
            const [selectedExpiry, setSelectedExpiry] = useState(null);

            // Fetch stock price when ticker changes
            const fetchStockPrice = async (ticker) => {
                if (!ticker || ticker.length < 1) {
                    setStockPrice(null);
                    setOptionsChain(null);
                    setStockError(null);
                    return;
                }
                setStockLoading(true);
                setStockError(null);
                try {
                    console.log('[AddPosition] Fetching price for:', ticker);
                    const response = await fetch(`/api/yahoo?ticker=${ticker}&type=chart`);

                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('[AddPosition] Got response for', ticker);

                    if (data.chart?.result?.[0]?.meta?.regularMarketPrice) {
                        const price = data.chart.result[0].meta.regularMarketPrice;
                        console.log('[AddPosition] Got price:', price);
                        setStockPrice(price);
                        // Auto-fill entry price for stocks
                        if (formData.type === 'stock') {
                            setFormData(prev => ({ ...prev, entryPrice: price.toFixed(2) }));
                        }
                    } else if (data.chart?.error) {
                        throw new Error(data.chart.error.description || 'Ticker not found');
                    } else if (data.error) {
                        throw new Error(data.error);
                    } else {
                        console.log('[AddPosition] Unexpected data structure:', Object.keys(data));
                        throw new Error('Could not find price data');
                    }
                } catch (error) {
                    console.error('[AddPosition] Error fetching stock price:', error);
                    setStockError(error.message || 'Failed to fetch');
                }
                setStockLoading(false);
            };

            // Fetch options chain when ticker changes and type is option
            const fetchOptionsChain = async (ticker) => {
                if (!ticker || ticker.length < 1) {
                    setOptionsChain(null);
                    setOptionsError(null);
                    return;
                }
                setOptionsLoading(true);
                setOptionsError(null);
                try {
                    console.log('[AddPosition] Fetching options for:', ticker);
                    const response = await fetch(`/api/yahoo?ticker=${ticker}&type=options`);

                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('[AddPosition] Got options response for', ticker);

                    if (data.optionChain?.result?.[0]) {
                        const result = data.optionChain.result[0];
                        console.log('[AddPosition] Got options:', result.expirationDates?.length, 'expirations');
                        setOptionsChain({
                            expirations: result.expirationDates || [],
                            strikes: result.strikes || [],
                            calls: result.options?.[0]?.calls || [],
                            puts: result.options?.[0]?.puts || [],
                            quote: result.quote
                        });
                        if (result.quote?.regularMarketPrice) {
                            setStockPrice(result.quote.regularMarketPrice);
                        }
                    } else if (data.optionChain?.error) {
                        throw new Error(data.optionChain.error.description || 'No options available');
                    } else if (data.error) {
                        throw new Error(data.error);
                    } else {
                        throw new Error('No options data found');
                    }
                } catch (error) {
                    console.error('[AddPosition] Error fetching options:', error);
                    setOptionsError(error.message || 'Failed to fetch options');
                }
                setOptionsLoading(false);
            };

            // Fetch options for a specific expiration
            const fetchOptionsForExpiry = async (ticker, expiry) => {
                setOptionsLoading(true);
                try {
                    const response = await fetch(`/api/yahoo?ticker=${ticker}&type=options&expiry=${expiry}`);
                    const data = await response.json();
                    if (data.optionChain?.result?.[0]?.options?.[0]) {
                        const result = data.optionChain.result[0];
                        const opts = result.options[0];
                        setOptionsChain(prev => ({
                            ...prev,
                            calls: opts.calls || [],
                            puts: opts.puts || [],
                            quote: result.quote || prev?.quote // Keep quote data
                        }));
                        // Update stock price if we got new quote data
                        if (result.quote?.regularMarketPrice) {
                            setStockPrice(result.quote.regularMarketPrice);
                        }
                    }
                } catch (error) {
                    console.error('Error fetching options for expiry:', error);
                }
                setOptionsLoading(false);
            };

            // Handle ticker change with debounce
            const tickerTimeoutRef = useRef(null);
            const handleTickerChange = (e) => {
                const ticker = e.target.value.toUpperCase();
                setFormData(prev => ({ ...prev, ticker }));
                setSelectedExpiry(null);
                setOptionsChain(null);

                // Clear previous timeout
                if (tickerTimeoutRef.current) clearTimeout(tickerTimeoutRef.current);

                // Debounce the API call
                if (ticker.length >= 1) {
                    tickerTimeoutRef.current = setTimeout(() => {
                        fetchStockPrice(ticker);
                        if (formData.type === 'option') {
                            fetchOptionsChain(ticker);
                        }
                    }, 500);
                }
            };

            // Handle type change
            const handleTypeChange = (type) => {
                setFormData(prev => ({ ...prev, type }));
                if (type === 'option' && formData.ticker) {
                    fetchOptionsChain(formData.ticker);
                }
                // Auto-fill stock price when switching to stock
                if (type === 'stock' && stockPrice) {
                    setFormData(prev => ({ ...prev, entryPrice: stockPrice.toFixed(2) }));
                }
            };

            // Handle expiration selection
            const handleExpirySelect = (expiryTimestamp) => {
                setSelectedExpiry(expiryTimestamp);
                const expiryDate = new Date(expiryTimestamp * 1000);
                // Use UTC to get correct date
                const year = expiryDate.getUTCFullYear();
                const month = String(expiryDate.getUTCMonth() + 1).padStart(2, '0');
                const day = String(expiryDate.getUTCDate()).padStart(2, '0');
                const formattedDate = `${year}-${month}-${day}`;
                setFormData(prev => ({ ...prev, expiration: formattedDate }));
                fetchOptionsForExpiry(formData.ticker, expiryTimestamp);
            };

            // Handle strike selection
            const handleStrikeSelect = (option) => {
                setFormData(prev => ({
                    ...prev,
                    strike: option.strike.toString(),
                    entryPrice: ((option.bid + option.ask) / 2).toFixed(2)
                }));
            };

            // Format expiry date for display (using UTC to avoid timezone issues)
            const formatExpiry = (timestamp) => {
                const date = new Date(timestamp * 1000);
                // Use UTC to get correct date (Yahoo timestamps are UTC midnight)
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${months[date.getUTCMonth()]} ${date.getUTCDate()}, ${String(date.getUTCFullYear()).slice(-2)}`;
            };

            // Get filtered options based on call/put selection - show ALL strikes
            const getFilteredOptions = () => {
                if (!optionsChain) return [];
                const options = formData.optionType === 'call' ? optionsChain.calls : optionsChain.puts;
                // Return all options that have any market activity
                return options.filter(opt => opt.bid > 0 || opt.ask > 0 || opt.volume > 0 || opt.openInterest > 0);
            };

            const getAiRating = async () => {
                setRatingLoading(true);
                const result = await analyzeTradeRating(formData);
                setAiRating(result);
                setRatingLoading(false);
            };

            const handleSubmit = (e) => {
                e.preventDefault();

                // CHECK LOCKOUT FIRST
                if (lockout && lockout.active) {
                    setPreTradeWarning({
                        warnings: [{
                            type: 'lockout',
                            severity: 'critical',
                            title: lockout.reason === 'emergency' ? 'üö® Emergency Brake Active' :
                                   lockout.reason === 'daily_loss' ? 'üõë Daily Loss Limit Reached' :
                                   lockout.reason === 'cooldown' ? '‚è≥ Cooldown Active' : 'üîí Trading Locked',
                            message: `Trading locked until ${new Date(lockout.until).toLocaleTimeString()}. Take a break.`,
                            emoji: 'üîí'
                        }],
                        hardBlocks: [{ reason: 'lockout', message: 'You are currently locked out of trading.' }],
                        overallRisk: 'blocked'
                    });
                    setShowWarningModal(true);
                    return;
                }

                const newPosition = {
                    id: Date.now(),
                    ...formData,
                    strike: parseFloat(formData.strike) || 0,
                    entryPrice: parseFloat(formData.entryPrice),
                    currentPrice: parseFloat(formData.entryPrice), // Start at entry
                    quantity: parseFloat(formData.quantity)
                };

                // Analyze the trade before proceeding (with settings and lastLossTime)
                const analysis = analyzeProposedTrade(formData, journalEntries, journalStats, settings, lastLossTime, positions);

                // CHECK FOR HARD BLOCKS (Guardian Mode)
                if (analysis.hardBlocks && analysis.hardBlocks.length > 0) {
                    setPreTradeWarning(analysis);
                    setShowWarningModal(true);
                    // Don't set pendingSubmit - blocked trades can't proceed
                    return;
                }

                // Guardian mode: always show warning, even for low-risk trades
                if (analysis.forceWarning || (analysis.warnings && analysis.warnings.length > 0)) {
                    // Add a "guardian check" warning if no other warnings exist
                    if (analysis.forceWarning && (!analysis.warnings || analysis.warnings.length === 0)) {
                        analysis.warnings = [{
                            type: 'guardian_check',
                            severity: 'low',
                            title: 'Guardian Mode Check',
                            message: 'No red flags detected. You may proceed.',
                            emoji: 'üõ°Ô∏è'
                        }];
                        analysis.overallRisk = 'low';
                    }
                    setPreTradeWarning(analysis);
                    setPendingSubmit(newPosition);
                    setShowWarningModal(true);
                } else {
                    // No warnings, proceed directly
                    completeSubmit(newPosition);
                }
            };

            const completeSubmit = (newPosition) => {
                onAdd(newPosition);
                setFormData({
                    ticker: '',
                    type: 'stock',
                    optionType: 'call',
                    strike: '',
                    expiration: '',
                    entryPrice: '',
                    quantity: '',
                    strategy: 'swing'
                });
                setAiRating(null);
                setStockPrice(null);
                setOptionsChain(null);
                setSelectedExpiry(null);
                setPreTradeWarning(null);
                setShowWarningModal(false);
                setPendingSubmit(null);
                onClose();
            };

            const handleProceedAnyway = () => {
                if (pendingSubmit) {
                    completeSubmit(pendingSubmit);
                }
            };

            const handleCancelTrade = () => {
                setShowWarningModal(false);
                setPreTradeWarning(null);
                setPendingSubmit(null);
            };

            // Reset state when modal closes
            useEffect(() => {
                if (!isOpen) {
                    setStockPrice(null);
                    setOptionsChain(null);
                    setSelectedExpiry(null);
                    setAiRating(null);
                    setPreTradeWarning(null);
                    setShowWarningModal(false);
                    setPendingSubmit(null);
                }
            }, [isOpen]);

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                    <div className="bg-gray-900 border border-gray-700 rounded-2xl w-full max-w-md max-h-[90vh] flex flex-col">
                        <div className="p-6 overflow-y-auto">
                            <div className="flex justify-between items-center mb-6">
                                <h2 className="text-2xl font-bold">‚ûï Add Position</h2>
                                <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl">&times;</button>
                            </div>

                            <form onSubmit={handleSubmit} className="space-y-4">
                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">Ticker</label>
                                    <div className="relative">
                                        <input
                                            type="text"
                                            value={formData.ticker}
                                            onChange={handleTickerChange}
                                            placeholder="NVDA, SPY, BTC..."
                                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-xl text-white focus:border-blue-500 focus:outline-none"
                                            required
                                        />
                                        {stockLoading && (
                                            <span className="absolute right-3 top-3 text-gray-400">‚è≥</span>
                                        )}
                                    </div>
                                    {stockPrice && !stockLoading && (
                                        <div className="mt-2 p-2 bg-green-900/30 border border-green-500/50 rounded-lg flex justify-between items-center">
                                            <span className="text-gray-400 text-sm">‚úÖ Current Price:</span>
                                            <span className="text-green-400 font-bold">${stockPrice.toFixed(2)}</span>
                                        </div>
                                    )}
                                    {stockError && !stockLoading && (
                                        <div className="mt-2 p-2 bg-red-900/30 border border-red-500/50 rounded-lg text-red-400 text-sm">
                                            ‚ùå {stockError}
                                        </div>
                                    )}
                                    {stockLoading && (
                                        <div className="mt-2 p-2 bg-blue-900/30 border border-blue-500/50 rounded-lg text-blue-400 text-sm">
                                            ‚è≥ Fetching price...
                                        </div>
                                    )}
                                </div>

                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">Type</label>
                                    <div className="grid grid-cols-3 gap-2">
                                        {['stock', 'option', 'crypto'].map(type => (
                                            <button
                                                key={type}
                                                type="button"
                                                onClick={() => handleTypeChange(type)}
                                                className={`p-2 rounded-xl border transition-all ${formData.type === type ? 'bg-blue-600 border-blue-500' : 'bg-gray-800 border-gray-700 hover:border-gray-600'}`}
                                            >
                                                {type.charAt(0).toUpperCase() + type.slice(1)}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {formData.type === 'option' && (
                                    <>
                                        <div className="grid grid-cols-2 gap-3">
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-1">Call/Put</label>
                                                <div className="grid grid-cols-2 gap-2">
                                                    {['call', 'put'].map(ot => (
                                                        <button
                                                            key={ot}
                                                            type="button"
                                                            onClick={() => setFormData({...formData, optionType: ot})}
                                                            className={`p-2 rounded-xl border transition-all ${formData.optionType === ot ? (ot === 'call' ? 'bg-green-600 border-green-500' : 'bg-red-600 border-red-500') : 'bg-gray-800 border-gray-700'}`}
                                                        >
                                                            {ot.toUpperCase()}
                                                        </button>
                                                    ))}
                                                </div>
                                            </div>
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-1">Strike</label>
                                                <input
                                                    type="number"
                                                    value={formData.strike}
                                                    onChange={(e) => setFormData({...formData, strike: e.target.value})}
                                                    placeholder={stockPrice ? `~$${stockPrice.toFixed(0)}` : '150'}
                                                    className="w-full p-3 bg-gray-800 border border-gray-700 rounded-xl text-white focus:border-blue-500 focus:outline-none"
                                                />
                                            </div>
                                        </div>

                                        {/* Options Loading/Error States */}
                                        {optionsLoading && (
                                            <div className="p-3 bg-blue-900/30 border border-blue-500/50 rounded-xl text-blue-400 text-sm text-center">
                                                ‚è≥ Loading options chain for {formData.ticker}...
                                            </div>
                                        )}
                                        {optionsError && !optionsLoading && (
                                            <div className="p-3 bg-red-900/30 border border-red-500/50 rounded-xl text-red-400 text-sm">
                                                ‚ùå {optionsError}
                                                <button
                                                    type="button"
                                                    onClick={() => fetchOptionsChain(formData.ticker)}
                                                    className="ml-2 underline hover:text-red-300"
                                                >
                                                    Retry
                                                </button>
                                            </div>
                                        )}
                                        {!optionsChain && !optionsLoading && !optionsError && formData.ticker && (
                                            <div className="p-3 bg-gray-800/50 border border-gray-600 rounded-xl text-gray-400 text-sm text-center">
                                                üìä Options chain will load after ticker is validated
                                                <button
                                                    type="button"
                                                    onClick={() => fetchOptionsChain(formData.ticker)}
                                                    className="block mx-auto mt-2 px-3 py-1 bg-blue-600 hover:bg-blue-500 rounded-lg text-white text-xs"
                                                >
                                                    Load Options Chain
                                                </button>
                                            </div>
                                        )}

                                        {/* Options Chain - Expirations */}
                                        {optionsChain && optionsChain.expirations?.length > 0 && (
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-2">üìÖ Select Expiration ({optionsChain.expirations.length} available)</label>
                                                <div className="flex flex-wrap gap-1 max-h-40 overflow-y-auto p-2 bg-gray-800/50 rounded-xl">
                                                    {optionsChain.expirations.map(exp => (
                                                        <button
                                                            key={exp}
                                                            type="button"
                                                            onClick={() => handleExpirySelect(exp)}
                                                            className={`px-2 py-1 text-xs rounded-lg transition-all ${
                                                                selectedExpiry === exp
                                                                    ? 'bg-blue-600 text-white'
                                                                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                                                            }`}
                                                        >
                                                            {formatExpiry(exp)}
                                                        </button>
                                                    ))}
                                                </div>
                                            </div>
                                        )}

                                        {/* Options Chain - Strikes */}
                                        {selectedExpiry && (optionsChain?.calls?.length > 0 || optionsChain?.puts?.length > 0) && (
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-2">
                                                    üéØ Select Strike ({formData.optionType.toUpperCase()})
                                                    {optionsLoading && <span className="ml-2">‚è≥</span>}
                                                </label>
                                                <div className="max-h-64 overflow-y-auto bg-gray-800/50 rounded-xl">
                                                    <table className="w-full text-xs">
                                                        <thead className="sticky top-0 bg-gray-800 z-10">
                                                            <tr className="text-gray-400">
                                                                <th className="p-2 text-left">Strike</th>
                                                                <th className="p-2 text-right">Bid</th>
                                                                <th className="p-2 text-right">Ask</th>
                                                                <th className="p-2 text-right">Vol</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            {getFilteredOptions().map(opt => {
                                                                const isITM = formData.optionType === 'call'
                                                                    ? opt.strike < stockPrice
                                                                    : opt.strike > stockPrice;
                                                                const isSelected = formData.strike === opt.strike.toString();
                                                                return (
                                                                    <tr
                                                                        key={opt.strike}
                                                                        onClick={() => handleStrikeSelect(opt)}
                                                                        className={`cursor-pointer transition-all ${
                                                                            isSelected
                                                                                ? 'bg-blue-600'
                                                                                : isITM
                                                                                    ? 'bg-green-900/20 hover:bg-green-900/40'
                                                                                    : 'hover:bg-gray-700'
                                                                        }`}
                                                                    >
                                                                        <td className="p-2 font-semibold">
                                                                            ${opt.strike}
                                                                            {isITM && <span className="ml-1 text-green-400 text-xs">ITM</span>}
                                                                        </td>
                                                                        <td className="p-2 text-right text-green-400">${opt.bid?.toFixed(2) || '-'}</td>
                                                                        <td className="p-2 text-right text-red-400">${opt.ask?.toFixed(2) || '-'}</td>
                                                                        <td className="p-2 text-right text-gray-400">{opt.volume || '-'}</td>
                                                                    </tr>
                                                                );
                                                            })}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            </div>
                                        )}

                                        {/* Show selected expiration */}
                                        {formData.expiration && (
                                            <div className="p-3 bg-purple-900/30 border border-purple-500/50 rounded-xl">
                                                <div className="flex justify-between items-center">
                                                    <span className="text-gray-400 text-sm">Selected Expiration:</span>
                                                    <span className="text-purple-300 font-bold">
                                                        {new Date(formData.expiration + 'T00:00:00').toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' })}
                                                    </span>
                                                </div>
                                            </div>
                                        )}

                                        {/* Only show manual date input if options chain failed to load */}
                                        {!optionsChain && !optionsLoading && optionsError && (
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-1">
                                                    Enter expiration manually (options expire on Fridays):
                                                </label>
                                                <input
                                                    type="date"
                                                    value={formData.expiration}
                                                    onChange={(e) => setFormData({...formData, expiration: e.target.value})}
                                                    className="w-full p-3 bg-gray-800 border border-gray-700 rounded-xl text-white focus:border-blue-500 focus:outline-none"
                                                />
                                            </div>
                                        )}
                                    </>
                                )}

                                <div className="grid grid-cols-2 gap-3">
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-1">Entry Price</label>
                                        <input
                                            type="number"
                                            step="0.01"
                                            value={formData.entryPrice}
                                            onChange={(e) => setFormData({...formData, entryPrice: e.target.value})}
                                            placeholder="0.00"
                                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-xl text-white focus:border-blue-500 focus:outline-none"
                                            required
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-1">Quantity</label>
                                        <input
                                            type="number"
                                            step="0.0001"
                                            value={formData.quantity}
                                            onChange={(e) => setFormData({...formData, quantity: e.target.value})}
                                            placeholder="10"
                                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-xl text-white focus:border-blue-500 focus:outline-none"
                                            required
                                        />
                                    </div>
                                </div>

                                <div>
                                    <label className="block text-sm text-gray-400 mb-1">Strategy</label>
                                    <div className="grid grid-cols-3 gap-2">
                                        {['day', 'swing', 'long'].map(strat => (
                                            <button
                                                key={strat}
                                                type="button"
                                                onClick={() => setFormData({...formData, strategy: strat})}
                                                className={`p-2 rounded-xl border transition-all text-sm ${formData.strategy === strat ? 'bg-blue-600 border-blue-500' : 'bg-gray-800 border-gray-700'}`}
                                            >
                                                {strat.charAt(0).toUpperCase() + strat.slice(1)}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* AI Trade Rating */}
                                <div className="mt-4 pt-4 border-t border-gray-700">
                                    <button
                                        type="button"
                                        onClick={getAiRating}
                                        disabled={ratingLoading || !formData.ticker || !formData.entryPrice}
                                        className="w-full py-2 bg-purple-600 hover:bg-purple-500 disabled:bg-gray-700 disabled:text-gray-500 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2"
                                    >
                                        {ratingLoading ? (
                                            <>‚è≥ Analyzing...</>
                                        ) : (
                                            <>üß† Get AI Rating</>
                                        )}
                                    </button>

                                    {aiRating && (
                                        <div className={`mt-3 p-3 rounded-xl border ${
                                            aiRating.color === 'green' ? 'bg-green-900/30 border-green-600' :
                                            aiRating.color === 'red' ? 'bg-red-900/30 border-red-600' :
                                            'bg-yellow-900/30 border-yellow-600'
                                        }`}>
                                            <div className="flex items-center gap-3 mb-2">
                                                <div className={`text-3xl font-bold ${
                                                    aiRating.color === 'green' ? 'text-green-400' :
                                                    aiRating.color === 'red' ? 'text-red-400' :
                                                    'text-yellow-400'
                                                }`}>
                                                    {aiRating.rating}/10
                                                </div>
                                                <div className="text-sm">
                                                    {aiRating.rating >= 7 ? '‚úÖ Looks Good' :
                                                     aiRating.rating >= 4 ? '‚ö†Ô∏è Proceed with Caution' :
                                                     'üö´ High Risk'}
                                                </div>
                                            </div>
                                            <div className="space-y-1 text-sm">
                                                {aiRating.reasons.map((reason, i) => (
                                                    <div key={i} className="text-gray-300">{reason}</div>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>

                                <button
                                    type="submit"
                                    className="w-full py-3 bg-green-600 hover:bg-green-500 rounded-xl font-semibold transition-colors mt-4"
                                >
                                    ‚úÖ Add Position
                                </button>
                            </form>
                        </div>
                    </div>

                    {/* Pre-Trade Warning Modal */}
                    {showWarningModal && preTradeWarning && (
                        <div className="fixed inset-0 bg-black/90 z-[60] flex items-center justify-center p-4">
                            <div className="bg-gray-900 border-2 border-red-500/50 rounded-2xl w-full max-w-md max-h-[85vh] overflow-y-auto">
                                <div className="p-4 border-b border-red-500/30 bg-red-900/20">
                                    <div className="flex items-center gap-3">
                                        <span className="text-4xl">üö®</span>
                                        <div>
                                            <h2 className="text-xl font-bold text-red-400">Hold Up!</h2>
                                            <p className="text-sm text-gray-400">AI detected concerns with this trade</p>
                                        </div>
                                    </div>
                                </div>

                                <div className="p-4 space-y-4">
                                    {/* Overall Risk Level */}
                                    <div className={`p-4 rounded-xl border ${
                                        preTradeWarning.overallRisk === 'blocked' ? 'bg-red-900/50 border-red-600 animate-pulse' :
                                        preTradeWarning.overallRisk === 'high' ? 'bg-red-900/30 border-red-500' :
                                        preTradeWarning.overallRisk === 'medium' ? 'bg-yellow-900/30 border-yellow-500' :
                                        'bg-blue-900/30 border-blue-500'
                                    }`}>
                                        <div className="text-center">
                                            <div className={`text-2xl font-bold ${
                                                preTradeWarning.overallRisk === 'blocked' ? 'text-red-500' :
                                                preTradeWarning.overallRisk === 'high' ? 'text-red-400' :
                                                preTradeWarning.overallRisk === 'medium' ? 'text-yellow-400' :
                                                'text-blue-400'
                                            }`}>
                                                {preTradeWarning.overallRisk === 'blocked' ? 'üö´ TRADE BLOCKED' :
                                                 preTradeWarning.overallRisk === 'high' ? '‚õî HIGH RISK' :
                                                 preTradeWarning.overallRisk === 'medium' ? '‚ö†Ô∏è MEDIUM RISK' :
                                                 'üí° LOW RISK'}
                                            </div>
                                            {preTradeWarning.scenarioWinRate !== null && (
                                                <div className="mt-2 text-lg">
                                                    Your win rate in this exact scenario: <span className={`font-bold ${preTradeWarning.scenarioWinRate >= 50 ? 'text-green-400' : 'text-red-400'}`}>
                                                        {preTradeWarning.scenarioWinRate.toFixed(0)}%
                                                    </span>
                                                    <span className="text-gray-500 text-sm"> ({preTradeWarning.scenarioTradeCount} trades)</span>
                                                </div>
                                            )}
                                            {preTradeWarning.lossStreak >= 2 && (
                                                <div className="mt-2 text-red-400 font-bold animate-pulse">
                                                    üî• You're on a {preTradeWarning.lossStreak}-trade losing streak
                                                </div>
                                            )}
                                        </div>
                                    </div>

                                    {/* Individual Warnings */}
                                    <div className="space-y-2">
                                        {preTradeWarning.warnings.map((warning, idx) => (
                                            <div key={idx} className={`p-3 rounded-xl border ${
                                                warning.severity === 'high' ? 'bg-red-900/20 border-red-500/50' :
                                                'bg-yellow-900/20 border-yellow-500/50'
                                            }`}>
                                                <div className="flex items-start gap-3">
                                                    <span className="text-2xl">{warning.emoji}</span>
                                                    <div>
                                                        <div className={`font-semibold ${
                                                            warning.severity === 'high' ? 'text-red-400' : 'text-yellow-400'
                                                        }`}>
                                                            {warning.title}
                                                        </div>
                                                        <div className="text-sm text-gray-400">{warning.message}</div>
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>

                                    {/* Positive Insights if any */}
                                    {preTradeWarning.insights && preTradeWarning.insights.length > 0 && (
                                        <div className="space-y-2">
                                            {preTradeWarning.insights.map((insight, idx) => (
                                                <div key={idx} className="p-3 rounded-xl bg-green-900/20 border border-green-500/50">
                                                    <div className="flex items-start gap-3">
                                                        <span className="text-2xl">{insight.emoji}</span>
                                                        <div>
                                                            <div className="font-semibold text-green-400">{insight.title}</div>
                                                            <div className="text-sm text-gray-400">{insight.message}</div>
                                                        </div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}

                                    {/* Hard Block Message */}
                                    {preTradeWarning.hardBlocks && preTradeWarning.hardBlocks.length > 0 && (
                                        <div className="p-4 bg-red-900/40 border-2 border-red-500 rounded-xl">
                                            <div className="text-center">
                                                <div className="text-lg font-bold text-red-400 mb-2">Guardian Mode has blocked this trade</div>
                                                {preTradeWarning.hardBlocks.map((block, idx) => (
                                                    <div key={idx} className="text-sm text-red-300">{block.message}</div>
                                                ))}
                                            </div>
                                        </div>
                                    )}

                                    {/* Action Buttons */}
                                    <div className="flex gap-3 pt-2">
                                        <button
                                            onClick={handleCancelTrade}
                                            className={`py-3 rounded-xl font-semibold transition-colors ${
                                                preTradeWarning.overallRisk === 'blocked'
                                                    ? 'flex-1 bg-gray-700 hover:bg-gray-600'
                                                    : 'flex-1 bg-gray-700 hover:bg-gray-600'
                                            }`}
                                        >
                                            {preTradeWarning.overallRisk === 'blocked' ? 'üëç OK, I Understand' : '‚ùå Cancel Trade'}
                                        </button>
                                        {preTradeWarning.overallRisk !== 'blocked' && (
                                            <button
                                                onClick={handleProceedAnyway}
                                                className={`flex-1 py-3 rounded-xl font-semibold transition-colors ${
                                                    preTradeWarning.overallRisk === 'high'
                                                        ? 'bg-red-700 hover:bg-red-600 text-red-100'
                                                        : 'bg-yellow-700 hover:bg-yellow-600 text-yellow-100'
                                                }`}
                                            >
                                                ‚ö†Ô∏è Proceed Anyway
                                            </button>
                                        )}
                                    </div>

                                    <p className="text-xs text-gray-500 text-center">
                                        This analysis is based on your trading history. Past performance doesn't guarantee future results.
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Popular patterns for quick-add (most commonly used)
        const POPULAR_PATTERNS = ['wedgedown', 'wedgeup', 'doubletop', 'doublebottom', 'headandshoulders', 'headandshouldersinv', 'channelup', 'channeldown', 'tlresistance', 'tlsupport', 'tltriangle', 'wedgeresistance', 'wedgesupport'];

        // Pattern Manager Component - Search, Add, Remove patterns
        const PatternManager = ({ enabledPatterns, onUpdate }) => {
            const [searchQuery, setSearchQuery] = useState('');
            const [showAllPatterns, setShowAllPatterns] = useState(false);

            const addPattern = (patternId) => {
                if (!enabledPatterns.includes(patternId)) {
                    onUpdate([...enabledPatterns, patternId]);
                }
            };

            const removePattern = (patternId) => {
                onUpdate(enabledPatterns.filter(id => id !== patternId));
            };

            // Get pattern objects for enabled patterns
            const userPatterns = enabledPatterns.map(id => CHART_PATTERNS.find(p => p.id === id)).filter(Boolean);

            // Filter patterns by search query
            const searchResults = searchQuery.trim()
                ? CHART_PATTERNS.filter(p =>
                    p.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
                    p.desc.toLowerCase().includes(searchQuery.toLowerCase()) ||
                    p.category.toLowerCase().includes(searchQuery.toLowerCase()) ||
                    p.type.toLowerCase().includes(searchQuery.toLowerCase())
                  )
                : [];

            // Popular patterns not yet added
            const availablePopular = POPULAR_PATTERNS
                .map(id => CHART_PATTERNS.find(p => p.id === id))
                .filter(p => p && !enabledPatterns.includes(p.id));

            // All patterns not yet added (for browse mode)
            const availablePatterns = CHART_PATTERNS.filter(p => !enabledPatterns.includes(p.id));

            return (
                <div>
                    <label className="block text-sm text-gray-400 mb-2">My Chart Patterns</label>

                    {/* User's Current Patterns */}
                    <div className="mb-4">
                        {userPatterns.length > 0 ? (
                            <div className="flex flex-wrap gap-2 p-3 bg-gray-800 rounded-xl border border-gray-700 max-h-32 overflow-y-auto">
                                {userPatterns.map(pattern => (
                                    <span
                                        key={pattern.id}
                                        className={`inline-flex items-center gap-1 px-2 py-1 rounded-lg text-xs font-medium ${
                                            pattern.type === 'bullish' ? 'bg-green-500/20 text-green-300 border border-green-500/30' :
                                            pattern.type === 'bearish' ? 'bg-red-500/20 text-red-300 border border-red-500/30' :
                                            'bg-yellow-500/20 text-yellow-300 border border-yellow-500/30'
                                        }`}
                                    >
                                        <span>{pattern.name}</span>
                                        <span>{pattern.emoji}</span>
                                        <button
                                            onClick={() => removePattern(pattern.id)}
                                            className="ml-1 hover:text-white"
                                        >√ó</button>
                                    </span>
                                ))}
                            </div>
                        ) : (
                            <div className="p-4 bg-gray-800 rounded-xl border border-gray-700 text-center text-gray-500 text-sm">
                                No patterns added yet. Search or add from popular patterns below.
                            </div>
                        )}
                        <div className="mt-1 text-xs text-gray-500">{userPatterns.length} pattern{userPatterns.length !== 1 ? 's' : ''} selected</div>
                    </div>

                    {/* Search Box */}
                    <div className="mb-4">
                        <div className="relative">
                            <input
                                type="text"
                                placeholder="Search patterns (e.g., wedge, bullish, reversal...)"
                                value={searchQuery}
                                onChange={(e) => setSearchQuery(e.target.value)}
                                className="w-full px-4 py-2 pl-10 bg-gray-800 border border-gray-700 rounded-xl text-sm focus:outline-none focus:border-purple-500"
                            />
                            <span className="absolute left-3 top-2.5 text-gray-500">üîç</span>
                        </div>

                        {/* Search Results */}
                        {searchQuery.trim() && (
                            <div className="mt-2 max-h-40 overflow-y-auto space-y-1">
                                {searchResults.length > 0 ? (
                                    searchResults.map(pattern => {
                                        const isAdded = enabledPatterns.includes(pattern.id);
                                        return (
                                            <div
                                                key={pattern.id}
                                                className={`flex items-center justify-between p-2 rounded-lg ${
                                                    isAdded ? 'bg-purple-600/20 border border-purple-500/30' : 'bg-gray-700/50 hover:bg-gray-700'
                                                }`}
                                            >
                                                <span className="flex items-center gap-2 text-sm">
                                                    <span>{pattern.name}</span>
                                                    <span className={`text-xs px-1.5 py-0.5 rounded ${
                                                        pattern.type === 'bullish' ? 'bg-green-500/20 text-green-400' :
                                                        pattern.type === 'bearish' ? 'bg-red-500/20 text-red-400' :
                                                        'bg-gray-500/20 text-gray-400'
                                                    }`}>{pattern.emoji} {pattern.type}</span>
                                                </span>
                                                {isAdded ? (
                                                    <button
                                                        onClick={() => removePattern(pattern.id)}
                                                        className="px-2 py-1 text-xs bg-red-600 hover:bg-red-500 rounded"
                                                    >Remove</button>
                                                ) : (
                                                    <button
                                                        onClick={() => addPattern(pattern.id)}
                                                        className="px-2 py-1 text-xs bg-green-600 hover:bg-green-500 rounded"
                                                    >+ Add</button>
                                                )}
                                            </div>
                                        );
                                    })
                                ) : (
                                    <div className="text-center text-gray-500 text-sm py-2">No patterns found</div>
                                )}
                            </div>
                        )}
                    </div>

                    {/* Popular Patterns Quick Add */}
                    {availablePopular.length > 0 && !searchQuery.trim() && (
                        <div className="mb-4">
                            <div className="text-xs text-gray-400 mb-2">Popular Patterns</div>
                            <div className="flex flex-wrap gap-2">
                                {availablePopular.map(pattern => (
                                    <button
                                        key={pattern.id}
                                        onClick={() => addPattern(pattern.id)}
                                        className="inline-flex items-center gap-1 px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded-lg text-xs transition-colors"
                                    >
                                        <span>{pattern.name}</span>
                                        <span>{pattern.emoji}</span>
                                        <span className="text-green-400 ml-1">+</span>
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Browse All Patterns */}
                    {!searchQuery.trim() && (
                        <div>
                            <button
                                onClick={() => setShowAllPatterns(!showAllPatterns)}
                                className="text-xs text-purple-400 hover:text-purple-300 mb-2"
                            >
                                {showAllPatterns ? '‚ñº Hide all patterns' : '‚ñ∂ Browse all patterns'} ({availablePatterns.length} available)
                            </button>

                            {showAllPatterns && (
                                <div className="max-h-48 overflow-y-auto space-y-1 p-2 bg-gray-800 rounded-xl border border-gray-700">
                                    {availablePatterns.map(pattern => (
                                        <div
                                            key={pattern.id}
                                            className="flex items-center justify-between p-2 rounded-lg bg-gray-700/50 hover:bg-gray-700"
                                        >
                                            <span className="flex items-center gap-2 text-sm">
                                                <span>{pattern.name}</span>
                                                <span className={`text-xs px-1.5 py-0.5 rounded ${
                                                    pattern.type === 'bullish' ? 'bg-green-500/20 text-green-400' :
                                                    pattern.type === 'bearish' ? 'bg-red-500/20 text-red-400' :
                                                    'bg-gray-500/20 text-gray-400'
                                                }`}>{pattern.emoji} {pattern.type}</span>
                                            </span>
                                            <button
                                                onClick={() => addPattern(pattern.id)}
                                                className="px-2 py-1 text-xs bg-green-600 hover:bg-green-500 rounded"
                                            >+ Add</button>
                                        </div>
                                    ))}
                                    {availablePatterns.length === 0 && (
                                        <div className="text-center text-gray-500 text-sm py-2">All patterns added!</div>
                                    )}
                                </div>
                            )}
                        </div>
                    )}

                    {/* Quick Actions */}
                    <div className="flex gap-2 mt-3">
                        <button
                            onClick={() => onUpdate(CHART_PATTERNS.map(p => p.id))}
                            className="px-3 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded-lg"
                        >Add All</button>
                        <button
                            onClick={() => onUpdate([])}
                            className="px-3 py-1 text-xs bg-gray-700 hover:bg-gray-600 rounded-lg"
                        >Clear All</button>
                        <button
                            onClick={() => onUpdate(POPULAR_PATTERNS)}
                            className="px-3 py-1 text-xs bg-purple-600 hover:bg-purple-500 rounded-lg"
                        >Reset to Popular</button>
                    </div>
                </div>
            );
        };

        // Settings Modal
        const SettingsModal = ({
            isOpen, onClose, settings, onSave,
            userName, onUserNameChange,
            supportedBrokerages, connectedBrokerages, brokerageLoading,
            brokerageSyncTime, brokerageError, onConnectBrokerage, onSyncBrokerages,
            autoImportTrades, onToggleAutoImport
        }) => {
            const [localSettings, setLocalSettings] = useState(settings);
            const [showBrokerageList, setShowBrokerageList] = useState(false);
            const [localUserName, setLocalUserName] = useState(userName || 'Trader');

            useEffect(() => {
                setLocalSettings(settings);
            }, [settings]);

            useEffect(() => {
                setLocalUserName(userName || 'Trader');
            }, [userName]);

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-start justify-center p-4 pt-8 overflow-y-auto">
                    <div className="bg-gray-900 border border-gray-700 rounded-2xl w-full max-w-md max-h-[90vh] overflow-hidden flex flex-col">
                        {/* Header - always visible */}
                        <div className="p-4 border-b border-gray-700 flex justify-between items-center sticky top-0 bg-gray-900 z-10">
                            <h2 className="text-2xl font-bold">‚öôÔ∏è Settings</h2>
                            <button onClick={onClose} className="text-gray-400 hover:text-white text-3xl font-bold w-10 h-10 flex items-center justify-center rounded-xl hover:bg-gray-800">&times;</button>
                        </div>

                        {/* Scrollable content */}
                        <div className="p-6 overflow-y-auto flex-1">
                            <div className="space-y-6">
                                {/* User Name */}
                                <div>
                                    <label className="block text-sm text-gray-400 mb-2">Your Name</label>
                                    <input
                                        type="text"
                                        value={localUserName}
                                        onChange={(e) => setLocalUserName(e.target.value)}
                                        onBlur={() => onUserNameChange && onUserNameChange(localUserName.trim() || 'Trader')}
                                        placeholder="What should we call you?"
                                        className="w-full px-4 py-3 bg-gray-800 border border-gray-700 rounded-xl focus:border-blue-500 focus:outline-none"
                                    />
                                    <p className="text-xs text-gray-500 mt-1">Used for personalized greetings</p>
                                </div>

                                <div>
                                    <label className="block text-sm text-gray-400 mb-2">AI Personality</label>
                                    <div className="space-y-2">
                                        {[
                                            { id: 'homie', label: 'üî• The Aggressive One', desc: 'Street-smart, hype, real talk' },
                                            { id: 'sergeant', label: 'üí™ Drill Sergeant', desc: 'No-nonsense, tough love' },
                                            { id: 'mentor', label: 'üßò Wise Mentor', desc: 'Calm, measured, thoughtful' },
                                            { id: 'nerd', label: 'ü§ì Data Nerd', desc: 'Stats-focused, analytical' }
                                        ].map(p => (
                                            <button
                                                key={p.id}
                                                onClick={() => setLocalSettings({...localSettings, personality: p.id})}
                                                className={`w-full p-3 text-left rounded-xl border transition-all ${localSettings.personality === p.id ? 'bg-blue-600/20 border-blue-500' : 'bg-gray-800 border-gray-700'}`}
                                            >
                                                <div className="font-semibold">{p.label}</div>
                                                <div className="text-sm text-gray-400">{p.desc}</div>
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Trading Mode Selector */}
                                <div>
                                    <label className="block text-sm text-gray-400 mb-2">Trading Mode</label>
                                    <div className="space-y-2">
                                        {[
                                            { id: 'guardian', icon: 'üõ°Ô∏è', label: 'Guardian Mode', desc: 'Maximum protection. Warnings on every trade.', color: 'red' },
                                            { id: 'standard', icon: '‚öñÔ∏è', label: 'Standard Mode', desc: 'Balanced. Warnings for risky trades only.', color: 'blue' },
                                            { id: 'aggressive', icon: 'üöÄ', label: 'Send It Mode', desc: 'Minimal warnings. [For Apes and Degens]', color: 'yellow' }
                                        ].map(mode => (
                                            <button
                                                key={mode.id}
                                                onClick={() => setLocalSettings({...localSettings, tradingMode: mode.id})}
                                                className={`w-full p-4 text-left rounded-xl border-2 transition-all ${
                                                    localSettings.tradingMode === mode.id
                                                        ? mode.color === 'red' ? 'bg-red-600/20 border-red-500'
                                                          : mode.color === 'blue' ? 'bg-blue-600/20 border-blue-500'
                                                          : 'bg-yellow-600/20 border-yellow-500'
                                                        : 'bg-gray-800 border-gray-700 hover:border-gray-500'
                                                }`}
                                            >
                                                <div className="flex items-center gap-3">
                                                    <span className="text-2xl">{mode.icon}</span>
                                                    <div>
                                                        <div className="font-semibold">{mode.label}</div>
                                                        <div className="text-sm text-gray-400">{mode.desc}</div>
                                                    </div>
                                                </div>
                                            </button>
                                        ))}
                                    </div>

                                    {/* Guardian Mode Settings Panel */}
                                    {localSettings.tradingMode === 'guardian' && (
                                        <div className="mt-4 p-4 bg-red-500/10 border border-red-500/30 rounded-xl space-y-4">
                                            <div className="text-sm font-semibold text-red-300">Guardian Settings</div>

                                            {/* Daily Loss Limit */}
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-medium">Daily Loss Limit</div>
                                                    <div className="text-xs text-gray-400">Lock out after losing this much</div>
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    <button
                                                        onClick={() => {
                                                            const gs = localSettings.guardianSettings || {};
                                                            const enabled = gs.dailyLossLimitEnabled !== false;
                                                            setLocalSettings({...localSettings, guardianSettings: {...gs, dailyLossLimitEnabled: !enabled}});
                                                        }}
                                                        className={`w-10 h-6 rounded-full transition-colors ${(localSettings.guardianSettings?.dailyLossLimitEnabled !== false) ? 'bg-red-500' : 'bg-gray-600'}`}
                                                    >
                                                        <div className={`w-4 h-4 bg-white rounded-full transition-transform ${(localSettings.guardianSettings?.dailyLossLimitEnabled !== false) ? 'translate-x-5' : 'translate-x-1'}`} />
                                                    </button>
                                                </div>
                                            </div>
                                            {(localSettings.guardianSettings?.dailyLossLimitEnabled !== false) && (
                                                <div className="relative">
                                                    <span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">$</span>
                                                    <input
                                                        type="number"
                                                        value={localSettings.guardianSettings?.dailyLossLimit ?? ''}
                                                        onChange={(e) => {
                                                            const val = e.target.value === '' ? '' : parseInt(e.target.value);
                                                            setLocalSettings({...localSettings, guardianSettings: {...(localSettings.guardianSettings || {}), dailyLossLimit: val}});
                                                        }}
                                                        onBlur={(e) => {
                                                            // Set default if empty when leaving field
                                                            if (e.target.value === '' || parseInt(e.target.value) <= 0) {
                                                                setLocalSettings({...localSettings, guardianSettings: {...(localSettings.guardianSettings || {}), dailyLossLimit: 500}});
                                                            }
                                                        }}
                                                        className="w-full pl-7 pr-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-sm focus:outline-none focus:border-red-500"
                                                        min="1"
                                                        placeholder="500"
                                                    />
                                                </div>
                                            )}

                                            {/* Cooldown Timer */}
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-medium">Loss Cooldown</div>
                                                    <div className="text-xs text-gray-400">Wait period after each loss</div>
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    <button
                                                        onClick={() => {
                                                            const gs = localSettings.guardianSettings || {};
                                                            setLocalSettings({...localSettings, guardianSettings: {...gs, cooldownEnabled: !gs.cooldownEnabled}});
                                                        }}
                                                        className={`w-10 h-6 rounded-full transition-colors ${localSettings.guardianSettings?.cooldownEnabled ? 'bg-red-500' : 'bg-gray-600'}`}
                                                    >
                                                        <div className={`w-4 h-4 bg-white rounded-full transition-transform ${localSettings.guardianSettings?.cooldownEnabled ? 'translate-x-5' : 'translate-x-1'}`} />
                                                    </button>
                                                </div>
                                            </div>
                                            {localSettings.guardianSettings?.cooldownEnabled && (
                                                <div className="flex gap-2">
                                                    {[2, 5, 10, 15].map(mins => (
                                                        <button
                                                            key={mins}
                                                            onClick={() => setLocalSettings({...localSettings, guardianSettings: {...(localSettings.guardianSettings || {}), cooldownMinutes: mins}})}
                                                            className={`flex-1 py-2 rounded-lg text-sm font-medium transition-colors ${(localSettings.guardianSettings?.cooldownMinutes || 5) === mins ? 'bg-red-500 text-white' : 'bg-gray-700 text-gray-300'}`}
                                                        >
                                                            {mins}m
                                                        </button>
                                                    ))}
                                                </div>
                                            )}

                                            {/* Block Bad Patterns */}
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-medium">Block Bad Patterns</div>
                                                    <div className="text-xs text-gray-400">Hard block trades with &lt;20% win rate</div>
                                                </div>
                                                <button
                                                    onClick={() => {
                                                        const gs = localSettings.guardianSettings || {};
                                                        setLocalSettings({...localSettings, guardianSettings: {...gs, blockBadPatterns: !gs.blockBadPatterns}});
                                                    }}
                                                    className={`w-10 h-6 rounded-full transition-colors ${localSettings.guardianSettings?.blockBadPatterns ? 'bg-red-500' : 'bg-gray-600'}`}
                                                >
                                                    <div className={`w-4 h-4 bg-white rounded-full transition-transform ${localSettings.guardianSettings?.blockBadPatterns ? 'translate-x-5' : 'translate-x-1'}`} />
                                                </button>
                                            </div>

                                            {/* Revenge Trade Detection */}
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-sm font-medium">Revenge Trade Detection</div>
                                                    <div className="text-xs text-gray-400">AI detects emotional trading</div>
                                                </div>
                                                <button
                                                    onClick={() => {
                                                        const gs = localSettings.guardianSettings || {};
                                                        setLocalSettings({...localSettings, guardianSettings: {...gs, revengeDetection: !gs.revengeDetection}});
                                                    }}
                                                    className={`w-10 h-6 rounded-full transition-colors ${localSettings.guardianSettings?.revengeDetection ? 'bg-red-500' : 'bg-gray-600'}`}
                                                >
                                                    <div className={`w-4 h-4 bg-white rounded-full transition-transform ${localSettings.guardianSettings?.revengeDetection ? 'translate-x-5' : 'translate-x-1'}`} />
                                                </button>
                                            </div>
                                        </div>
                                    )}

                                    {/* Standard Mode Info */}
                                    {localSettings.tradingMode === 'standard' && (
                                        <div className="mt-3 p-3 bg-blue-500/10 border border-blue-500/30 rounded-xl text-sm text-blue-300">
                                            Warnings shown for: 0DTE options, loss streaks, historically bad setups
                                        </div>
                                    )}

                                    {/* Send It Mode Warning */}
                                    {localSettings.tradingMode === 'aggressive' && (
                                        <div className="mt-3 p-3 bg-yellow-500/10 border border-yellow-500/30 rounded-xl text-sm text-yellow-300">
                                            üöÄ SEND IT! Minimal warnings. Only critical alerts (3+ loss streaks). Godspeed, degen.
                                        </div>
                                    )}
                                </div>

                                <div>
                                    <label className="block text-sm text-gray-400 mb-2">Real-Time P&L Alerts</label>
                                    <div className="flex items-center justify-between p-4 bg-gray-800 rounded-xl border border-gray-700">
                                        <div>
                                            <div className="font-semibold">üîî Red/Green Alerts</div>
                                            <div className="text-sm text-gray-400">Notify when positions flip red or green</div>
                                        </div>
                                        <button
                                            onClick={() => setLocalSettings({...localSettings, realtimePnLAlerts: !localSettings.realtimePnLAlerts})}
                                            className={`w-14 h-8 rounded-full transition-colors ${localSettings.realtimePnLAlerts ? 'bg-green-500' : 'bg-gray-600'}`}
                                        >
                                            <div className={`w-6 h-6 bg-white rounded-full transition-transform ${localSettings.realtimePnLAlerts ? 'translate-x-7' : 'translate-x-1'}`} />
                                        </button>
                                    </div>
                                    {localSettings.realtimePnLAlerts ? (
                                        <div className="mt-2 p-3 bg-blue-500/10 border border-blue-500/30 rounded-xl text-sm text-blue-300">
                                            ‚úÖ You'll get notified when any position goes red, goes green, or has sudden price swings.
                                        </div>
                                    ) : (
                                        <div className="mt-2 p-3 bg-gray-500/10 border border-gray-500/30 rounded-xl text-sm text-gray-400">
                                            Real-time P&L alerts disabled. Expiration and other alerts still active.
                                        </div>
                                    )}
                                </div>

                                <div>
                                    <label className="block text-sm text-gray-400 mb-2">Alert Frequency</label>
                                    <div className="grid grid-cols-3 gap-2">
                                        {['high', 'balanced', 'low'].map(freq => (
                                            <button
                                                key={freq}
                                                onClick={() => setLocalSettings({...localSettings, alertFrequency: freq})}
                                                className={`p-3 rounded-xl border transition-all ${localSettings.alertFrequency === freq ? 'bg-blue-600 border-blue-500' : 'bg-gray-800 border-gray-700'}`}
                                            >
                                                {freq.charAt(0).toUpperCase() + freq.slice(1)}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Brokerage Connections */}
                                <div className="border-t border-gray-700 pt-4">
                                    <label className="block text-sm text-gray-400 mb-2">Connected Brokerages</label>
                                    <p className="text-xs text-gray-500 mb-3">Link your brokerage accounts to sync positions automatically</p>

                                    {/* Connected accounts list */}
                                    {connectedBrokerages && connectedBrokerages.length > 0 ? (
                                        <div className="space-y-2 mb-3">
                                            {connectedBrokerages.map(code => {
                                                const brokerage = supportedBrokerages?.find(b => b.shortCode === code);
                                                return (
                                                    <div key={code} className="flex items-center justify-between p-3 bg-gray-800 rounded-xl border border-gray-700">
                                                        <div className="flex items-center gap-2">
                                                            <span className="px-2 py-1 text-xs font-bold rounded" style={{ backgroundColor: brokerage?.color || '#888' }}>
                                                                {code}
                                                            </span>
                                                            <span className="text-sm">{brokerage?.name || code}</span>
                                                        </div>
                                                        <span className="text-xs text-green-400">Connected</span>
                                                    </div>
                                                );
                                            })}
                                            {brokerageSyncTime && (
                                                <p className="text-xs text-gray-500 text-center">
                                                    Last sync: {brokerageSyncTime.toLocaleTimeString()}
                                                </p>
                                            )}
                                        </div>
                                    ) : (
                                        <div className="p-4 bg-gray-800/50 rounded-xl border border-dashed border-gray-600 text-center mb-3">
                                            <p className="text-gray-400 text-sm">No brokerages connected yet</p>
                                        </div>
                                    )}

                                    {/* Connect new brokerage button */}
                                    <button
                                        onClick={() => setShowBrokerageList(!showBrokerageList)}
                                        disabled={brokerageLoading}
                                        className="w-full py-2 bg-gray-800 hover:bg-gray-700 border border-gray-600 rounded-xl text-sm font-medium transition-colors flex items-center justify-center gap-2"
                                    >
                                        {brokerageLoading ? (
                                            <>Loading...</>
                                        ) : (
                                            <>+ Connect Brokerage</>
                                        )}
                                    </button>

                                    {/* Brokerage selection dropdown */}
                                    {showBrokerageList && supportedBrokerages && (
                                        <div className="mt-2 space-y-1 max-h-48 overflow-y-auto">
                                            {supportedBrokerages.map(brokerage => (
                                                <button
                                                    key={brokerage.id}
                                                    onClick={() => {
                                                        console.log('[Settings] Clicked brokerage:', brokerage.id);
                                                        console.log('[Settings] onConnectBrokerage exists:', !!onConnectBrokerage);
                                                        if (onConnectBrokerage) {
                                                            onConnectBrokerage(brokerage.id);
                                                        } else {
                                                            console.error('[Settings] onConnectBrokerage is undefined!');
                                                        }
                                                        setShowBrokerageList(false);
                                                    }}
                                                    className="w-full p-3 bg-gray-800 hover:bg-gray-700 rounded-xl text-left transition-colors flex items-center gap-3"
                                                >
                                                    <span className="px-2 py-1 text-xs font-bold rounded" style={{ backgroundColor: brokerage.color }}>
                                                        {brokerage.shortCode}
                                                    </span>
                                                    <span>{brokerage.name}</span>
                                                </button>
                                            ))}
                                        </div>
                                    )}

                                    {/* Sync button */}
                                    {connectedBrokerages && connectedBrokerages.length > 0 && (
                                        <button
                                            onClick={onSyncBrokerages}
                                            disabled={brokerageLoading}
                                            className="w-full mt-2 py-2 bg-blue-600/20 hover:bg-blue-600/30 border border-blue-500/30 rounded-xl text-sm text-blue-400 transition-colors"
                                        >
                                            {brokerageLoading ? 'Syncing...' : 'Sync Now'}
                                        </button>
                                    )}

                                    {/* Auto-import toggle */}
                                    <div className="mt-3 flex items-center justify-between p-3 bg-gray-800 rounded-xl">
                                        <div>
                                            <div className="text-sm font-medium">Auto-import Trades</div>
                                            <div className="text-xs text-gray-500">Add trades to Journal automatically</div>
                                        </div>
                                        <button
                                            onClick={() => {
                                                const newValue = !autoImportTrades;
                                                onToggleAutoImport && onToggleAutoImport(newValue);
                                            }}
                                            className={`w-12 h-6 rounded-full transition-colors ${autoImportTrades ? 'bg-green-500' : 'bg-gray-600'}`}
                                        >
                                            <div className={`w-5 h-5 bg-white rounded-full transition-transform ${autoImportTrades ? 'translate-x-6' : 'translate-x-0.5'}`} />
                                        </button>
                                    </div>

                                    {brokerageError && (
                                        <div className="mt-2 p-2 bg-red-500/10 border border-red-500/30 rounded-xl text-xs text-red-400">
                                            {brokerageError}
                                        </div>
                                    )}

                                    {(!supportedBrokerages || supportedBrokerages.length === 0) && (
                                        <div className="mt-2 p-2 bg-yellow-500/10 border border-yellow-500/30 rounded-xl text-xs text-yellow-400">
                                            SnapTrade not configured. Add API keys to .env file to enable brokerage sync.
                                        </div>
                                    )}
                                </div>

                                {/* Pattern Customization - Search & Add */}
                                <PatternManager
                                    enabledPatterns={localSettings.enabledPatterns || []}
                                    onUpdate={(newPatterns) => setLocalSettings({...localSettings, enabledPatterns: newPatterns})}
                                />

                                <button
                                    onClick={() => { onSave(localSettings); onClose(); }}
                                    className="w-full py-3 bg-blue-600 hover:bg-blue-500 rounded-xl font-semibold transition-colors"
                                >
                                    üíæ Save Settings
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // ============================================
        // TRADINGVIEW WIDGET - Real-time Charts
        // ============================================
        const TradingViewWidget = ({ symbol }) => {
            const containerRef = React.useRef(null);
            const [currentSymbol, setCurrentSymbol] = React.useState(symbol);

            React.useEffect(() => {
                if (!containerRef.current) return;

                // Clear previous widget
                containerRef.current.innerHTML = '';

                // Create widget container
                const widgetDiv = document.createElement('div');
                widgetDiv.className = 'tradingview-widget-container';
                widgetDiv.style.height = '100%';
                widgetDiv.style.width = '100%';

                const widgetInner = document.createElement('div');
                widgetInner.className = 'tradingview-widget-container__widget';
                widgetInner.style.height = '100%';
                widgetInner.style.width = '100%';
                widgetDiv.appendChild(widgetInner);

                containerRef.current.appendChild(widgetDiv);

                // Create and append script
                const script = document.createElement('script');
                script.src = 'https://s3.tradingview.com/external-embedding/embed-widget-advanced-chart.js';
                script.async = true;
                script.innerHTML = JSON.stringify({
                    "autosize": true,
                    "symbol": symbol,
                    "interval": "5",
                    "timezone": "America/New_York",
                    "theme": "dark",
                    "style": "1",
                    "locale": "en",
                    "backgroundColor": "rgba(17, 17, 27, 1)",
                    "gridColor": "rgba(45, 45, 68, 1)",
                    "enable_publishing": false,
                    "allow_symbol_change": true,
                    "hide_top_toolbar": false,
                    "hide_legend": false,
                    "save_image": true,
                    "calendar": false,
                    "hide_volume": false,
                    "support_host": "https://www.tradingview.com",
                    "studies": [
                        "STD;VWAP",
                        "STD;EMA"
                    ]
                });
                widgetDiv.appendChild(script);

                setCurrentSymbol(symbol);
            }, [symbol]);

            return (
                <div
                    ref={containerRef}
                    style={{ height: '500px', width: '100%' }}
                />
            );
        };

        // ============================================
        // SCALPER DASHBOARD - Day Trading Mode
        // ============================================
        const ScalperDashboard = ({ positions, tradeStats, setTradeStats, dailyGoal, setDailyGoal, onClose }) => {
            const [editingGoal, setEditingGoal] = useState(false);
            const [newGoal, setNewGoal] = useState(dailyGoal);

            // Calculate today's P&L from positions
            const todayPnL = positions.reduce((sum, pos) => {
                const pnl = ((pos.livePrice || pos.currentPrice) - pos.entryPrice) * pos.quantity;
                return sum + pnl;
            }, 0);

            const goalProgress = Math.min(100, (todayPnL / dailyGoal) * 100);
            const goalHit = todayPnL >= dailyGoal;

            // Record a trade (win or loss)
            const recordTrade = (isWin, pnl) => {
                const today = new Date().toDateString();
                let newStats = { ...tradeStats };

                // Reset daily stats if it's a new day
                if (newStats.lastTradeDate !== today) {
                    newStats.todayPnL = 0;
                    newStats.todayTrades = 0;
                }

                if (isWin) {
                    newStats.wins++;
                    if (newStats.streakType === 'win') {
                        newStats.streak++;
                    } else {
                        newStats.streak = 1;
                        newStats.streakType = 'win';
                    }
                } else {
                    newStats.losses++;
                    if (newStats.streakType === 'loss') {
                        newStats.streak++;
                    } else {
                        newStats.streak = 1;
                        newStats.streakType = 'loss';
                    }
                }

                newStats.todayPnL += pnl;
                newStats.todayTrades++;
                newStats.lastTradeDate = today;

                setTradeStats(newStats);
                saveTradeStats(newStats);
            };

            // Reset stats
            const resetStats = () => {
                const reset = { wins: 0, losses: 0, streak: 0, streakType: null, todayPnL: 0, todayTrades: 0, lastTradeDate: null };
                setTradeStats(reset);
                saveTradeStats(reset);
            };

            const streak = getStreakDisplay(tradeStats.streak, tradeStats.streakType);
            const winRate = tradeStats.wins + tradeStats.losses > 0
                ? ((tradeStats.wins / (tradeStats.wins + tradeStats.losses)) * 100).toFixed(0)
                : 0;

            return (
                <div className="fixed inset-0 bg-black/90 backdrop-blur-sm z-50 flex flex-col">
                    {/* Header */}
                    <div className="p-4 border-b border-gray-800 flex justify-between items-center">
                        <div className="flex items-center gap-3">
                            <span className="text-2xl">‚ö°</span>
                            <div>
                                <h2 className="text-xl font-bold">SCALPER MODE</h2>
                                <p className="text-xs text-gray-400">Real-time trading dashboard</p>
                            </div>
                        </div>
                        <button onClick={onClose} className="p-2 hover:bg-gray-800 rounded-xl text-2xl">‚úï</button>
                    </div>

                    {/* Stats Bar */}
                    <div className="p-4 border-b border-gray-800 grid grid-cols-4 gap-4">
                        {/* Daily Goal */}
                        <div className={`p-3 rounded-xl ${goalHit ? 'bg-green-500/20 border border-green-500' : 'bg-gray-800'}`}>
                            <div className="text-xs text-gray-400 mb-1">Daily Goal</div>
                            {editingGoal ? (
                                <div className="flex gap-1">
                                    <input
                                        type="number"
                                        value={newGoal}
                                        onChange={(e) => setNewGoal(e.target.value)}
                                        className="w-20 p-1 bg-gray-700 rounded text-sm"
                                        autoFocus
                                    />
                                    <button
                                        onClick={() => {
                                            setDailyGoal(parseFloat(newGoal));
                                            saveDailyGoal(parseFloat(newGoal));
                                            setEditingGoal(false);
                                        }}
                                        className="px-2 bg-green-600 rounded text-xs"
                                    >‚úì</button>
                                </div>
                            ) : (
                                <div className="flex items-center gap-2">
                                    <span className={`text-lg font-bold ${goalHit ? 'text-green-400' : ''}`}>
                                        ${todayPnL.toFixed(0)} / ${dailyGoal}
                                    </span>
                                    <button onClick={() => setEditingGoal(true)} className="text-xs text-gray-500">‚úèÔ∏è</button>
                                </div>
                            )}
                            <div className="mt-1 h-2 bg-gray-700 rounded-full overflow-hidden">
                                <div
                                    className={`h-full ${goalHit ? 'bg-green-500' : todayPnL > 0 ? 'bg-blue-500' : 'bg-red-500'}`}
                                    style={{ width: `${Math.max(0, goalProgress)}%` }}
                                />
                            </div>
                            {goalHit && <div className="text-xs text-green-400 mt-1">üéØ GOAL HIT! Consider stopping.</div>}
                        </div>

                        {/* Win Rate */}
                        <div className="p-3 bg-gray-800 rounded-xl">
                            <div className="text-xs text-gray-400 mb-1">Win Rate</div>
                            <div className="text-lg font-bold">{winRate}%</div>
                            <div className="text-xs text-gray-500">{tradeStats.wins}W / {tradeStats.losses}L</div>
                        </div>

                        {/* Streak */}
                        <div className="p-3 bg-gray-800 rounded-xl">
                            <div className="text-xs text-gray-400 mb-1">Streak</div>
                            <div className={`text-lg font-bold ${streak.color}`}>
                                {streak.emoji} {streak.text}
                            </div>
                        </div>

                        {/* Today's Trades */}
                        <div className="p-3 bg-gray-800 rounded-xl">
                            <div className="text-xs text-gray-400 mb-1">Today</div>
                            <div className="text-lg font-bold">{tradeStats.todayTrades} trades</div>
                            <button onClick={resetStats} className="text-xs text-red-400 hover:text-red-300">Reset Stats</button>
                        </div>
                    </div>

                    {/* Position Cards - Scalper Style */}
                    <div className="flex-1 overflow-y-auto p-4">
                        <div className="grid gap-3">
                            {positions.map(pos => {
                                const pnl = ((pos.livePrice || pos.currentPrice) - pos.entryPrice) * pos.quantity;
                                const pnlPercent = ((pos.livePrice || pos.currentPrice) - pos.entryPrice) / pos.entryPrice * 100;
                                const momentum = getMomentum(pos.dayChange, pos.volume, pos.avgVolume);
                                const volumeStatus = getVolumeStatus(pos.volume, pos.avgVolume);
                                const isWinning = pnl > 0;

                                return (
                                    <div
                                        key={pos.id}
                                        className={`p-4 rounded-xl border ${
                                            isWinning ? 'bg-green-500/10 border-green-500/50' : 'bg-red-500/10 border-red-500/50'
                                        }`}
                                    >
                                        <div className="flex justify-between items-start">
                                            {/* Left - Ticker & Price */}
                                            <div>
                                                <div className="flex items-center gap-2">
                                                    <span className="text-xl font-bold">{pos.ticker}</span>
                                                    <span className={`px-2 py-0.5 rounded text-xs ${momentum.bg} ${momentum.color}`}>
                                                        {momentum.emoji} {momentum.status}
                                                    </span>
                                                    {volumeStatus && volumeStatus.status !== 'NORMAL' && (
                                                        <span className={`px-2 py-0.5 rounded text-xs bg-orange-500/20 ${volumeStatus.color}`}>
                                                            {volumeStatus.emoji} {volumeStatus.multiplier}x VOL
                                                        </span>
                                                    )}
                                                </div>
                                                <div className="text-2xl font-bold mt-1">
                                                    ${(pos.livePrice || pos.currentPrice).toFixed(2)}
                                                    {pos.dayChange && (
                                                        <span className={`text-sm ml-2 ${parseFloat(pos.dayChange) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                            {parseFloat(pos.dayChange) >= 0 ? '+' : ''}{pos.dayChange}%
                                                        </span>
                                                    )}
                                                </div>
                                                {pos.type === 'option' && (
                                                    <div className="text-xs text-gray-400 mt-1">
                                                        ${pos.strike} {pos.optionType?.toUpperCase()} ‚Ä¢ {formatExpirationDate(pos.expiration)}
                                                    </div>
                                                )}
                                            </div>

                                            {/* Right - P&L */}
                                            <div className="text-right">
                                                <div className={`text-2xl font-bold ${isWinning ? 'text-green-400' : 'text-red-400'}`}>
                                                    {isWinning ? '+' : ''}{pnlPercent.toFixed(1)}%
                                                </div>
                                                <div className={`text-lg ${isWinning ? 'text-green-400' : 'text-red-400'}`}>
                                                    {isWinning ? '+' : ''}${pnl.toFixed(2)}
                                                </div>
                                                <div className="text-xs text-gray-500">
                                                    Entry: ${pos.entryPrice.toFixed(2)}
                                                </div>
                                            </div>
                                        </div>

                                        {/* Quick Actions */}
                                        <div className="flex gap-2 mt-3">
                                            {pnlPercent >= 10 && (
                                                <div className="px-3 py-1 bg-green-600 rounded-lg text-xs font-semibold animate-pulse">
                                                    üí∞ TAKE PROFIT?
                                                </div>
                                            )}
                                            {pnlPercent <= -10 && (
                                                <div className="px-3 py-1 bg-red-600 rounded-lg text-xs font-semibold animate-pulse">
                                                    üõë CUT LOSS?
                                                </div>
                                            )}
                                            <button
                                                onClick={() => recordTrade(pnl > 0, pnl)}
                                                className="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded-lg text-xs"
                                            >
                                                üìù Log as {pnl > 0 ? 'Win' : 'Loss'}
                                            </button>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>

                        {positions.length === 0 && (
                            <div className="text-center py-12 text-gray-500">
                                <p className="text-4xl mb-2">‚ö°</p>
                                <p>No positions to track</p>
                                <p className="text-sm">Add positions to see them in scalper mode</p>
                            </div>
                        )}
                    </div>

                    {/* Footer - Quick Stats */}
                    <div className="p-4 border-t border-gray-800 bg-gray-900">
                        <div className="flex justify-between items-center">
                            <div className="text-sm text-gray-400">
                                {positions.length} position{positions.length !== 1 ? 's' : ''} tracked
                            </div>
                            <div className={`text-lg font-bold ${todayPnL >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                Total: {todayPnL >= 0 ? '+' : ''}${todayPnL.toFixed(2)}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Alert Banner Component
        const AlertBanner = ({ position, personality, onDismiss }) => {
            const daysToExpiry = getDaysToExpiry(position.expiration);
            const currentPrice = position.livePrice || position.currentPrice;
            const pnlPercent = ((currentPrice - position.entryPrice) / position.entryPrice * 100).toFixed(1);

            if (position.type !== 'option' || daysToExpiry > 7) return null;

            // Adjust tone based on personality
            const isAggressive = personality === 'homie';
            const greeting = "Your";
            const winMessage = isAggressive
                ? " Take the W before theta eats it. Don't get greedy with only " + daysToExpiry + " days left!"
                : " Consider taking profits before theta decay accelerates. " + daysToExpiry + " days remaining.";
            const lossMessage = isAggressive
                ? " Cut this NOW or watch it go to zero. Time is NOT on your side."
                : " Consider closing this position. Time decay is working against you.";

            return (
                <div className="bg-red-500/20 border border-red-500 rounded-xl p-4 mb-4 urgent-pulse relative">
                    <button
                        onClick={() => onDismiss && onDismiss(position.id)}
                        className="absolute top-2 right-2 text-gray-400 hover:text-white text-xl w-8 h-8 flex items-center justify-center rounded-lg hover:bg-gray-700/50"
                        title="Dismiss"
                    >
                        √ó
                    </button>
                    <div className="flex items-start gap-3 pr-8">
                        <span className="text-2xl">üö®</span>
                        <div>
                            <div className="font-bold text-red-300">URGENT: {position.ticker} Options Expiring Soon!</div>
                            <p className="text-sm mt-1">
                                {greeting} {position.ticker} ${position.strike} {position.optionType}s expire in {daysToExpiry} {daysToExpiry === 1 ? 'day' : 'days'}.
                                You're {pnlPercent >= 0 ? 'up' : 'down'} {Math.abs(pnlPercent)}%.
                                {pnlPercent >= 0 ? winMessage : lossMessage}
                            </p>
                        </div>
                    </div>
                </div>
            );
        };

        // ============================================
        // CUSTOM ALERT SYSTEM - Industry Leading
        // ============================================

        // Personalize alert messages based on AI personality
        const personalizeAlertMessage = (message, personality) => {
            if (!personality || !message) return message;

            if (personality === 'homie') {
                // Aggressive One - direct, energetic
                const prefixes = ['Heads up! ', 'Listen up - ', 'Real talk - ', 'Pay attention: '];
                const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
                return prefix + message;
            } else if (personality === 'sergeant') {
                // Drill Sergeant - military style
                const prefixes = ['ATTENTION! ', 'ALERT! ', 'INCOMING! ', 'HEADS UP SOLDIER! '];
                const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
                return prefix + message.toUpperCase();
            } else if (personality === 'mentor') {
                // Wise Mentor - calm, professional
                return 'Notice: ' + message;
            } else if (personality === 'nerd') {
                // Data Nerd - analytical
                return 'Data Alert: ' + message;
            }
            return message;
        };

        const ALERT_TYPES = {
            PRICE_ABOVE: 'price_above',
            PRICE_BELOW: 'price_below',
            PERCENT_GAIN: 'percent_gain',
            PERCENT_LOSS: 'percent_loss',
            RSI_ABOVE: 'rsi_above',
            RSI_BELOW: 'rsi_below',
            SMA_50: 'sma_50',                      // Price near 50 SMA
            SMA_200: 'sma_200',                    // Price near 200 SMA
            GOLDEN_CROSS: 'golden_cross',          // 50 SMA crosses above 200 SMA
            DEATH_CROSS: 'death_cross',            // 50 SMA crosses below 200 SMA
            NEWS: 'news',
            VOLUME_SPIKE: 'volume_spike',
            TRAILING_STOP: 'trailing_stop',
            PRICE_VELOCITY: 'price_velocity',      // Alert on X% move in short time
            GAP_UP: 'gap_up',                      // Pre-market gap up X%
            GAP_DOWN: 'gap_down',                  // Pre-market gap down X%
            BREAKOUT: 'breakout',                  // Price breaks above X-day high
            BREAKDOWN: 'breakdown'                 // Price breaks below X-day low
        };

        const ALERT_PRIORITIES = {
            CRITICAL: 'critical',
            WARNING: 'warning',
            INFO: 'info'
        };

        // Load custom alerts from localStorage
        const loadCustomAlerts = () => {
            try {
                const saved = localStorage.getItem('customAlerts');
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                return [];
            }
        };

        // Save custom alerts to localStorage
        const saveCustomAlerts = (alerts) => {
            localStorage.setItem('customAlerts', JSON.stringify(alerts));
        };

        // Load triggered alert history
        const loadAlertHistory = () => {
            try {
                const saved = localStorage.getItem('alertHistory');
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                return [];
            }
        };

        // Save alert history
        const saveAlertHistory = (history) => {
            // Keep only last 100 alerts
            const trimmed = history.slice(-100);
            localStorage.setItem('alertHistory', JSON.stringify(trimmed));
        };

        // Load watched news tickers
        const loadNewsWatchlist = () => {
            try {
                const saved = localStorage.getItem('newsWatchlist');
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                return [];
            }
        };

        // Save news watchlist
        const saveNewsWatchlist = (watchlist) => {
            localStorage.setItem('newsWatchlist', JSON.stringify(watchlist));
        };

        // Calculate RSI from price data
        const calculateRSI = (prices, period = 14) => {
            if (!prices || prices.length < period + 1) return null;

            let gains = 0;
            let losses = 0;

            // Calculate initial average gain/loss
            for (let i = 1; i <= period; i++) {
                const change = prices[i] - prices[i - 1];
                if (change >= 0) gains += change;
                else losses += Math.abs(change);
            }

            let avgGain = gains / period;
            let avgLoss = losses / period;

            // Calculate smoothed RSI for remaining prices
            for (let i = period + 1; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                if (change >= 0) {
                    avgGain = (avgGain * (period - 1) + change) / period;
                    avgLoss = (avgLoss * (period - 1)) / period;
                } else {
                    avgGain = (avgGain * (period - 1)) / period;
                    avgLoss = (avgLoss * (period - 1) + Math.abs(change)) / period;
                }
            }

            if (avgLoss === 0) return 100;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        };

        // Fetch RSI data for a ticker
        const fetchRSIData = async (ticker) => {
            try {
                const response = await fetch(`/api/proxy?url=${encodeURIComponent(`https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?interval=1d&range=1mo`)}`);
                const data = await response.json();
                const prices = data.chart?.result?.[0]?.indicators?.quote?.[0]?.close?.filter(p => p != null);
                if (prices && prices.length > 14) {
                    return calculateRSI(prices);
                }
                return null;
            } catch (e) {
                console.error('Error fetching RSI:', e);
                return null;
            }
        };

        // Fetch latest news for a ticker
        const fetchTickerNews = async (ticker) => {
            try {
                // Use Yahoo Finance news
                const response = await fetch(`/api/proxy?url=${encodeURIComponent(`https://query1.finance.yahoo.com/v1/finance/search?q=${ticker}&newsCount=10`)}`);
                const data = await response.json();
                return data.news || [];
            } catch (e) {
                console.error('Error fetching news:', e);
                return [];
            }
        };

        // Alert Manager Component
        const AlertManager = ({ isOpen, onClose, customAlerts, setCustomAlerts, alertHistory, setAlertHistory, newsWatchlist, setNewsWatchlist, pushEnabled, setPushEnabled, fcmToken, setFcmToken, fcmError, setFcmError }) => {
            const [activeSection, setActiveSection] = useState('create'); // create, active, history, news
            const [newAlert, setNewAlert] = useState({
                ticker: '',
                type: ALERT_TYPES.PRICE_ABOVE,
                value: '',
                priority: ALERT_PRIORITIES.WARNING,
                sound: true,
                repeat: false,
                note: ''
            });
            const [newsTicker, setNewsTicker] = useState('');
            const [newsArticles, setNewsArticles] = useState({});  // { ticker: [articles] }
            const [newsLoading, setNewsLoading] = useState({});    // { ticker: boolean }
            const [selectedNewsTicker, setSelectedNewsTicker] = useState(null); // Which ticker's news to show

            // Fetch news for a specific ticker
            const loadNewsForTicker = async (ticker) => {
                if (newsLoading[ticker]) return;
                setNewsLoading(prev => ({ ...prev, [ticker]: true }));
                try {
                    const articles = await fetchTickerNews(ticker);
                    setNewsArticles(prev => ({ ...prev, [ticker]: articles }));
                } catch (e) {
                    console.error('Error loading news for', ticker, e);
                    setNewsArticles(prev => ({ ...prev, [ticker]: [] }));
                }
                setNewsLoading(prev => ({ ...prev, [ticker]: false }));
            };

            // Load news when a ticker is selected
            useEffect(() => {
                if (selectedNewsTicker && !newsArticles[selectedNewsTicker]) {
                    loadNewsForTicker(selectedNewsTicker);
                }
            }, [selectedNewsTicker]);

            // Auto-select first ticker when entering news section
            useEffect(() => {
                if (activeSection === 'news' && newsWatchlist.length > 0 && !selectedNewsTicker) {
                    setSelectedNewsTicker(newsWatchlist[0]);
                }
            }, [activeSection, newsWatchlist]);

            // Save to localStorage when state changes
            useEffect(() => {
                saveCustomAlerts(customAlerts);
            }, [customAlerts]);

            useEffect(() => {
                saveAlertHistory(alertHistory);
            }, [alertHistory]);

            useEffect(() => {
                saveNewsWatchlist(newsWatchlist);
            }, [newsWatchlist]);

            // Create new alert
            const createAlert = () => {
                if (!newAlert.ticker || !newAlert.value) return;

                const alert = {
                    id: Date.now(),
                    ...newAlert,
                    ticker: newAlert.ticker.toUpperCase(),
                    value: parseFloat(newAlert.value),
                    createdAt: new Date().toISOString(),
                    triggered: false,
                    highestPrice: null, // For trailing stops
                    active: true
                };

                setCustomAlerts([...customAlerts, alert]);
                setNewAlert({
                    ticker: '',
                    type: ALERT_TYPES.PRICE_ABOVE,
                    value: '',
                    priority: ALERT_PRIORITIES.WARNING,
                    sound: true,
                    repeat: false,
                    note: ''
                });
            };

            // Delete alert
            const deleteAlert = (id) => {
                setCustomAlerts(customAlerts.filter(a => a.id !== id));
            };

            // Toggle alert active state
            const toggleAlert = (id) => {
                setCustomAlerts(customAlerts.map(a =>
                    a.id === id ? { ...a, active: !a.active } : a
                ));
            };

            // Add ticker to news watchlist
            const addNewsWatch = () => {
                if (!newsTicker) return;
                const ticker = newsTicker.toUpperCase();
                if (!newsWatchlist.includes(ticker)) {
                    setNewsWatchlist([...newsWatchlist, ticker]);
                }
                // Immediately select and load news for this ticker
                setSelectedNewsTicker(ticker);
                loadNewsForTicker(ticker);
                setNewsTicker('');
            };

            // Remove ticker from news watchlist
            const removeNewsWatch = (ticker) => {
                setNewsWatchlist(newsWatchlist.filter(t => t !== ticker));
            };

            // Clear alert history
            const clearHistory = () => {
                setAlertHistory([]);
            };

            // Get alert type label
            const getAlertTypeLabel = (type) => {
                const labels = {
                    [ALERT_TYPES.PRICE_ABOVE]: 'üìà Price Above',
                    [ALERT_TYPES.PRICE_BELOW]: 'üìâ Price Below',
                    [ALERT_TYPES.PERCENT_GAIN]: 'üí∞ % Gain',
                    [ALERT_TYPES.PERCENT_LOSS]: 'üìâ % Loss',
                    [ALERT_TYPES.RSI_ABOVE]: 'üìä RSI Above',
                    [ALERT_TYPES.RSI_BELOW]: 'üìä RSI Below',
                    [ALERT_TYPES.SMA_50]: 'üìè Near 50 SMA',
                    [ALERT_TYPES.SMA_200]: 'üìè Near 200 SMA',
                    [ALERT_TYPES.GOLDEN_CROSS]: '‚ö° Golden Cross',
                    [ALERT_TYPES.DEATH_CROSS]: 'üíÄ Death Cross',
                    [ALERT_TYPES.VOLUME_SPIKE]: 'üîä Volume Spike',
                    [ALERT_TYPES.TRAILING_STOP]: 'üõë Trailing Stop %',
                    [ALERT_TYPES.PRICE_VELOCITY]: '‚ö° Price Velocity',
                    [ALERT_TYPES.GAP_UP]: 'üåÖ Gap Up',
                    [ALERT_TYPES.GAP_DOWN]: 'üåô Gap Down',
                    [ALERT_TYPES.BREAKOUT]: 'üöÄ Breakout (52w High)',
                    [ALERT_TYPES.BREAKDOWN]: 'üí• Breakdown (52w Low)'
                };
                return labels[type] || type;
            };

            // Get priority color
            const getPriorityColor = (priority) => {
                const colors = {
                    [ALERT_PRIORITIES.CRITICAL]: 'bg-red-500/20 border-red-500 text-red-400',
                    [ALERT_PRIORITIES.WARNING]: 'bg-yellow-500/20 border-yellow-500 text-yellow-400',
                    [ALERT_PRIORITIES.INFO]: 'bg-blue-500/20 border-blue-500 text-blue-400'
                };
                return colors[priority] || colors[ALERT_PRIORITIES.INFO];
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                    <div className="bg-gray-900 border border-gray-700 rounded-2xl w-full max-w-2xl max-h-[90vh] flex flex-col">
                        <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                            <h2 className="text-xl font-bold flex items-center gap-2">
                                üîî Alert Manager
                            </h2>
                            <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl">&times;</button>
                        </div>

                        {/* Background Notifications Banner */}
                        <div className={`p-3 mx-4 mt-3 rounded-xl ${pushEnabled ? 'bg-green-900/50 border border-green-700' : 'bg-yellow-900/50 border border-yellow-700'}`}>
                            <div className="flex items-center justify-between">
                                <div className="flex items-center gap-2">
                                    <span className="text-lg">{pushEnabled ? '‚úÖ' : '‚ö†Ô∏è'}</span>
                                    <div>
                                        <div className="font-medium text-sm">
                                            {pushEnabled ? 'Background Alerts Active' : 'Background Alerts Disabled'}
                                        </div>
                                        <div className="text-xs text-gray-400">
                                            {pushEnabled
                                                ? `${customAlerts.filter(a => a.active).length} alerts synced to server`
                                                : fcmError || 'Click to enable notifications when browser is closed'}
                                        </div>
                                    </div>
                                </div>
                                {pushEnabled ? (
                                    <button
                                        onClick={async () => {
                                            const token = fcmToken || localStorage.getItem('fcmToken');
                                            const activeAlerts = customAlerts.filter(a => a.active).map(a => ({
                                                id: a.id,
                                                ticker: a.ticker,
                                                type: a.type,
                                                value: parseFloat(a.value)
                                            }));
                                            try {
                                                const response = await fetch('/api/register-push-token', {
                                                    method: 'POST',
                                                    headers: { 'Content-Type': 'application/json' },
                                                    body: JSON.stringify({ token, alerts: activeAlerts })
                                                });
                                                const result = await response.json();
                                                alert(`Synced ${activeAlerts.length} alerts to server!`);
                                            } catch (err) {
                                                alert('Sync failed: ' + err.message);
                                            }
                                        }}
                                        className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium whitespace-nowrap"
                                    >
                                        Sync Now
                                    </button>
                                ) : (
                                    <button
                                        onClick={async () => {
                                            try {
                                                const permission = await Notification.requestPermission();
                                                if (permission === 'granted') {
                                                    // Re-initialize Firebase to get token
                                                    if (firebase.apps.length && window.VAPID_KEY) {
                                                        const messaging = firebase.messaging();
                                                        const registration = await navigator.serviceWorker.getRegistration('/firebase-messaging-sw.js');
                                                        const token = await messaging.getToken({
                                                            vapidKey: window.VAPID_KEY,
                                                            serviceWorkerRegistration: registration
                                                        });
                                                        if (token) {
                                                            setFcmToken(token);
                                                            setPushEnabled(true);
                                                            localStorage.setItem('fcmToken', token);
                                                            // Register with backend
                                                            fetch('/api/register-push-token', {
                                                                method: 'POST',
                                                                headers: { 'Content-Type': 'application/json' },
                                                                body: JSON.stringify({
                                                                    token,
                                                                    alerts: customAlerts.filter(a => a.active).map(a => ({
                                                                        id: a.id,
                                                                        ticker: a.ticker,
                                                                        type: a.type,
                                                                        value: parseFloat(a.value)
                                                                    }))
                                                                })
                                                            });
                                                        }
                                                    }
                                                } else {
                                                    setFcmError('Permission denied - check browser settings');
                                                }
                                            } catch (err) {
                                                setFcmError(err.message);
                                            }
                                        }}
                                        className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium whitespace-nowrap"
                                    >
                                        Enable Now
                                    </button>
                                )}
                            </div>
                        </div>

                        {/* Tabs */}
                        <div className="flex border-b border-gray-700">
                            {[
                                { id: 'create', label: '‚ûï Create', icon: '' },
                                { id: 'active', label: `üîî Active (${customAlerts.filter(a => a.active).length})`, icon: '' },
                                { id: 'news', label: `üì∞ News Watch (${newsWatchlist.length})`, icon: '' },
                                { id: 'history', label: 'üìú History', icon: '' }
                            ].map(tab => (
                                <button
                                    key={tab.id}
                                    onClick={() => setActiveSection(tab.id)}
                                    className={`flex-1 py-3 text-sm font-medium transition-colors ${
                                        activeSection === tab.id
                                            ? 'bg-blue-600 text-white'
                                            : 'text-gray-400 hover:bg-gray-800'
                                    }`}
                                >
                                    {tab.label}
                                </button>
                            ))}
                        </div>

                        <div className="p-4 overflow-y-auto flex-1">
                            {/* CREATE ALERT */}
                            {activeSection === 'create' && (
                                <div className="space-y-4">
                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="block text-sm text-gray-400 mb-1">Ticker Symbol</label>
                                            <input
                                                type="text"
                                                value={newAlert.ticker}
                                                onChange={(e) => setNewAlert({ ...newAlert, ticker: e.target.value.toUpperCase() })}
                                                placeholder="TSLA, BTC, SPY..."
                                                className="w-full p-3 bg-gray-800 border border-gray-700 rounded-xl text-white focus:border-blue-500 focus:outline-none"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-sm text-gray-400 mb-1">Alert Type</label>
                                            <select
                                                value={newAlert.type}
                                                onChange={(e) => setNewAlert({ ...newAlert, type: e.target.value })}
                                                className="w-full p-3 bg-gray-800 border border-gray-700 rounded-xl text-white focus:border-blue-500 focus:outline-none"
                                            >
                                                <option value={ALERT_TYPES.PRICE_ABOVE}>üìà Price Goes Above</option>
                                                <option value={ALERT_TYPES.PRICE_BELOW}>üìâ Price Goes Below</option>
                                                <option value={ALERT_TYPES.PERCENT_GAIN}>üí∞ Position Gains %</option>
                                                <option value={ALERT_TYPES.PERCENT_LOSS}>üìâ Position Loses %</option>
                                                <option value={ALERT_TYPES.TRAILING_STOP}>üõë Trailing Stop %</option>
                                                <option value={ALERT_TYPES.RSI_ABOVE}>üìä RSI Overbought (Above)</option>
                                                <option value={ALERT_TYPES.RSI_BELOW}>üìä RSI Oversold (Below)</option>
                                                <option value={ALERT_TYPES.SMA_50}>üìè Price Near 50 SMA (%)</option>
                                                <option value={ALERT_TYPES.SMA_200}>üìè Price Near 200 SMA (%)</option>
                                                <option value={ALERT_TYPES.GOLDEN_CROSS}>‚ö° Golden Cross (50/200 SMA)</option>
                                                <option value={ALERT_TYPES.DEATH_CROSS}>üíÄ Death Cross (50/200 SMA)</option>
                                                <option value={ALERT_TYPES.PRICE_VELOCITY}>‚ö° Price Velocity (% in 5min)</option>
                                                <option value={ALERT_TYPES.VOLUME_SPIKE}>üîä Volume Spike (X% above avg)</option>
                                                <option value={ALERT_TYPES.GAP_UP}>üåÖ Pre-Market Gap Up %</option>
                                                <option value={ALERT_TYPES.GAP_DOWN}>üåô Pre-Market Gap Down %</option>
                                                <option value={ALERT_TYPES.BREAKOUT}>üöÄ 52-Week High Breakout</option>
                                                <option value={ALERT_TYPES.BREAKDOWN}>üí• 52-Week Low Breakdown</option>
                                            </select>
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="block text-sm text-gray-400 mb-1">
                                                {newAlert.type.includes('percent') || newAlert.type === ALERT_TYPES.TRAILING_STOP
                                                    ? 'Percentage %'
                                                    : newAlert.type.includes('rsi')
                                                        ? 'RSI Value (0-100)'
                                                        : newAlert.type.includes('sma')
                                                            ? 'Distance from SMA (%)'
                                                            : newAlert.type.includes('cross')
                                                                ? 'Not needed (auto)'
                                                                : 'Target Price $'
                                                }
                                            </label>
                                            <input
                                                type="number"
                                                value={newAlert.value}
                                                onChange={(e) => setNewAlert({ ...newAlert, value: e.target.value })}
                                                placeholder={
                                                    newAlert.type.includes('rsi') ? '70'
                                                    : newAlert.type.includes('percent') ? '10'
                                                    : newAlert.type.includes('sma') ? '2'
                                                    : newAlert.type.includes('cross') ? '0'
                                                    : '100.00'
                                                }
                                                disabled={newAlert.type.includes('cross')}
                                                className="w-full p-3 bg-gray-800 border border-gray-700 rounded-xl text-white focus:border-blue-500 focus:outline-none disabled:opacity-50"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-sm text-gray-400 mb-1">Priority</label>
                                            <select
                                                value={newAlert.priority}
                                                onChange={(e) => setNewAlert({ ...newAlert, priority: e.target.value })}
                                                className="w-full p-3 bg-gray-800 border border-gray-700 rounded-xl text-white focus:border-blue-500 focus:outline-none"
                                            >
                                                <option value={ALERT_PRIORITIES.CRITICAL}>üî¥ Critical</option>
                                                <option value={ALERT_PRIORITIES.WARNING}>üü° Warning</option>
                                                <option value={ALERT_PRIORITIES.INFO}>üîµ Info</option>
                                            </select>
                                        </div>
                                    </div>

                                    <div>
                                        <label className="block text-sm text-gray-400 mb-1">Note (optional)</label>
                                        <input
                                            type="text"
                                            value={newAlert.note}
                                            onChange={(e) => setNewAlert({ ...newAlert, note: e.target.value })}
                                            placeholder="e.g., Take profits at this level"
                                            className="w-full p-3 bg-gray-800 border border-gray-700 rounded-xl text-white focus:border-blue-500 focus:outline-none"
                                        />
                                    </div>

                                    <div className="flex gap-4">
                                        <label className="flex items-center gap-2 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={newAlert.sound}
                                                onChange={(e) => setNewAlert({ ...newAlert, sound: e.target.checked })}
                                                className="w-5 h-5 rounded"
                                            />
                                            <span className="text-sm">üîä Play Sound</span>
                                        </label>
                                        <label className="flex items-center gap-2 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={newAlert.repeat}
                                                onChange={(e) => setNewAlert({ ...newAlert, repeat: e.target.checked })}
                                                className="w-5 h-5 rounded"
                                            />
                                            <span className="text-sm">üîÅ Repeat Alert</span>
                                        </label>
                                    </div>

                                    <button
                                        onClick={createAlert}
                                        disabled={!newAlert.ticker || !newAlert.value}
                                        className="w-full py-3 bg-green-600 hover:bg-green-500 disabled:bg-gray-700 disabled:cursor-not-allowed rounded-xl font-semibold transition-colors"
                                    >
                                        ‚úÖ Create Alert
                                    </button>

                                    {/* Quick Alert Templates */}
                                    <div className="mt-4 pt-4 border-t border-gray-700">
                                        <p className="text-sm text-gray-400 mb-3">‚ö° Quick Templates:</p>
                                        <div className="grid grid-cols-2 gap-2">
                                            <button
                                                onClick={() => setNewAlert({ ...newAlert, type: ALERT_TYPES.RSI_ABOVE, value: '70' })}
                                                className="p-2 bg-gray-800 hover:bg-gray-700 rounded-lg text-xs text-left"
                                            >
                                                üìä RSI Overbought (&gt;70)
                                            </button>
                                            <button
                                                onClick={() => setNewAlert({ ...newAlert, type: ALERT_TYPES.RSI_BELOW, value: '30' })}
                                                className="p-2 bg-gray-800 hover:bg-gray-700 rounded-lg text-xs text-left"
                                            >
                                                üìä RSI Oversold (&lt;30)
                                            </button>
                                            <button
                                                onClick={() => setNewAlert({ ...newAlert, type: ALERT_TYPES.PERCENT_LOSS, value: '10', priority: ALERT_PRIORITIES.CRITICAL })}
                                                className="p-2 bg-gray-800 hover:bg-gray-700 rounded-lg text-xs text-left"
                                            >
                                                üõë Stop Loss (-10%)
                                            </button>
                                            <button
                                                onClick={() => setNewAlert({ ...newAlert, type: ALERT_TYPES.PERCENT_GAIN, value: '20' })}
                                                className="p-2 bg-gray-800 hover:bg-gray-700 rounded-lg text-xs text-left"
                                            >
                                                üí∞ Take Profit (+20%)
                                            </button>
                                            <button
                                                onClick={() => setNewAlert({ ...newAlert, type: ALERT_TYPES.TRAILING_STOP, value: '5', priority: ALERT_PRIORITIES.CRITICAL })}
                                                className="p-2 bg-gray-800 hover:bg-gray-700 rounded-lg text-xs text-left"
                                            >
                                                üõë Trailing Stop (5%)
                                            </button>
                                            <button
                                                onClick={() => setNewAlert({ ...newAlert, type: ALERT_TYPES.SMA_50, value: '2' })}
                                                className="p-2 bg-gray-800 hover:bg-gray-700 rounded-lg text-xs text-left"
                                            >
                                                üìè Near 50 SMA (2%)
                                            </button>
                                            <button
                                                onClick={() => setNewAlert({ ...newAlert, type: ALERT_TYPES.SMA_200, value: '2' })}
                                                className="p-2 bg-gray-800 hover:bg-gray-700 rounded-lg text-xs text-left"
                                            >
                                                üìè Near 200 SMA (2%)
                                            </button>
                                            <button
                                                onClick={() => setNewAlert({ ...newAlert, type: ALERT_TYPES.GOLDEN_CROSS, value: '0' })}
                                                className="p-2 bg-gray-800 hover:bg-gray-700 rounded-lg text-xs text-left"
                                            >
                                                ‚ö° Golden Cross Alert
                                            </button>
                                            <button
                                                onClick={() => setNewAlert({ ...newAlert, type: ALERT_TYPES.DEATH_CROSS, value: '0' })}
                                                className="p-2 bg-gray-800 hover:bg-gray-700 rounded-lg text-xs text-left"
                                            >
                                                üíÄ Death Cross Alert
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* ACTIVE ALERTS */}
                            {activeSection === 'active' && (
                                <div className="space-y-3">
                                    {customAlerts.length === 0 ? (
                                        <div className="text-center py-8 text-gray-500">
                                            <p className="text-4xl mb-2">üîï</p>
                                            <p>No alerts set up yet</p>
                                            <p className="text-sm">Create your first alert to get started!</p>
                                        </div>
                                    ) : (
                                        customAlerts.map(alert => (
                                            <div
                                                key={alert.id}
                                                className={`p-3 rounded-xl border ${alert.active ? getPriorityColor(alert.priority) : 'bg-gray-800/50 border-gray-700 opacity-50'}`}
                                            >
                                                <div className="flex justify-between items-start">
                                                    <div>
                                                        <div className="font-bold text-lg">{alert.ticker}</div>
                                                        <div className="text-sm">
                                                            {getAlertTypeLabel(alert.type)}: {
                                                                alert.type.includes('percent') || alert.type === ALERT_TYPES.TRAILING_STOP ? `${alert.value}%`
                                                                : alert.type.includes('rsi') ? alert.value
                                                                : alert.type.includes('sma') ? `within ${alert.value}%`
                                                                : alert.type.includes('cross') ? 'Auto-detect'
                                                                : `$${alert.value}`
                                                            }
                                                        </div>
                                                        {alert.note && <div className="text-xs text-gray-400 mt-1">üìù {alert.note}</div>}
                                                        <div className="text-xs text-gray-500 mt-1">
                                                            Created: {new Date(alert.createdAt).toLocaleDateString()}
                                                            {alert.sound && ' üîä'}
                                                            {alert.repeat && ' üîÅ'}
                                                        </div>
                                                    </div>
                                                    <div className="flex gap-2">
                                                        <button
                                                            onClick={() => toggleAlert(alert.id)}
                                                            className={`px-3 py-1 rounded-lg text-xs ${alert.active ? 'bg-green-600' : 'bg-gray-600'}`}
                                                        >
                                                            {alert.active ? 'ON' : 'OFF'}
                                                        </button>
                                                        <button
                                                            onClick={() => deleteAlert(alert.id)}
                                                            className="px-3 py-1 bg-red-600 rounded-lg text-xs"
                                                        >
                                                            üóëÔ∏è
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>
                                        ))
                                    )}
                                </div>
                            )}

                            {/* NEWS WATCHLIST */}
                            {activeSection === 'news' && (
                                <div className="space-y-4">
                                    {/* Search box */}
                                    <div className="flex gap-2">
                                        <input
                                            type="text"
                                            value={newsTicker}
                                            onChange={(e) => setNewsTicker(e.target.value.toUpperCase())}
                                            placeholder="Enter ticker (e.g., TSLA, AAPL)..."
                                            className="flex-1 p-3 bg-gray-800 border border-gray-700 rounded-xl text-white focus:border-blue-500 focus:outline-none"
                                            onKeyPress={(e) => e.key === 'Enter' && addNewsWatch()}
                                        />
                                        <button
                                            onClick={addNewsWatch}
                                            className="px-4 bg-blue-600 hover:bg-blue-500 rounded-xl font-semibold"
                                        >
                                            üì∞ Get News
                                        </button>
                                    </div>

                                    {/* Watched tickers as tabs */}
                                    {newsWatchlist.length > 0 && (
                                        <div className="flex flex-wrap gap-2">
                                            {newsWatchlist.map(ticker => (
                                                <button
                                                    key={ticker}
                                                    onClick={() => {
                                                        setSelectedNewsTicker(ticker);
                                                        if (!newsArticles[ticker]) loadNewsForTicker(ticker);
                                                    }}
                                                    className={`px-3 py-2 rounded-xl flex items-center gap-2 transition-colors ${
                                                        selectedNewsTicker === ticker
                                                            ? 'bg-purple-600 text-white'
                                                            : 'bg-gray-800 hover:bg-gray-700 text-gray-300'
                                                    }`}
                                                >
                                                    <span className="font-semibold">{ticker}</span>
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            removeNewsWatch(ticker);
                                                            if (selectedNewsTicker === ticker) {
                                                                setSelectedNewsTicker(newsWatchlist[0] === ticker ? newsWatchlist[1] : newsWatchlist[0]);
                                                            }
                                                        }}
                                                        className="text-red-400 hover:text-red-300 ml-1"
                                                    >
                                                        ‚úï
                                                    </button>
                                                </button>
                                            ))}
                                        </div>
                                    )}

                                    {/* News articles list */}
                                    {selectedNewsTicker ? (
                                        <div className="bg-gray-800/50 border border-gray-700 rounded-xl overflow-hidden">
                                            <div className="p-3 bg-gray-800 border-b border-gray-700 flex justify-between items-center">
                                                <div className="flex items-center gap-2">
                                                    <span className="text-lg">üì∞</span>
                                                    <span className="font-bold">{selectedNewsTicker} News</span>
                                                </div>
                                                <button
                                                    onClick={() => loadNewsForTicker(selectedNewsTicker)}
                                                    className="text-xs text-blue-400 hover:text-blue-300"
                                                >
                                                    üîÑ Refresh
                                                </button>
                                            </div>

                                            <div className="max-h-64 overflow-y-auto">
                                                {newsLoading[selectedNewsTicker] ? (
                                                    <div className="p-8 text-center text-gray-400">
                                                        <div className="animate-spin text-2xl mb-2">‚è≥</div>
                                                        <p>Loading news...</p>
                                                    </div>
                                                ) : newsArticles[selectedNewsTicker]?.length > 0 ? (
                                                    newsArticles[selectedNewsTicker].map((article, idx) => (
                                                        <a
                                                            key={idx}
                                                            href={article.link}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            className="block p-3 border-b border-gray-700/50 hover:bg-gray-700/50 transition-colors cursor-pointer"
                                                        >
                                                            <div className="flex gap-3">
                                                                {article.thumbnail?.resolutions?.[0]?.url && (
                                                                    <img
                                                                        src={article.thumbnail.resolutions[0].url}
                                                                        alt=""
                                                                        className="w-16 h-16 object-cover rounded-lg flex-shrink-0"
                                                                    />
                                                                )}
                                                                <div className="flex-1 min-w-0">
                                                                    <div className="font-medium text-sm text-white line-clamp-2 mb-1">
                                                                        {article.title}
                                                                    </div>
                                                                    <div className="flex items-center gap-2 text-xs text-gray-400">
                                                                        <span>{article.publisher}</span>
                                                                        <span>‚Ä¢</span>
                                                                        <span>{new Date(article.providerPublishTime * 1000).toLocaleDateString()}</span>
                                                                    </div>
                                                                    <div className="text-xs text-blue-400 mt-1">
                                                                        Read article ‚Üí
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        </a>
                                                    ))
                                                ) : (
                                                    <div className="p-8 text-center text-gray-500">
                                                        <p className="text-2xl mb-2">ü§∑</p>
                                                        <p>No news found for {selectedNewsTicker}</p>
                                                        <p className="text-sm">Try a different ticker</p>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    ) : newsWatchlist.length === 0 ? (
                                        <div className="text-center py-8 text-gray-500">
                                            <p className="text-4xl mb-2">üì∞</p>
                                            <p>Enter a ticker to see latest news</p>
                                            <p className="text-sm mt-2">Example: TSLA, AAPL, NVDA, SPY</p>
                                        </div>
                                    ) : null}

                                    {/* Info box */}
                                    <div className="p-3 bg-blue-900/20 border border-blue-500/30 rounded-xl text-sm">
                                        <p className="text-blue-400">üí° Tip</p>
                                        <p className="text-gray-400 text-xs mt-1">
                                            Click any article to read the full story. Your watched tickers will also send you
                                            popup alerts when breaking news drops!
                                        </p>
                                    </div>
                                </div>
                            )}

                            {/* ALERT HISTORY */}
                            {activeSection === 'history' && (
                                <div className="space-y-3">
                                    {alertHistory.length > 0 && (
                                        <button
                                            onClick={clearHistory}
                                            className="text-xs text-red-400 hover:text-red-300"
                                        >
                                            üóëÔ∏è Clear History
                                        </button>
                                    )}
                                    {alertHistory.length === 0 ? (
                                        <div className="text-center py-8 text-gray-500">
                                            <p className="text-4xl mb-2">üìú</p>
                                            <p>No alert history yet</p>
                                            <p className="text-sm">Triggered alerts will appear here</p>
                                        </div>
                                    ) : (
                                        [...alertHistory].reverse().map((entry, idx) => (
                                            <div
                                                key={idx}
                                                className={`p-3 rounded-xl border ${getPriorityColor(entry.priority)}`}
                                            >
                                                <div className="flex justify-between items-start">
                                                    <div>
                                                        <div className="font-bold">{entry.ticker}</div>
                                                        <div className="text-sm">{entry.message}</div>
                                                        {entry.note && <div className="text-xs text-gray-400 mt-1">üìù {entry.note}</div>}
                                                    </div>
                                                    <div className="text-xs text-gray-500">
                                                        {new Date(entry.triggeredAt).toLocaleString()}
                                                    </div>
                                                </div>
                                            </div>
                                        ))
                                    )}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Alert Notification Popup Component
        const AlertNotification = ({ alerts, onDismiss, onDismissAll }) => {
            if (!alerts || alerts.length === 0) return null;

            // Separate news alerts from other alerts
            const newsAlerts = alerts.filter(a => a.type === 'news');
            const otherAlerts = alerts.filter(a => a.type !== 'news');

            // Play alert sound
            useEffect(() => {
                const hasSound = alerts.some(a => a.sound);
                if (hasSound) {
                    // Create a simple beep sound
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();

                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        oscillator.frequency.value = 800;
                        oscillator.type = 'sine';
                        gainNode.gain.value = 0.3;

                        oscillator.start();
                        setTimeout(() => {
                            oscillator.stop();
                            audioContext.close();
                        }, 200);
                    } catch (e) {
                        console.log('Could not play alert sound');
                    }
                }
            }, [alerts]);

            // Open link in new tab
            const openArticle = (link) => {
                if (link) {
                    window.open(link, '_blank', 'noopener,noreferrer');
                }
            };

            return (
                <div className="fixed top-4 right-4 z-50 space-y-2 max-w-md">
                    {/* Regular alerts (non-news) with pulse */}
                    {otherAlerts.map((alert, idx) => (
                        <div
                            key={`alert-${idx}`}
                            className={`p-4 rounded-xl border shadow-2xl animate-pulse ${
                                alert.priority === ALERT_PRIORITIES.CRITICAL
                                    ? 'bg-red-900/90 border-red-500'
                                    : alert.priority === ALERT_PRIORITIES.WARNING
                                        ? 'bg-yellow-900/90 border-yellow-500'
                                        : 'bg-blue-900/90 border-blue-500'
                            }`}
                        >
                            <div className="flex justify-between items-start">
                                <div>
                                    <div className="font-bold text-lg flex items-center gap-2">
                                        {alert.priority === ALERT_PRIORITIES.CRITICAL ? 'üö®' : alert.priority === ALERT_PRIORITIES.WARNING ? '‚ö†Ô∏è' : '‚ÑπÔ∏è'}
                                        {alert.ticker}
                                    </div>
                                    <div className="text-sm mt-1">{alert.message}</div>
                                    {alert.note && <div className="text-xs text-gray-300 mt-1">üìù {alert.note}</div>}
                                </div>
                                <button
                                    onClick={() => onDismiss(alerts.indexOf(alert))}
                                    className="text-gray-400 hover:text-white text-xl ml-2"
                                >
                                    ‚úï
                                </button>
                            </div>
                        </div>
                    ))}

                    {/* News alerts - organized card without pulse */}
                    {newsAlerts.length > 0 && (
                        <div className="bg-gray-900/95 border border-purple-500/50 rounded-xl shadow-2xl overflow-hidden">
                            <div className="p-3 bg-purple-900/50 border-b border-purple-500/30 flex justify-between items-center">
                                <div className="flex items-center gap-2">
                                    <span className="text-lg">üì∞</span>
                                    <span className="font-bold">Breaking News</span>
                                    <span className="text-xs bg-purple-500/30 px-2 py-0.5 rounded-full">{newsAlerts.length} new</span>
                                </div>
                                <button
                                    onClick={() => newsAlerts.forEach(a => onDismiss(alerts.indexOf(a)))}
                                    className="text-gray-400 hover:text-white text-sm"
                                >
                                    Clear all
                                </button>
                            </div>
                            <div className="max-h-80 overflow-y-auto">
                                {newsAlerts.map((alert, idx) => (
                                    <div
                                        key={`news-${idx}`}
                                        className="p-3 border-b border-gray-700/50 hover:bg-gray-800/50 transition-colors cursor-pointer"
                                        onClick={() => openArticle(alert.link)}
                                    >
                                        <div className="flex justify-between items-start gap-2">
                                            <div className="flex-1 min-w-0">
                                                <div className="flex items-center gap-2 mb-1">
                                                    <span className="font-bold text-purple-400 text-sm">{alert.ticker}</span>
                                                    {alert.note && <span className="text-xs text-gray-500">‚Ä¢ {alert.note}</span>}
                                                </div>
                                                <div className="text-sm text-gray-200 line-clamp-2">
                                                    {alert.message.replace(`üì∞ ${alert.ticker}: `, '')}
                                                </div>
                                                {alert.link && (
                                                    <div className="text-xs text-blue-400 mt-1 hover:underline flex items-center gap-1">
                                                        Read full article ‚Üí
                                                    </div>
                                                )}
                                            </div>
                                            <button
                                                onClick={(e) => { e.stopPropagation(); onDismiss(alerts.indexOf(alert)); }}
                                                className="text-gray-500 hover:text-white text-lg flex-shrink-0"
                                            >
                                                ‚úï
                                            </button>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {alerts.length > 1 && (
                        <button
                            onClick={onDismissAll}
                            className="w-full py-2 bg-gray-800 hover:bg-gray-700 rounded-xl text-sm"
                        >
                            Dismiss All ({alerts.length})
                        </button>
                    )}
                </div>
            );
        };

        // Calendar View Component for Trade Journal
        const CalendarView = ({ entries, onDayClick, dayOfWeekStats }) => {
            const [currentDate, setCurrentDate] = useState(new Date());
            const [selectedDay, setSelectedDay] = useState(null);

            // Get first day of month and total days
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const monthName = currentDate.toLocaleString('default', { month: 'long', year: 'numeric' });

            // Group trades by date
            const tradesByDate = {};
            entries.forEach(trade => {
                const date = trade.exitDate || trade.entryDate;
                if (date) {
                    const key = date.split('T')[0];
                    if (!tradesByDate[key]) {
                        tradesByDate[key] = { trades: [], pnl: 0 };
                    }
                    tradesByDate[key].trades.push(trade);
                    tradesByDate[key].pnl += trade.pnl || 0;
                }
            });

            // Calculate monthly stats
            const monthStart = `${year}-${String(month + 1).padStart(2, '0')}`;
            const monthTrades = entries.filter(t => (t.exitDate || t.entryDate || '').startsWith(monthStart));
            const monthPnL = monthTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);
            const monthWins = monthTrades.filter(t => t.pnl > 0).length;
            const monthWinRate = monthTrades.length > 0 ? (monthWins / monthTrades.length) * 100 : 0;

            // Generate calendar days
            const days = [];
            for (let i = 0; i < firstDay; i++) {
                days.push(null); // Empty cells before first day
            }
            for (let d = 1; d <= daysInMonth; d++) {
                const dateKey = `${year}-${String(month + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                days.push({ day: d, dateKey, data: tradesByDate[dateKey] });
            }

            const prevMonth = () => setCurrentDate(new Date(year, month - 1, 1));
            const nextMonth = () => setCurrentDate(new Date(year, month + 1, 1));
            const goToToday = () => setCurrentDate(new Date());

            return (
                <div className="space-y-4">
                    {/* Month Navigation */}
                    <div className="flex justify-between items-center">
                        <button onClick={prevMonth} className="p-2 hover:bg-gray-700 rounded-lg transition-colors">
                            ‚Üê Prev
                        </button>
                        <div className="text-center">
                            <div className="font-semibold text-lg">{monthName}</div>
                            <button onClick={goToToday} className="text-xs text-blue-400 hover:text-blue-300">Today</button>
                        </div>
                        <button onClick={nextMonth} className="p-2 hover:bg-gray-700 rounded-lg transition-colors">
                            Next ‚Üí
                        </button>
                    </div>

                    {/* Monthly Summary */}
                    <div className="grid grid-cols-3 gap-2 text-center">
                        <div className="bg-gray-800/50 p-3 rounded-xl border border-gray-700">
                            <div className="text-xs text-gray-500">Trades</div>
                            <div className="font-bold">{monthTrades.length}</div>
                        </div>
                        <div className="bg-gray-800/50 p-3 rounded-xl border border-gray-700">
                            <div className="text-xs text-gray-500">P&L</div>
                            <div className={`font-bold ${monthPnL >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                {monthPnL >= 0 ? '+' : ''}${monthPnL.toFixed(0)}
                            </div>
                        </div>
                        <div className="bg-gray-800/50 p-3 rounded-xl border border-gray-700">
                            <div className="text-xs text-gray-500">Win Rate</div>
                            <div className={`font-bold ${monthWinRate >= 50 ? 'text-green-400' : 'text-red-400'}`}>
                                {monthWinRate.toFixed(0)}%
                            </div>
                        </div>
                    </div>

                    {/* Calendar Grid */}
                    <div className="bg-gray-800/50 rounded-xl border border-gray-700 overflow-hidden">
                        {/* Day Headers */}
                        <div className="grid grid-cols-7 text-center text-xs text-gray-500 border-b border-gray-700">
                            {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(d => (
                                <div key={d} className="py-2 font-medium">{d}</div>
                            ))}
                        </div>

                        {/* Calendar Days */}
                        <div className="grid grid-cols-7">
                            {days.map((dayObj, idx) => {
                                if (!dayObj) {
                                    return <div key={`empty-${idx}`} className="aspect-square bg-gray-900/30" />;
                                }

                                const { day, dateKey, data } = dayObj;
                                const isToday = dateKey === new Date().toISOString().split('T')[0];
                                const hasTradesOnDay = data && data.trades.length > 0;
                                const pnl = data?.pnl || 0;

                                return (
                                    <div
                                        key={dateKey}
                                        onClick={() => {
                                            if (hasTradesOnDay) {
                                                setSelectedDay(selectedDay === dateKey ? null : dateKey);
                                                if (data.trades.length === 1) {
                                                    onDayClick(dateKey, data.trades);
                                                }
                                            }
                                        }}
                                        className={`aspect-square p-1 border-b border-r border-gray-700/50 flex flex-col items-center justify-center cursor-pointer transition-colors
                                            ${isToday ? 'ring-2 ring-blue-500 ring-inset' : ''}
                                            ${hasTradesOnDay ? (pnl >= 0 ? 'bg-green-500/20 hover:bg-green-500/30' : 'bg-red-500/20 hover:bg-red-500/30') : 'hover:bg-gray-700/30'}
                                            ${selectedDay === dateKey ? 'ring-2 ring-yellow-400 ring-inset' : ''}`}
                                    >
                                        <span className={`text-sm ${isToday ? 'font-bold text-blue-400' : ''}`}>{day}</span>
                                        {hasTradesOnDay && (
                                            <>
                                                <span className={`text-xs font-bold ${pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                    {pnl >= 0 ? '+' : ''}{pnl.toFixed(0)}
                                                </span>
                                                <span className="text-[10px] text-gray-500">{data.trades.length}</span>
                                            </>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {/* Selected Day Details */}
                    {selectedDay && tradesByDate[selectedDay] && tradesByDate[selectedDay].trades.length > 1 && (
                        <div className="bg-gray-800/50 p-4 rounded-xl border border-yellow-500/30">
                            <div className="text-sm font-semibold mb-3">
                                {new Date(selectedDay).toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' })} - {tradesByDate[selectedDay].trades.length} Trades
                            </div>
                            <div className="space-y-2">
                                {tradesByDate[selectedDay].trades.map(trade => (
                                    <div
                                        key={trade.id}
                                        onClick={() => onDayClick(selectedDay, [trade])}
                                        className={`p-3 rounded-lg cursor-pointer transition-colors ${
                                            trade.pnl >= 0 ? 'bg-green-900/30 hover:bg-green-900/50' : 'bg-red-900/30 hover:bg-red-900/50'
                                        }`}
                                    >
                                        <div className="flex justify-between items-center">
                                            <span className="font-semibold">{trade.ticker}</span>
                                            <span className={`font-bold ${trade.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                {trade.pnl >= 0 ? '+' : ''}${trade.pnl.toFixed(2)}
                                            </span>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Day of Week Performance */}
                    <div className="bg-gray-800/50 p-4 rounded-xl border border-gray-700">
                        <div className="text-sm font-semibold mb-3">Day of Week Performance</div>
                        <div className="grid grid-cols-7 gap-1 text-center text-xs">
                            {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, idx) => {
                                const stats = dayOfWeekStats[idx];
                                return (
                                    <div key={day} className="p-2">
                                        <div className="text-gray-500">{day}</div>
                                        <div className={`font-bold ${stats?.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                            {stats?.trades > 0 ? `${stats.pnl >= 0 ? '+' : ''}$${stats.pnl.toFixed(0)}` : '-'}
                                        </div>
                                        <div className="text-gray-600">{stats?.trades || 0}</div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {/* Legend */}
                    <div className="flex justify-center gap-4 text-xs text-gray-500">
                        <span><span className="inline-block w-3 h-3 bg-green-500/40 rounded mr-1"></span> Green Day</span>
                        <span><span className="inline-block w-3 h-3 bg-red-500/40 rounded mr-1"></span> Red Day</span>
                        <span><span className="inline-block w-3 h-3 border-2 border-blue-500 rounded mr-1"></span> Today</span>
                    </div>
                </div>
            );
        };

        // Main App Component
        const App = () => {
            const [positions, setPositions] = useState(samplePositions);
            const [showTalkMeDown, setShowTalkMeDown] = useState(false);
            const [showAddPosition, setShowAddPosition] = useState(false);
            const [showSettings, setShowSettings] = useState(false);
            const [showWelcome, setShowWelcome] = useState(() => !localStorage.getItem('welcomeSeen'));
            const [userName, setUserName] = useState(() => localStorage.getItem('userName') || 'Trader');
            const [welcomeNameInput, setWelcomeNameInput] = useState('');
            const [dismissedAlertBanners, setDismissedAlertBanners] = useState(() => {
                const saved = localStorage.getItem('dismissedAlertBanners');
                return saved ? JSON.parse(saved) : [];
            });
            const [watchlist, setWatchlist] = useState(() => {
                const saved = localStorage.getItem('watchlist');
                return saved ? JSON.parse(saved) : ['SPY', 'QQQ', 'AAPL', 'NVDA', 'TSLA'];
            });
            const [watchlistData, setWatchlistData] = useState({});
            const [watchlistLoading, setWatchlistLoading] = useState(false);
            const [showSplash, setShowSplash] = useState(false); // Disabled - using Option A instead
            const [loading, setLoading] = useState(true);
            const [trending, setTrending] = useState({ trending: [], posts: [] });
            const [insiderTrades, setInsiderTrades] = useState([]);
            const [activeTab, setActiveTab] = useState('dashboard');
            const [screenerTab, setScreenerTab] = useState('patterns');
            const [selectedPattern, setSelectedPattern] = useState('wedgedown');
            const [patternStocks, setPatternStocks] = useState([]);
            const [patternLoading, setPatternLoading] = useState(false);
            const [patternCategory, setPatternCategory] = useState('all');
            const [technicalScreenType, setTechnicalScreenType] = useState('rsi_oversold');
            const [technicalStocks, setTechnicalStocks] = useState([]);
            const [technicalLoading, setTechnicalLoading] = useState(false);
            const [chartStock, setChartStock] = useState(null); // Selected stock to show chart
            const [alerts, setAlerts] = useState([]);
            const [showAlerts, setShowAlerts] = useState(false);
            const [checklistItems, setChecklistItems] = useState([
                { id: 1, text: "I know my STOP before entering", checked: false },
                { id: 2, text: "I know my TARGET before entering", checked: false },
                { id: 3, text: "This is an A+ setup, not FOMO", checked: false },
                { id: 4, text: "Position size is 1-2% max risk", checked: false },
                { id: 5, text: "I accept I could lose this trade", checked: false }
            ]);
            const [lastAlertCheck, setLastAlertCheck] = useState(null);
            const [previousPnL, setPreviousPnL] = useState({}); // Track previous P&L to detect changes
            // Track when user dismissed alerts - use localStorage to persist across sessions
            const getInitialDismissTime = () => {
                const saved = localStorage.getItem('alertsDismissedAt');
                return saved ? parseInt(saved) : null;
            };
            const [alertsDismissedAt, setAlertsDismissedAt] = useState(getInitialDismissTime());
            const [selectedPositionDetail, setSelectedPositionDetail] = useState(null); // Position detail modal

            // Custom Alert System State
            const [showAlertManager, setShowAlertManager] = useState(false);
            const [triggeredAlerts, setTriggeredAlerts] = useState([]); // Popup notifications
            const [customAlerts, setCustomAlerts] = useState(loadCustomAlerts());
            const [newsWatchlist, setNewsWatchlist] = useState(loadNewsWatchlist());
            const [seenNewsIds, setSeenNewsIds] = useState(() => {
                try { return JSON.parse(localStorage.getItem('seenNewsIds') || '[]'); } catch { return []; }
            });
            const [alertHistory, setAlertHistory] = useState(loadAlertHistory());
            const [rsiCache, setRsiCache] = useState({}); // Cache RSI values
            const [priceCache, setPriceCache] = useState({}); // Cache latest prices
            const [priceHistory, setPriceHistory] = useState({}); // { ticker: [{price, timestamp}] } for velocity detection
            const [stockInfoCache, setStockInfoCache] = useState({}); // { ticker: { fiftyTwoWeekHigh, fiftyTwoWeekLow, previousClose, volume, avgVolume } }

            // Firebase Cloud Messaging State
            const [fcmToken, setFcmToken] = useState(null);
            const [pushEnabled, setPushEnabled] = useState(false);
            const [fcmError, setFcmError] = useState(null);

            // Scalper Mode State
            const [showScalperMode, setShowScalperMode] = useState(false);
            const [tradeStats, setTradeStats] = useState(loadTradeStats());
            const [dailyGoal, setDailyGoal] = useState(loadDailyGoal());

            // Trade Journal State
            const [journalEntries, setJournalEntries] = useState(loadJournalEntries());
            const [showAddTrade, setShowAddTrade] = useState(false);
            const [showCoach, setShowCoach] = useState(false);
            const [coachQuestion, setCoachQuestion] = useState('');
            const [coachResponse, setCoachResponse] = useState(null);
            const [showTradeAnalysis, setShowTradeAnalysis] = useState(false);
            const [editingNotes, setEditingNotes] = useState(false);
            const [editedNotes, setEditedNotes] = useState('');
            const [journalView, setJournalView] = useState('list'); // 'list', 'stats', 'calendar'
            const [journalFilter, setJournalFilter] = useState({ ticker: '', setup: '', result: 'all', dateRange: 'all' });
            const [selectedJournalTrade, setSelectedJournalTrade] = useState(null);
            const journalStats = calculateJournalStats(journalEntries);

            // Brokerage Integration State
            const [brokerageUserId] = useState(() => {
                // Use a stable user ID (generate once and save to localStorage)
                let id = localStorage.getItem('brokerageUserId');
                if (!id) {
                    id = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('brokerageUserId', id);
                }
                return id;
            });
            const [connectedBrokerages, setConnectedBrokerages] = useState([]);
            const [brokeragePositions, setBrokeragePositions] = useState([]);
            const [brokerageLoading, setBrokerageLoading] = useState(false);
            const [tradeSyncing, setTradeSyncing] = useState(false);
            const [lastTradeSync, setLastTradeSync] = useState(null);
            const [tradesImported, setTradesImported] = useState(0);
            const [brokerageSyncTime, setBrokerageSyncTime] = useState(null);
            const [brokerageError, setBrokerageError] = useState(null);
            const [supportedBrokerages, setSupportedBrokerages] = useState([]);
            const [autoImportTrades, setAutoImportTrades] = useState(() => {
                return localStorage.getItem('autoImportTrades') !== 'false';
            });

            // Load enabled patterns from localStorage (default: popular patterns)
            // Also ensures any new POPULAR_PATTERNS are added for existing users
            const getInitialEnabledPatterns = () => {
                const saved = localStorage.getItem('enabledPatterns');
                if (saved) {
                    const savedPatterns = JSON.parse(saved);
                    // Merge in any new popular patterns that might have been added
                    const merged = [...new Set([...savedPatterns, ...POPULAR_PATTERNS])];
                    // Save the merged list back
                    localStorage.setItem('enabledPatterns', JSON.stringify(merged));
                    return merged;
                }
                return POPULAR_PATTERNS; // Start with popular patterns by default
            };

            // Load trading mode settings from localStorage
            const getInitialTradingMode = () => localStorage.getItem('tradingMode') || 'standard';
            const getInitialGuardianSettings = () => {
                try {
                    return JSON.parse(localStorage.getItem('guardianSettings')) || {
                        dailyLossLimit: 500,
                        cooldownMinutes: 5,
                        blockBadPatterns: true,
                        autoGuardianHours: []
                    };
                } catch { return { dailyLossLimit: 500, cooldownMinutes: 5, blockBadPatterns: true, autoGuardianHours: [] }; }
            };

            const [settings, setSettings] = useState({
                personality: 'homie',
                guardianMode: true,
                alertFrequency: 'balanced',
                realtimePnLAlerts: true, // Alert when positions go red/green
                enabledPatterns: getInitialEnabledPatterns(),
                tradingMode: getInitialTradingMode(), // 'guardian' | 'standard' | 'aggressive' (Send It Mode)
                guardianSettings: getInitialGuardianSettings()
            });

            // Lockout state for Guardian Mode
            const [lockout, setLockout] = useState(() => {
                const emergencyUntil = localStorage.getItem('emergencyBrakeUntil');
                const lockoutUntil = localStorage.getItem('lockoutUntil');
                const now = Date.now();
                if (emergencyUntil && parseInt(emergencyUntil) > now) {
                    return { active: true, reason: 'emergency', until: parseInt(emergencyUntil) };
                }
                if (lockoutUntil && parseInt(lockoutUntil) > now) {
                    return { active: true, reason: 'daily_loss', until: parseInt(lockoutUntil) };
                }
                return { active: false, reason: '', until: null };
            });

            // Track last loss time for cooldown
            const [lastLossTime, setLastLossTime] = useState(() => {
                const saved = localStorage.getItem('lastLossTime');
                return saved ? parseInt(saved) : null;
            });

            // Timer tick for lockout countdown refresh
            const [lockoutTick, setLockoutTick] = useState(0);
            useEffect(() => {
                if (lockout.active) {
                    const interval = setInterval(() => setLockoutTick(t => t + 1), 1000);
                    return () => clearInterval(interval);
                }
            }, [lockout.active]);

            // ===== BROKERAGE INTEGRATION FUNCTIONS =====

            // Fetch supported brokerages from server
            const fetchSupportedBrokerages = async () => {
                try {
                    const response = await fetch('/api/brokerage/supported');
                    const data = await response.json();
                    // Always set brokerages if available (even if not enabled yet)
                    if (data.brokerages) {
                        setSupportedBrokerages(data.brokerages);
                    }
                    // Store enabled status to show proper message
                    if (!data.enabled) {
                        setBrokerageError('SnapTrade not configured. Add API keys to .env file.');
                    }
                } catch (err) {
                    console.log('[Brokerage] Could not fetch supported brokerages:', err.message);
                }
            };

            // Register user with SnapTrade (called once on first brokerage connection)
            const registerBrokerageUser = async () => {
                try {
                    const response = await fetch('/api/brokerage/user', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userId: brokerageUserId })
                    });
                    const data = await response.json();
                    return data.success;
                } catch (err) {
                    console.error('[Brokerage] User registration failed:', err.message);
                    return false;
                }
            };

            // Connect a brokerage (opens OAuth flow)
            const connectBrokerage = async (brokerageId) => {
                console.log('[Brokerage] Connecting to:', brokerageId);
                setBrokerageLoading(true);
                setBrokerageError(null);
                try {
                    // Ensure user is registered
                    const registered = await registerBrokerageUser();
                    console.log('[Brokerage] User registered:', registered);

                    // Get connection link
                    console.log('[Brokerage] Fetching connection link...');
                    const response = await fetch('/api/brokerage/connect', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userId: brokerageUserId, brokerage: brokerageId })
                    });
                    console.log('[Brokerage] Response status:', response.status);
                    const data = await response.json();
                    console.log('[Brokerage] Response data:', data);

                    if (data.redirectUrl) {
                        // Open OAuth in new window/tab
                        window.open(data.redirectUrl, '_blank', 'width=600,height=700');
                    } else {
                        const errorMsg = data.error || 'Could not get connection link';
                        console.log('[Brokerage] Error:', errorMsg);
                        setBrokerageError(errorMsg);
                    }
                } catch (err) {
                    console.error('[Brokerage] Exception:', err);
                    setBrokerageError(err.message);
                } finally {
                    setBrokerageLoading(false);
                }
            };

            // Fetch all positions from connected brokerages
            const fetchBrokeragePositions = async () => {
                setBrokerageLoading(true);
                setBrokerageError(null);
                try {
                    const response = await fetch(`/api/brokerage/positions?userId=${brokerageUserId}`);
                    const data = await response.json();

                    if (data.error) {
                        if (!data.error.includes('User not found')) {
                            setBrokerageError(data.error);
                        }
                        return;
                    }

                    setBrokeragePositions(data.positions || []);
                    setBrokerageSyncTime(new Date(data.lastSync));

                    // Extract unique brokerages from positions
                    const uniqueBrokerages = [...new Set(data.positions.map(p => p.source))];
                    setConnectedBrokerages(uniqueBrokerages);

                } catch (err) {
                    console.log('[Brokerage] Fetch positions failed:', err.message);
                } finally {
                    setBrokerageLoading(false);
                }
            };

            // Fetch recent trades for auto-journaling - matches BUY/SELL pairs for real P&L
            const fetchBrokerageTrades = async (days = 7) => {
                setTradeSyncing(true);
                try {
                    const response = await fetch(`/api/brokerage/trades?userId=${brokerageUserId}&days=${days}`);
                    const data = await response.json();

                    if (data.trades && data.trades.length > 0 && autoImportTrades) {
                        // Group trades by ticker
                        const tradesByTicker = {};
                        data.trades.forEach(trade => {
                            if (!trade.ticker) return;
                            if (!tradesByTicker[trade.ticker]) {
                                tradesByTicker[trade.ticker] = { buys: [], sells: [] };
                            }
                            const tradeData = {
                                ...trade,
                                date: new Date(trade.date),
                                quantity: Math.abs(trade.quantity || 0),
                                price: trade.price || 0
                            };
                            if (trade.type === 'buy') {
                                tradesByTicker[trade.ticker].buys.push(tradeData);
                            } else if (trade.type === 'sell') {
                                tradesByTicker[trade.ticker].sells.push(tradeData);
                            }
                        });

                        // Match buys with sells (FIFO - first in, first out)
                        const closedTrades = [];
                        const existingTradeIds = new Set(
                            journalEntries
                                .filter(e => e.external_trade_id)
                                .map(e => e.external_trade_id)
                        );

                        Object.entries(tradesByTicker).forEach(([ticker, { buys, sells }]) => {
                            // Sort by date (oldest first for FIFO)
                            buys.sort((a, b) => a.date - b.date);
                            sells.sort((a, b) => a.date - b.date);

                            // Match each sell with corresponding buys
                            for (const sell of sells) {
                                let remainingToSell = sell.quantity;
                                let totalCost = 0;
                                let totalShares = 0;
                                let entryDate = null;
                                const matchedBuyIds = [];

                                for (const buy of buys) {
                                    if (remainingToSell <= 0) break;
                                    if (buy.remainingQty === undefined) buy.remainingQty = buy.quantity;
                                    if (buy.remainingQty <= 0) continue;
                                    if (buy.date > sell.date) continue; // Can't sell before buying

                                    const sharesToMatch = Math.min(remainingToSell, buy.remainingQty);
                                    totalCost += sharesToMatch * buy.price;
                                    totalShares += sharesToMatch;
                                    buy.remainingQty -= sharesToMatch;
                                    remainingToSell -= sharesToMatch;
                                    matchedBuyIds.push(buy.id);

                                    if (!entryDate || buy.date < entryDate) {
                                        entryDate = buy.date;
                                    }
                                }

                                // If we matched shares, create a closed trade
                                if (totalShares > 0) {
                                    const avgEntryPrice = totalCost / totalShares;
                                    const pnl = (sell.price - avgEntryPrice) * totalShares;
                                    const tradeId = `${sell.id}_${matchedBuyIds.join('_')}`;

                                    // Skip if already imported
                                    if (existingTradeIds.has(tradeId)) continue;

                                    closedTrades.push({
                                        id: Date.now() + Math.random(),
                                        ticker,
                                        side: 'long',
                                        assetType: 'stock',
                                        entryPrice: parseFloat(avgEntryPrice.toFixed(2)),
                                        exitPrice: parseFloat(sell.price.toFixed(2)),
                                        quantity: totalShares,
                                        entryDate: entryDate.toISOString(),
                                        exitDate: sell.date.toISOString(),
                                        pnl: parseFloat(pnl.toFixed(2)),
                                        fees: 0,
                                        setup: 'other',
                                        mistakes: ['none'],
                                        emotionBefore: 'neutral',
                                        emotionAfter: pnl >= 0 ? 'confident' : 'frustrated',
                                        followedPlan: true,
                                        notes: `Auto-imported from ${sell.source || 'brokerage'}`,
                                        source: 'auto',
                                        external_trade_id: tradeId
                                    });
                                }
                            }
                        });

                        if (closedTrades.length > 0) {
                            const updated = [...journalEntries, ...closedTrades];
                            setJournalEntries(updated);
                            saveJournalEntries(updated);
                            setTradesImported(closedTrades.length);
                            console.log(`[Brokerage] Auto-imported ${closedTrades.length} closed trades with real P&L`);
                        }
                    }
                    setLastTradeSync(new Date());
                } catch (err) {
                    console.log('[Brokerage] Fetch trades failed:', err.message);
                } finally {
                    setTradeSyncing(false);
                }
            };

            // Check for OAuth callback on page load
            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const brokerageConnected = urlParams.get('brokerage_connected');

                if (brokerageConnected) {
                    // Clear URL params
                    window.history.replaceState({}, '', window.location.pathname);
                    // Refresh positions
                    fetchBrokeragePositions();
                    fetchBrokerageTrades();
                }

                // Initial load
                fetchSupportedBrokerages();
                fetchBrokeragePositions();
                // Auto-fetch trades on load if auto-import is enabled
                if (autoImportTrades) {
                    setTimeout(() => fetchBrokerageTrades(30), 2000); // Fetch last 30 days on load
                }
            }, []);

            // Auto-sync positions AND trades every 5 minutes
            useEffect(() => {
                if (connectedBrokerages.length > 0) {
                    const interval = setInterval(() => {
                        fetchBrokeragePositions();
                        if (autoImportTrades) {
                            fetchBrokerageTrades(7); // Sync last 7 days
                        }
                    }, 5 * 60 * 1000); // 5 minutes
                    return () => clearInterval(interval);
                }
            }, [connectedBrokerages.length, autoImportTrades]);

            // Auto-dismiss trade sync toast after 3 seconds
            useEffect(() => {
                if (tradesImported > 0) {
                    const timer = setTimeout(() => {
                        setTradesImported(0);
                    }, 3500);
                    return () => clearTimeout(timer);
                }
            }, [tradesImported]);

            // Option B: Auto-hide splash screen after 2 seconds
            useEffect(() => {
                const timer = setTimeout(() => {
                    setShowSplash(false);
                }, 2000);
                return () => clearTimeout(timer);
            }, []);

            // Save trading mode settings to localStorage
            useEffect(() => {
                localStorage.setItem('tradingMode', settings.tradingMode);
                localStorage.setItem('guardianSettings', JSON.stringify(settings.guardianSettings));
            }, [settings.tradingMode, settings.guardianSettings]);

            // Clear lockout when time expires
            useEffect(() => {
                if (lockout.active && lockout.until) {
                    const timeLeft = lockout.until - Date.now();
                    if (timeLeft <= 0) {
                        setLockout({ active: false, reason: '', until: null });
                        localStorage.removeItem('lockoutUntil');
                        localStorage.removeItem('emergencyBrakeUntil');
                    } else {
                        const timer = setTimeout(() => {
                            setLockout({ active: false, reason: '', until: null });
                            localStorage.removeItem('lockoutUntil');
                            localStorage.removeItem('emergencyBrakeUntil');
                        }, timeLeft);
                        return () => clearTimeout(timer);
                    }
                }
            }, [lockout]);

            // Calculate today's P&L from journal
            const calculateTodaysPnL = () => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const todaysTrades = journalEntries.filter(entry => {
                    const exitDate = new Date(entry.exitDate || entry.entryDate);
                    exitDate.setHours(0, 0, 0, 0);
                    return exitDate.getTime() === today.getTime();
                });
                return todaysTrades.reduce((sum, entry) => sum + (entry.pnl || 0), 0);
            };

            // Check daily loss limit and trigger lockout
            useEffect(() => {
                if (settings.tradingMode !== 'guardian') return;
                if (!settings.guardianSettings?.dailyLossLimitEnabled) return;

                const todaysPnL = calculateTodaysPnL();
                const lossLimit = settings.guardianSettings?.dailyLossLimit || 500;

                if (todaysPnL < -lossLimit && !lockout.active) {
                    const lockoutUntil = Date.now() + (24 * 60 * 60 * 1000); // Lock until end of day (24hrs)
                    localStorage.setItem('lockoutUntil', lockoutUntil.toString());
                    setLockout({
                        active: true,
                        reason: 'daily_loss',
                        until: lockoutUntil
                    });
                }
            }, [journalEntries, settings.tradingMode, settings.guardianSettings]);

            // Track last loss time when journal entries change
            useEffect(() => {
                if (journalEntries.length > 0) {
                    const sortedEntries = [...journalEntries].sort((a, b) =>
                        new Date(b.exitDate || b.entryDate) - new Date(a.exitDate || a.entryDate)
                    );
                    const lastTrade = sortedEntries[0];
                    if (lastTrade && lastTrade.pnl < 0) {
                        const lossTime = new Date(lastTrade.exitDate || lastTrade.entryDate).getTime();
                        if (lossTime !== lastLossTime) {
                            setLastLossTime(lossTime);
                            localStorage.setItem('lastLossTime', lossTime.toString());

                            // Cooldown check (Guardian mode only)
                            if (settings.tradingMode === 'guardian' && settings.guardianSettings?.cooldownEnabled) {
                                const cooldownMins = settings.guardianSettings?.cooldownMinutes || 5;
                                const cooldownUntil = lossTime + (cooldownMins * 60 * 1000);
                                if (cooldownUntil > Date.now() && !lockout.active) {
                                    setLockout({
                                        active: true,
                                        reason: 'cooldown',
                                        until: cooldownUntil
                                    });
                                }
                            }
                        }
                    }
                }
            }, [journalEntries]);

            // Emergency brake function
            const activateEmergencyBrake = (hours = 1) => {
                const until = Date.now() + (hours * 60 * 60 * 1000);
                localStorage.setItem('emergencyBrakeUntil', until.toString());
                setLockout({
                    active: true,
                    reason: 'emergency',
                    until: until
                });
            };

            // AI Position Monitor - Scans positions and generates alerts
            const analyzePositionsForAlerts = (positions, prevPnL, enableRealtimeAlerts = true) => {
                const newAlerts = [];
                const now = new Date();
                const newPnLTracker = {};

                positions.forEach(pos => {
                    const pnlPercent = ((pos.currentPrice - pos.entryPrice) / pos.entryPrice) * 100;
                    const daysToExpiry = pos.expiration ? getDaysToExpiry(pos.expiration) : null;
                    const isOption = pos.type === 'option';
                    const posDesc = isOption
                        ? `${pos.ticker} $${pos.strike} ${pos.optionType?.toUpperCase()}`
                        : pos.ticker;

                    // Track P&L for change detection
                    newPnLTracker[pos.id] = pnlPercent;
                    const prevPnlForPos = prevPnL[pos.id];

                    // ===== REAL-TIME CHANGE ALERTS (can be toggled off) =====
                    if (enableRealtimeAlerts) {
                        // Just went RED (was positive, now negative)
                        if (prevPnlForPos !== undefined && prevPnlForPos >= 0 && pnlPercent < 0) {
                            newAlerts.push({
                                id: `just-red-${pos.id}-${Date.now()}`,
                                type: 'critical',
                                icon: 'üî¥',
                                title: 'JUST WENT RED!',
                                ticker: pos.ticker,
                                message: `${posDesc} just turned negative! Was +${prevPnlForPos.toFixed(1)}%, now ${pnlPercent.toFixed(1)}%.`,
                                pnl: pnlPercent,
                                action: 'Check the chart - what happened?',
                                position: pos
                            });
                        }

                        // Just went GREEN (was negative, now positive)
                        if (prevPnlForPos !== undefined && prevPnlForPos < 0 && pnlPercent >= 0) {
                            newAlerts.push({
                                id: `just-green-${pos.id}-${Date.now()}`,
                                type: 'opportunity',
                                icon: 'üü¢',
                                title: 'JUST WENT GREEN!',
                                ticker: pos.ticker,
                                message: `${posDesc} just turned positive! Was ${prevPnlForPos.toFixed(1)}%, now +${pnlPercent.toFixed(1)}%.`,
                                pnl: pnlPercent,
                                action: 'Nice recovery! Lock in or ride it?',
                                position: pos
                            });
                        }

                        // Sudden drop (down 5%+ since last check)
                        if (prevPnlForPos !== undefined && (prevPnlForPos - pnlPercent) > 5) {
                            newAlerts.push({
                                id: `sudden-drop-${pos.id}-${Date.now()}`,
                                type: 'critical',
                                icon: 'üìâ',
                                title: 'SUDDEN DROP!',
                                ticker: pos.ticker,
                                message: `${posDesc} dropped ${(prevPnlForPos - pnlPercent).toFixed(1)}% since last update!`,
                                pnl: pnlPercent,
                                action: 'News? Support broken? Check NOW!',
                                position: pos
                            });
                        }

                        // Sudden spike (up 5%+ since last check)
                        if (prevPnlForPos !== undefined && (pnlPercent - prevPnlForPos) > 5 && pnlPercent > 0) {
                            newAlerts.push({
                                id: `sudden-spike-${pos.id}-${Date.now()}`,
                                type: 'opportunity',
                                icon: 'üìà',
                                title: 'SPIKING!',
                                ticker: pos.ticker,
                                message: `${posDesc} up ${(pnlPercent - prevPnlForPos).toFixed(1)}% since last update! Now +${pnlPercent.toFixed(1)}%`,
                                pnl: pnlPercent,
                                action: 'Lock in gains or let it ride?',
                                position: pos
                            });
                        }
                    }

                    // ===== CRITICAL ALERTS (Priority 1) =====

                    // Options expiring THIS WEEK
                    if (isOption && daysToExpiry !== null && daysToExpiry <= 7 && daysToExpiry >= 0) {
                        newAlerts.push({
                            id: `expire-${pos.id}`,
                            type: 'critical',
                            icon: 'üö®',
                            title: 'EXPIRING THIS WEEK',
                            ticker: pos.ticker,
                            message: `${posDesc} expires in ${daysToExpiry} day${daysToExpiry !== 1 ? 's' : ''}! ${pnlPercent >= 0 ? 'Consider taking profits or rolling.' : 'Decide: cut losses or roll out?'}`,
                            pnl: pnlPercent,
                            action: daysToExpiry <= 2 ? 'URGENT: Act today!' : 'Review this position',
                            position: pos
                        });
                    }

                    // Catastrophic loss on option with limited time
                    if (isOption && pnlPercent <= -70 && daysToExpiry !== null && daysToExpiry < 30) {
                        newAlerts.push({
                            id: `catastrophic-${pos.id}`,
                            type: 'critical',
                            icon: 'üíÄ',
                            title: 'POSITION IN TROUBLE',
                            ticker: pos.ticker,
                            message: `${posDesc} is down ${Math.abs(pnlPercent).toFixed(0)}% with only ${daysToExpiry} days left. Recovery is unlikely.`,
                            pnl: pnlPercent,
                            action: 'Consider cutting losses to preserve capital',
                            position: pos
                        });
                    }

                    // ===== WARNING ALERTS (Priority 2) =====

                    // Options expiring in 2 weeks with losses
                    if (isOption && daysToExpiry !== null && daysToExpiry > 7 && daysToExpiry <= 14 && pnlPercent < -20) {
                        newAlerts.push({
                            id: `expiry-warning-${pos.id}`,
                            type: 'warning',
                            icon: '‚ö†Ô∏è',
                            title: 'THETA ACCELERATING',
                            ticker: pos.ticker,
                            message: `${posDesc} is down ${Math.abs(pnlPercent).toFixed(0)}% with ${daysToExpiry} days left. Time decay is speeding up!`,
                            pnl: pnlPercent,
                            action: 'Needs a plan: hold, roll, or cut?',
                            position: pos
                        });
                    }

                    // Big unrealized gains - consider taking profits
                    if (pnlPercent >= 50) {
                        const warningType = pnlPercent >= 100 ? 'critical' : 'warning';
                        newAlerts.push({
                            id: `profit-${pos.id}`,
                            type: 'opportunity',
                            icon: 'üí∞',
                            title: pnlPercent >= 100 ? 'DOUBLED UP!' : 'BIG GAINS',
                            ticker: pos.ticker,
                            message: `${posDesc} is up ${pnlPercent.toFixed(0)}%! ${pnlPercent >= 100 ? 'You DOUBLED your money!' : 'Solid profits!'} Consider trimming.`,
                            pnl: pnlPercent,
                            action: 'Lock in some gains? Pigs get slaughtered.',
                            position: pos
                        });
                    }

                    // Position down significantly
                    if (pnlPercent <= -30 && pnlPercent > -70) {
                        // For options, check time
                        if (isOption && daysToExpiry !== null) {
                            if (daysToExpiry > 60) {
                                // LEAPs have time, just monitor
                                newAlerts.push({
                                    id: `loss-monitor-${pos.id}`,
                                    type: 'info',
                                    icon: 'üëÄ',
                                    title: 'MONITORING LOSS',
                                    ticker: pos.ticker,
                                    message: `${posDesc} is down ${Math.abs(pnlPercent).toFixed(0)}% but has ${daysToExpiry} days to recover.`,
                                    pnl: pnlPercent,
                                    action: 'Keep watching - time is on your side',
                                    position: pos
                                });
                            } else {
                                newAlerts.push({
                                    id: `loss-warning-${pos.id}`,
                                    type: 'warning',
                                    icon: 'üìâ',
                                    title: 'DOWN SIGNIFICANT',
                                    ticker: pos.ticker,
                                    message: `${posDesc} is down ${Math.abs(pnlPercent).toFixed(0)}% with ${daysToExpiry} days left.`,
                                    pnl: pnlPercent,
                                    action: 'Have a plan - stop loss or thesis change?',
                                    position: pos
                                });
                            }
                        } else {
                            // Stocks - just monitor
                            newAlerts.push({
                                id: `stock-loss-${pos.id}`,
                                type: 'info',
                                icon: 'üìä',
                                title: 'STOCK DOWN',
                                ticker: pos.ticker,
                                message: `${pos.ticker} is down ${Math.abs(pnlPercent).toFixed(0)}%. No expiration so you have time.`,
                                pnl: pnlPercent,
                                action: 'Review your thesis - still valid?',
                                position: pos
                            });
                        }
                    }

                    // Momentum alerts
                    if (pos.momentum === 'ripping' && pnlPercent > 20) {
                        newAlerts.push({
                            id: `momentum-${pos.id}`,
                            type: 'opportunity',
                            icon: 'üöÄ',
                            title: 'RIPPING!',
                            ticker: pos.ticker,
                            message: `${posDesc} is ripping! Up ${pnlPercent.toFixed(0)}% with strong momentum.`,
                            pnl: pnlPercent,
                            action: 'Ride the wave but have a trailing stop!',
                            position: pos
                        });
                    }

                    if (pos.momentum === 'bleeding' && pnlPercent < -10) {
                        newAlerts.push({
                            id: `bleeding-${pos.id}`,
                            type: 'warning',
                            icon: 'ü©∏',
                            title: 'BLEEDING OUT',
                            ticker: pos.ticker,
                            message: `${posDesc} is bleeding - down ${Math.abs(pnlPercent).toFixed(0)}% with negative momentum.`,
                            pnl: pnlPercent,
                            action: 'Falling knife? Consider stopping the bleeding.',
                            position: pos
                        });
                    }
                });

                // Sort alerts by priority: critical > warning > opportunity > info
                const priorityOrder = { critical: 0, warning: 1, opportunity: 2, info: 3 };
                newAlerts.sort((a, b) => priorityOrder[a.type] - priorityOrder[b.type]);

                return { alerts: newAlerts, pnlTracker: newPnLTracker };
            };

            // Run alert analysis when positions change
            useEffect(() => {
                if (positions.length > 0) {
                    const { alerts: newAlerts, pnlTracker } = analyzePositionsForAlerts(
                        positions,
                        previousPnL,
                        settings.realtimePnLAlerts // Pass the toggle setting
                    );
                    setAlerts(newAlerts);
                    setPreviousPnL(pnlTracker);
                    setLastAlertCheck(new Date());

                    // If there are critical alerts and real-time alerts are enabled, auto-show the panel
                    // BUT only if user hasn't dismissed alerts in the last 60 seconds
                    if (settings.realtimePnLAlerts) {
                        const timeSinceDismiss = alertsDismissedAt ? (Date.now() - alertsDismissedAt) : Infinity;
                        const hasCritical = newAlerts.some(a => a.type === 'critical' && (
                            a.title === 'JUST WENT RED!' ||
                            a.title === 'SUDDEN DROP!' ||
                            a.title === 'EXPIRING THIS WEEK'
                        ));
                        // Only auto-show once per day (24 hours = 86400000ms)
                        if (hasCritical && !showAlerts && timeSinceDismiss > 86400000) {
                            setShowAlerts(true);
                        }
                    }
                }
            }, [positions, settings.realtimePnLAlerts]);

            // Auto-load selected pattern when switching to patterns tab
            useEffect(() => {
                if (screenerTab === 'patterns' && patternStocks.length === 0 && !patternLoading) {
                    const loadInitialPattern = async () => {
                        setPatternLoading(true);
                        const stocks = await fetchPatternStocks(selectedPattern);
                        if (stocks !== null) {
                            setPatternStocks(stocks);
                            setPatternLoading(false);
                        }
                    };
                    loadInitialPattern();
                }
            }, [screenerTab, selectedPattern]);

            // Save enabled patterns to localStorage when they change
            useEffect(() => {
                localStorage.setItem('enabledPatterns', JSON.stringify(settings.enabledPatterns));
            }, [settings.enabledPatterns]);

            // ===== FIREBASE CLOUD MESSAGING INITIALIZATION =====
            // This enables push notifications even when app is closed (when deployed to cloud)
            useEffect(() => {
                const initializeFirebase = async () => {
                    try {
                        // Check if Firebase config is set up
                        if (!window.FIREBASE_CONFIG ||
                            window.FIREBASE_CONFIG.apiKey === "YOUR_API_KEY" ||
                            !window.FIREBASE_CONFIG.apiKey) {
                            console.log('[FCM] Firebase not configured yet - push notifications disabled');
                            setFcmError('Firebase not configured');
                            return;
                        }

                        // Check if browser supports service workers and notifications
                        if (!('serviceWorker' in navigator) || !('Notification' in window)) {
                            console.log('[FCM] Browser does not support push notifications');
                            setFcmError('Browser not supported');
                            return;
                        }

                        // Initialize Firebase
                        if (!firebase.apps.length) {
                            firebase.initializeApp(window.FIREBASE_CONFIG);
                        }

                        // Register service worker
                        const registration = await navigator.serviceWorker.register('/firebase-messaging-sw.js');
                        console.log('[FCM] Service worker registered:', registration.scope);

                        // Get messaging instance
                        const messaging = firebase.messaging();

                        // Request notification permission
                        const permission = await Notification.requestPermission();
                        if (permission !== 'granted') {
                            console.log('[FCM] Notification permission denied');
                            setFcmError('Permission denied');
                            return;
                        }

                        // Get FCM token
                        const vapidKey = window.VAPID_KEY && window.VAPID_KEY !== "YOUR_VAPID_KEY"
                            ? window.VAPID_KEY
                            : null;

                        const token = await messaging.getToken({
                            vapidKey: vapidKey,
                            serviceWorkerRegistration: registration
                        });

                        if (token) {
                            console.log('[FCM] Token obtained:', token.substring(0, 20) + '...');
                            setFcmToken(token);
                            setPushEnabled(true);

                            // Save token locally
                            localStorage.setItem('fcmToken', token);

                            // Register token with backend (when deployed)
                            try {
                                await fetch('/api/register-push-token', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        token,
                                        alerts: customAlerts.filter(a => a.active).map(a => ({
                                            id: a.id,
                                            ticker: a.ticker,
                                            type: a.type,
                                            value: a.value
                                        }))
                                    })
                                });
                                console.log('[FCM] Token registered with backend');
                            } catch (err) {
                                // Backend endpoint not available yet (local dev)
                                console.log('[FCM] Backend registration skipped (not deployed)');
                            }
                        }

                        // Handle foreground messages
                        messaging.onMessage((payload) => {
                            console.log('[FCM] Foreground message:', payload);

                            // Show as triggered alert
                            const alert = {
                                id: Date.now(),
                                type: payload.data?.type || 'notification',
                                ticker: payload.data?.ticker || '',
                                message: payload.notification?.body || payload.data?.body,
                                title: payload.notification?.title || 'Alert',
                                timestamp: new Date()
                            };
                            setTriggeredAlerts(prev => [alert, ...prev]);
                        });

                    } catch (error) {
                        console.error('[FCM] Initialization error:', error);
                        setFcmError(error.message);
                    }
                };

                initializeFirebase();
            }, []);

            // Sync alerts to server whenever they change (for background notifications)
            const syncAlertsToServer = async () => {
                const token = fcmToken || localStorage.getItem('fcmToken');
                if (!token) {
                    console.log('[Sync] No FCM token - skipping sync');
                    return;
                }

                const activeAlerts = customAlerts.filter(a => a.active).map(a => ({
                    id: a.id,
                    ticker: a.ticker,
                    type: a.type,
                    value: parseFloat(a.value)
                }));

                console.log('[Sync] Syncing', activeAlerts.length, 'alerts to server with token:', token.substring(0, 20) + '...');

                try {
                    const response = await fetch('/api/register-push-token', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token, alerts: activeAlerts })
                    });
                    const result = await response.json();
                    console.log('[Sync] Server response:', result);
                } catch (err) {
                    console.log('[Sync] Failed to sync:', err.message);
                }
            };

            // Sync when alerts change
            useEffect(() => {
                const timeoutId = setTimeout(syncAlertsToServer, 1000);
                return () => clearTimeout(timeoutId);
            }, [customAlerts]);

            // Also sync when FCM token becomes available
            useEffect(() => {
                if (fcmToken) {
                    console.log('[Sync] FCM token available, syncing alerts...');
                    syncAlertsToServer();
                }
            }, [fcmToken]);

            // Force sync on page load after 3 seconds (gives Firebase time to init)
            useEffect(() => {
                const timeoutId = setTimeout(() => {
                    console.log('[Sync] Delayed page load sync...');
                    syncAlertsToServer();
                }, 3000);
                return () => clearTimeout(timeoutId);
            }, []);

            // Get only enabled patterns
            const getEnabledPatterns = () => {
                return CHART_PATTERNS.filter(p => settings.enabledPatterns.includes(p.id));
            };

            const [lastPriceUpdate, setLastPriceUpdate] = useState(null);
            const [isRefreshing, setIsRefreshing] = useState(false);

            // Fast price refresh function (only updates prices, not all data)
            const refreshPrices = async () => {
                if (positions.length === 0) return;
                setIsRefreshing(true);

                const updatedPositions = await Promise.all(
                    positions.map(async (pos) => {
                        try {
                            // For OPTIONS: fetch the actual option contract price
                            if (pos.type === 'option' && pos.expiration && pos.optionType && pos.strike) {
                                const optionData = await fetchOptionPrice(pos.ticker, pos.expiration, pos.optionType, pos.strike);

                                if (optionData && optionData.price) {
                                    const dayChange = optionData.percentChange?.toFixed(2) || '0.00';

                                    // Determine momentum from option's price movement
                                    let momentum = pos.momentum;
                                    const change = parseFloat(dayChange);
                                    if (change > 10) momentum = 'ripping';
                                    else if (change > 3) momentum = 'uptrend';
                                    else if (change < -10) momentum = 'bleeding';
                                    else if (change < -3) momentum = 'downtrend';

                                    console.log(`[Position Update] ${pos.ticker} ${pos.strike}${pos.optionType?.charAt(0).toUpperCase()}: Setting livePrice=${optionData.price}`);

                                    return {
                                        ...pos,
                                        livePrice: optionData.price,
                                        dayChange: dayChange,
                                        momentum: momentum,
                                        optionBid: optionData.bid,
                                        optionAsk: optionData.ask,
                                        optionVolume: optionData.volume,
                                        optionOI: optionData.openInterest,
                                        optionIV: optionData.impliedVolatility
                                    };
                                }
                                // Fallback: if option price fetch fails, return position unchanged
                                return pos;
                            }

                            // For STOCKS/CRYPTO: fetch the regular price
                            const response = await fetch(`/api/proxy?url=${encodeURIComponent(`https://query1.finance.yahoo.com/v8/finance/chart/${pos.ticker}?interval=1m&range=1d`)}`);
                            const data = await response.json();

                            if (data.chart?.result?.[0]?.meta?.regularMarketPrice) {
                                const newPrice = data.chart.result[0].meta.regularMarketPrice;
                                const previousClose = data.chart.result[0].meta.previousClose || newPrice;
                                const dayChange = ((newPrice - previousClose) / previousClose * 100).toFixed(2);

                                // Determine momentum from intraday movement
                                let momentum = pos.momentum;
                                if (parseFloat(dayChange) > 3) momentum = 'ripping';
                                else if (parseFloat(dayChange) > 1) momentum = 'uptrend';
                                else if (parseFloat(dayChange) < -3) momentum = 'bleeding';
                                else if (parseFloat(dayChange) < -1) momentum = 'downtrend';

                                return {
                                    ...pos,
                                    livePrice: newPrice,
                                    dayChange: dayChange,
                                    momentum: momentum
                                };
                            }
                        } catch (error) {
                            console.error(`Error refreshing ${pos.ticker}:`, error);
                        }
                        return pos;
                    })
                );

                setPositions(updatedPositions);
                setLastPriceUpdate(new Date());
                setIsRefreshing(false);
            };

            // Fetch real market data on load
            useEffect(() => {
                const fetchAllData = async () => {
                    setLoading(true);

                    // Fetch all data in parallel
                    const [trendingData, insiderData] = await Promise.all([
                        fetchTrendingStocks(),
                        fetchInsiderTrading()
                    ]);

                    setTrending(trendingData);
                    setInsiderTrades(insiderData);

                    // Fetch position data
                    const updatedPositions = await Promise.all(
                        positions.map(async (pos) => {
                            if (pos.type === 'crypto') return pos;

                            // For OPTIONS: fetch actual option contract price
                            if (pos.type === 'option' && pos.expiration && pos.optionType && pos.strike) {
                                const optionData = await fetchOptionPrice(pos.ticker, pos.expiration, pos.optionType, pos.strike);
                                const stockData = await fetchStockData(pos.ticker);

                                if (optionData && optionData.price) {
                                    const dayChange = optionData.percentChange?.toFixed(2) || '0.00';
                                    let momentum = pos.momentum;
                                    const change = parseFloat(dayChange);
                                    if (change > 10) momentum = 'ripping';
                                    else if (change > 3) momentum = 'uptrend';
                                    else if (change < -10) momentum = 'bleeding';
                                    else if (change < -3) momentum = 'downtrend';

                                    console.log(`[Initial Load] ${pos.ticker} ${pos.strike}${pos.optionType?.charAt(0).toUpperCase()}: Setting livePrice=${optionData.price}`);

                                    return {
                                        ...pos,
                                        livePrice: optionData.price,
                                        dayChange: dayChange,
                                        momentum: momentum,
                                        optionBid: optionData.bid,
                                        optionAsk: optionData.ask,
                                        optionVolume: optionData.volume,
                                        optionOI: optionData.openInterest,
                                        optionIV: optionData.impliedVolatility,
                                        stockPrice: stockData?.currentPrice,
                                        stockWeekChange: stockData?.weekChange,
                                        stockMonthChange: stockData?.monthChange
                                    };
                                } else {
                                    console.log(`[Initial Load] ${pos.ticker}: optionData fetch failed or no price`, optionData);
                                }
                            }

                            // For STOCKS: fetch stock data
                            const data = await fetchStockData(pos.ticker);
                            if (data) {
                                let finalMomentum = pos.momentum || data.momentum;

                                return {
                                    ...pos,
                                    livePrice: data.currentPrice,
                                    stockWeekChange: data.weekChange,
                                    stockMonthChange: data.monthChange,
                                    weekChange: data.weekChange,
                                    monthChange: data.monthChange,
                                    momentum: finalMomentum
                                };
                            }
                            return pos;
                        })
                    );
                    setPositions(updatedPositions);
                    setLastPriceUpdate(new Date());
                    setLoading(false);
                };
                fetchAllData();
            }, []);

            // Auto-refresh prices - FAST for real-time alerts
            useEffect(() => {
                const interval = setInterval(() => {
                    if (positions.length > 0 && !isRefreshing) {
                        refreshPrices();
                    }
                }, 5000); // 5 seconds - fast for real-time stock/crypto alerts

                return () => clearInterval(interval);
            }, [positions.length, isRefreshing]);

            // Fetch live price for any ticker (for alerts on non-position tickers)
            const fetchLivePrice = async (ticker) => {
                try {
                    const response = await fetch(`/api/proxy?url=${encodeURIComponent(`https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?interval=1m&range=1d`)}`);
                    const data = await response.json();
                    if (data.chart?.result?.[0]?.meta?.regularMarketPrice) {
                        return data.chart.result[0].meta.regularMarketPrice;
                    }
                    return null;
                } catch (e) {
                    console.error('Error fetching price for', ticker, e);
                    return null;
                }
            };

            // Fetch comprehensive stock info for advanced alerts (52w high/low, volume, prev close)
            const fetchStockInfo = async (ticker) => {
                try {
                    const response = await fetch(`/api/proxy?url=${encodeURIComponent(`https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?interval=1d&range=1y`)}`);
                    const data = await response.json();
                    const meta = data.chart?.result?.[0]?.meta;
                    const quotes = data.chart?.result?.[0]?.indicators?.quote?.[0];

                    if (meta) {
                        return {
                            regularMarketPrice: meta.regularMarketPrice,
                            previousClose: meta.previousClose || meta.chartPreviousClose,
                            fiftyTwoWeekHigh: meta.fiftyTwoWeekHigh,
                            fiftyTwoWeekLow: meta.fiftyTwoWeekLow,
                            volume: meta.regularMarketVolume,
                            avgVolume: quotes?.volume ? Math.round(quotes.volume.reduce((a, b) => a + (b || 0), 0) / quotes.volume.filter(v => v).length) : null
                        };
                    }
                    return null;
                } catch (e) {
                    console.error('Error fetching stock info for', ticker, e);
                    return null;
                }
            };

            // ===== REAL-TIME ALERT MONITORING ENGINE =====
            // Checks all custom alerts whenever positions update
            useEffect(() => {
                const checkAlerts = async () => {
                    const activeAlerts = customAlerts.filter(a => a.active);
                    if (activeAlerts.length === 0) return;

                    const newTriggered = [];

                    for (const alert of activeAlerts) {
                        let triggered = false;
                        let message = '';
                        let currentValue = null;

                        // Get current price for this ticker - from positions or fetch live
                        const position = positions.find(p => p.ticker === alert.ticker);
                        let livePrice = position?.livePrice || position?.currentPrice || priceCache[alert.ticker];

                        // If no price in cache/positions, fetch it for this ticker
                        if (!livePrice && (alert.type === ALERT_TYPES.PRICE_ABOVE || alert.type === ALERT_TYPES.PRICE_BELOW || alert.type === ALERT_TYPES.TRAILING_STOP)) {
                            livePrice = await fetchLivePrice(alert.ticker);
                            if (livePrice) {
                                setPriceCache(prev => ({ ...prev, [alert.ticker]: livePrice }));
                            }
                        }

                        // Price alerts
                        if (alert.type === ALERT_TYPES.PRICE_ABOVE && livePrice) {
                            if (livePrice >= alert.value) {
                                triggered = true;
                                message = `${alert.ticker} hit $${livePrice.toFixed(2)} (above $${alert.value})`;
                                currentValue = livePrice;
                            }
                        } else if (alert.type === ALERT_TYPES.PRICE_BELOW && livePrice) {
                            if (livePrice <= alert.value) {
                                triggered = true;
                                message = `${alert.ticker} dropped to $${livePrice.toFixed(2)} (below $${alert.value})`;
                                currentValue = livePrice;
                            }
                        }
                        // Percent gain/loss alerts (position-based)
                        else if (alert.type === ALERT_TYPES.PERCENT_GAIN && position) {
                            const pnlPercent = ((position.livePrice || position.currentPrice) - position.entryPrice) / position.entryPrice * 100;
                            if (pnlPercent >= alert.value) {
                                triggered = true;
                                message = `${alert.ticker} is up ${pnlPercent.toFixed(1)}% (target: ${alert.value}%)`;
                                currentValue = pnlPercent;
                            }
                        } else if (alert.type === ALERT_TYPES.PERCENT_LOSS && position) {
                            const pnlPercent = ((position.livePrice || position.currentPrice) - position.entryPrice) / position.entryPrice * 100;
                            if (pnlPercent <= -alert.value) {
                                triggered = true;
                                message = `${alert.ticker} is down ${Math.abs(pnlPercent).toFixed(1)}% (stop: -${alert.value}%)`;
                                currentValue = pnlPercent;
                            }
                        }
                        // RSI alerts
                        else if (alert.type === ALERT_TYPES.RSI_ABOVE || alert.type === ALERT_TYPES.RSI_BELOW) {
                            let rsi = rsiCache[alert.ticker];
                            if (!rsi) {
                                rsi = await fetchRSIData(alert.ticker);
                                if (rsi) setRsiCache(prev => ({ ...prev, [alert.ticker]: rsi }));
                            }
                            if (rsi) {
                                if (alert.type === ALERT_TYPES.RSI_ABOVE && rsi >= alert.value) {
                                    triggered = true;
                                    message = `${alert.ticker} RSI is ${rsi.toFixed(1)} (overbought above ${alert.value})`;
                                    currentValue = rsi;
                                } else if (alert.type === ALERT_TYPES.RSI_BELOW && rsi <= alert.value) {
                                    triggered = true;
                                    message = `${alert.ticker} RSI is ${rsi.toFixed(1)} (oversold below ${alert.value})`;
                                    currentValue = rsi;
                                }
                            }
                        }
                        // Trailing stop
                        else if (alert.type === ALERT_TYPES.TRAILING_STOP && livePrice) {
                            const highestPrice = alert.highestPrice || livePrice;
                            const newHighest = Math.max(highestPrice, livePrice);
                            const dropPercent = ((newHighest - livePrice) / newHighest) * 100;

                            // Update highest price
                            if (newHighest > highestPrice) {
                                setCustomAlerts(prev => prev.map(a =>
                                    a.id === alert.id ? { ...a, highestPrice: newHighest } : a
                                ));
                            }

                            if (dropPercent >= alert.value) {
                                triggered = true;
                                message = `${alert.ticker} trailing stop triggered! Dropped ${dropPercent.toFixed(1)}% from high of $${newHighest.toFixed(2)}`;
                                currentValue = livePrice;
                            }
                        }

                        if (triggered) {
                            const triggeredAlert = {
                                ...alert,
                                message,
                                currentValue,
                                triggeredAt: new Date().toISOString()
                            };

                            newTriggered.push(triggeredAlert);

                            // Add to history
                            setAlertHistory(prev => {
                                const updated = [...prev, triggeredAlert];
                                saveAlertHistory(updated);
                                return updated;
                            });

                            // Deactivate if not repeating
                            if (!alert.repeat) {
                                setCustomAlerts(prev => {
                                    const updated = prev.map(a => a.id === alert.id ? { ...a, active: false } : a);
                                    saveCustomAlerts(updated);
                                    return updated;
                                });
                            }
                        }
                    }

                    if (newTriggered.length > 0) {
                        setTriggeredAlerts(prev => [...prev, ...newTriggered]);
                    }
                };

                checkAlerts();
            }, [positions, customAlerts]);

            // ===== ADVANCED REAL-TIME ALERT MONITORING ENGINE =====
            // Dedicated loop that checks ALL alert tickers every 30 seconds
            // Works for ANY ticker, not just positions
            useEffect(() => {
                const activeAlerts = customAlerts.filter(a => a.active);
                if (activeAlerts.length === 0) return;

                // Request browser notification permission on first alert
                if ('Notification' in window && Notification.permission === 'default') {
                    Notification.requestPermission();
                }

                const runAlertCheck = async () => {
                    console.log('[Alert Engine] Running check for', activeAlerts.length, 'alerts');

                    // Get unique tickers that need price checks
                    const priceTickers = [...new Set(
                        activeAlerts
                            .filter(a => [ALERT_TYPES.PRICE_ABOVE, ALERT_TYPES.PRICE_BELOW, ALERT_TYPES.TRAILING_STOP].includes(a.type))
                            .map(a => a.ticker)
                    )];

                    // Fetch all prices in parallel
                    const pricePromises = priceTickers.map(async (ticker) => {
                        try {
                            // Check positions first
                            const pos = positions.find(p => p.ticker === ticker);
                            if (pos?.livePrice) return { ticker, price: pos.livePrice };

                            // Otherwise fetch live
                            const price = await fetchLivePrice(ticker);
                            return { ticker, price };
                        } catch (e) {
                            return { ticker, price: null };
                        }
                    });

                    const priceResults = await Promise.all(pricePromises);
                    const livePrices = {};
                    priceResults.forEach(r => { if (r.price) livePrices[r.ticker] = r.price; });

                    // Update price cache
                    setPriceCache(prev => ({ ...prev, ...livePrices }));

                    const newTriggered = [];

                    for (const alert of activeAlerts) {
                        let triggered = false;
                        let message = '';
                        const livePrice = livePrices[alert.ticker];
                        const position = positions.find(p => p.ticker === alert.ticker);

                        // Price Above
                        if (alert.type === ALERT_TYPES.PRICE_ABOVE && livePrice) {
                            if (livePrice >= alert.value) {
                                triggered = true;
                                message = `üöÄ ${alert.ticker} broke above $${alert.value}! Now at $${livePrice.toFixed(2)}`;
                            }
                        }
                        // Price Below
                        else if (alert.type === ALERT_TYPES.PRICE_BELOW && livePrice) {
                            if (livePrice <= alert.value) {
                                triggered = true;
                                message = `üìâ ${alert.ticker} dropped below $${alert.value}! Now at $${livePrice.toFixed(2)}`;
                            }
                        }
                        // Percent Gain
                        else if (alert.type === ALERT_TYPES.PERCENT_GAIN && position) {
                            const currentPrice = position.livePrice || position.currentPrice;
                            const pnlPercent = ((currentPrice - position.entryPrice) / position.entryPrice * 100);
                            if (pnlPercent >= alert.value) {
                                triggered = true;
                                message = `üí∞ ${alert.ticker} is UP ${pnlPercent.toFixed(1)}%! Target ${alert.value}% hit!`;
                            }
                        }
                        // Percent Loss
                        else if (alert.type === ALERT_TYPES.PERCENT_LOSS && position) {
                            const currentPrice = position.livePrice || position.currentPrice;
                            const pnlPercent = ((currentPrice - position.entryPrice) / position.entryPrice * 100);
                            if (pnlPercent <= -alert.value) {
                                triggered = true;
                                message = `üõë ${alert.ticker} is DOWN ${Math.abs(pnlPercent).toFixed(1)}%! Stop level -${alert.value}% hit!`;
                            }
                        }
                        // Trailing Stop
                        else if (alert.type === ALERT_TYPES.TRAILING_STOP && livePrice) {
                            const highestPrice = alert.highestPrice || livePrice;

                            // Update highest price if current is higher
                            if (livePrice > highestPrice) {
                                setCustomAlerts(prev => prev.map(a =>
                                    a.id === alert.id ? { ...a, highestPrice: livePrice } : a
                                ));
                            }

                            // Check if dropped X% from highest
                            const dropPercent = ((highestPrice - livePrice) / highestPrice) * 100;
                            if (dropPercent >= alert.value && highestPrice > livePrice) {
                                triggered = true;
                                message = `üîª ${alert.ticker} trailing stop! Dropped ${dropPercent.toFixed(1)}% from high of $${highestPrice.toFixed(2)}`;
                            }
                        }
                        // RSI alerts
                        else if (alert.type === ALERT_TYPES.RSI_ABOVE || alert.type === ALERT_TYPES.RSI_BELOW) {
                            let rsi = rsiCache[alert.ticker];
                            if (!rsi) {
                                rsi = await fetchRSIData(alert.ticker);
                                if (rsi) setRsiCache(prev => ({ ...prev, [alert.ticker]: rsi }));
                            }
                            if (rsi) {
                                if (alert.type === ALERT_TYPES.RSI_ABOVE && rsi >= alert.value) {
                                    triggered = true;
                                    message = `üìä ${alert.ticker} RSI is ${rsi.toFixed(1)} - OVERBOUGHT above ${alert.value}!`;
                                } else if (alert.type === ALERT_TYPES.RSI_BELOW && rsi <= alert.value) {
                                    triggered = true;
                                    message = `üìä ${alert.ticker} RSI is ${rsi.toFixed(1)} - OVERSOLD below ${alert.value}!`;
                                }
                            }
                        }
                        // Price Velocity - detect X% move in last few minutes
                        else if (alert.type === ALERT_TYPES.PRICE_VELOCITY && livePrice) {
                            const history = priceHistory[alert.ticker] || [];
                            const fiveMinAgo = Date.now() - (5 * 60 * 1000);
                            const oldEntry = history.find(h => h.timestamp <= fiveMinAgo) || history[0];

                            // Store current price in history
                            setPriceHistory(prev => {
                                const existing = prev[alert.ticker] || [];
                                const updated = [...existing, { price: livePrice, timestamp: Date.now() }]
                                    .filter(h => h.timestamp > Date.now() - (10 * 60 * 1000)) // Keep 10 min
                                    .slice(-30); // Max 30 entries
                                return { ...prev, [alert.ticker]: updated };
                            });

                            if (oldEntry && oldEntry.price) {
                                const velocityPercent = Math.abs((livePrice - oldEntry.price) / oldEntry.price * 100);
                                if (velocityPercent >= alert.value) {
                                    const direction = livePrice > oldEntry.price ? 'üöÄ RIPPING' : 'üí• DUMPING';
                                    triggered = true;
                                    message = `‚ö° ${alert.ticker} ${direction}! Moved ${velocityPercent.toFixed(1)}% in ~5 min! Now $${livePrice.toFixed(2)}`;
                                }
                            }
                        }
                        // Volume Spike - detect volume X% above average
                        else if (alert.type === ALERT_TYPES.VOLUME_SPIKE) {
                            let info = stockInfoCache[alert.ticker];
                            if (!info) {
                                info = await fetchStockInfo(alert.ticker);
                                if (info) setStockInfoCache(prev => ({ ...prev, [alert.ticker]: info }));
                            }
                            if (info?.volume && info?.avgVolume) {
                                const volumeRatio = (info.volume / info.avgVolume) * 100;
                                if (volumeRatio >= alert.value + 100) { // alert.value is % ABOVE average
                                    triggered = true;
                                    message = `üîä ${alert.ticker} VOLUME SPIKE! ${volumeRatio.toFixed(0)}% of avg volume (${(info.volume/1000000).toFixed(1)}M vs ${(info.avgVolume/1000000).toFixed(1)}M avg)`;
                                }
                            }
                        }
                        // Gap Up - pre-market gap above previous close
                        else if (alert.type === ALERT_TYPES.GAP_UP && livePrice) {
                            let info = stockInfoCache[alert.ticker];
                            if (!info) {
                                info = await fetchStockInfo(alert.ticker);
                                if (info) setStockInfoCache(prev => ({ ...prev, [alert.ticker]: info }));
                            }
                            if (info?.previousClose) {
                                const gapPercent = ((livePrice - info.previousClose) / info.previousClose) * 100;
                                if (gapPercent >= alert.value) {
                                    triggered = true;
                                    message = `üåÖ ${alert.ticker} GAP UP ${gapPercent.toFixed(1)}%! From $${info.previousClose.toFixed(2)} to $${livePrice.toFixed(2)}`;
                                }
                            }
                        }
                        // Gap Down - pre-market gap below previous close
                        else if (alert.type === ALERT_TYPES.GAP_DOWN && livePrice) {
                            let info = stockInfoCache[alert.ticker];
                            if (!info) {
                                info = await fetchStockInfo(alert.ticker);
                                if (info) setStockInfoCache(prev => ({ ...prev, [alert.ticker]: info }));
                            }
                            if (info?.previousClose) {
                                const gapPercent = ((info.previousClose - livePrice) / info.previousClose) * 100;
                                if (gapPercent >= alert.value) {
                                    triggered = true;
                                    message = `üåô ${alert.ticker} GAP DOWN ${gapPercent.toFixed(1)}%! From $${info.previousClose.toFixed(2)} to $${livePrice.toFixed(2)}`;
                                }
                            }
                        }
                        // 52-Week Breakout
                        else if (alert.type === ALERT_TYPES.BREAKOUT && livePrice) {
                            let info = stockInfoCache[alert.ticker];
                            if (!info) {
                                info = await fetchStockInfo(alert.ticker);
                                if (info) setStockInfoCache(prev => ({ ...prev, [alert.ticker]: info }));
                            }
                            if (info?.fiftyTwoWeekHigh && livePrice >= info.fiftyTwoWeekHigh) {
                                triggered = true;
                                message = `üöÄ ${alert.ticker} 52-WEEK HIGH BREAKOUT! Now $${livePrice.toFixed(2)} (prev high: $${info.fiftyTwoWeekHigh.toFixed(2)})`;
                            }
                        }
                        // 52-Week Breakdown
                        else if (alert.type === ALERT_TYPES.BREAKDOWN && livePrice) {
                            let info = stockInfoCache[alert.ticker];
                            if (!info) {
                                info = await fetchStockInfo(alert.ticker);
                                if (info) setStockInfoCache(prev => ({ ...prev, [alert.ticker]: info }));
                            }
                            if (info?.fiftyTwoWeekLow && livePrice <= info.fiftyTwoWeekLow) {
                                triggered = true;
                                message = `üí• ${alert.ticker} 52-WEEK LOW BREAKDOWN! Now $${livePrice.toFixed(2)} (prev low: $${info.fiftyTwoWeekLow.toFixed(2)})`;
                            }
                        }

                        if (triggered) {
                            // Check if already triggered recently (within 5 min) unless repeat is on
                            const recentlyTriggered = alertHistory.some(h =>
                                h.alertId === alert.id &&
                                (Date.now() - new Date(h.triggeredAt).getTime()) < 300000
                            );

                            if (!recentlyTriggered || alert.repeat) {
                                // Personalize message based on AI personality
                                const personalizedMessage = personalizeAlertMessage(message, settings.personality);

                                const alertData = {
                                    alertId: alert.id,
                                    ticker: alert.ticker,
                                    type: alert.type,
                                    priority: alert.priority,
                                    message: personalizedMessage,
                                    note: alert.note,
                                    triggeredAt: new Date().toISOString(),
                                    sound: alert.sound
                                };

                                newTriggered.push(alertData);

                                // Browser push notification
                                if ('Notification' in window && Notification.permission === 'granted') {
                                    new Notification(`üîî ${alert.ticker} Alert!`, {
                                        body: personalizedMessage,
                                        icon: 'üîî',
                                        tag: `alert-${alert.id}`,
                                        requireInteraction: alert.priority === ALERT_PRIORITIES.CRITICAL
                                    });
                                }

                                // Deactivate non-repeat alerts
                                if (!alert.repeat) {
                                    setCustomAlerts(prev => prev.map(a =>
                                        a.id === alert.id ? { ...a, active: false, triggered: true } : a
                                    ));
                                }

                                // Add to history
                                setAlertHistory(prev => {
                                    const updated = [...prev, alertData];
                                    saveAlertHistory(updated);
                                    return updated;
                                });

                                console.log('[Alert Engine] TRIGGERED:', message);
                            }
                        }
                    }

                    if (newTriggered.length > 0) {
                        setTriggeredAlerts(prev => [...prev, ...newTriggered]);
                    }
                };

                // Run immediately then every 20 seconds for fast alerts
                runAlertCheck();
                const interval = setInterval(runAlertCheck, 20000);

                return () => clearInterval(interval);
            }, [customAlerts, positions, alertHistory, settings.personality]);

            // ===== NEWS MONITORING ENGINE =====
            // Checks for breaking news on watched tickers every 2 minutes
            useEffect(() => {
                if (newsWatchlist.length === 0) return;

                const checkNews = async () => {
                    for (const ticker of newsWatchlist) {
                        try {
                            const news = await fetchTickerNews(ticker);
                            const newNews = news.filter(n => !seenNewsIds.includes(n.uuid));

                            if (newNews.length > 0) {
                                // Mark as seen
                                const newIds = newNews.map(n => n.uuid);
                                setSeenNewsIds(prev => {
                                    const updated = [...prev, ...newIds].slice(-500); // Keep last 500
                                    localStorage.setItem('seenNewsIds', JSON.stringify(updated));
                                    return updated;
                                });

                                // Create news alerts
                                newNews.forEach(item => {
                                    const baseMessage = `üì∞ ${ticker}: ${item.title}`;
                                    const personalizedMessage = personalizeAlertMessage(baseMessage, settings.personality);

                                    const newsAlert = {
                                        ticker,
                                        type: 'news',
                                        priority: ALERT_PRIORITIES.INFO,
                                        sound: true,
                                        message: personalizedMessage,
                                        note: item.publisher,
                                        triggeredAt: new Date().toISOString(),
                                        link: item.link
                                    };

                                    setTriggeredAlerts(prev => [...prev, newsAlert]);
                                    setAlertHistory(prev => {
                                        const updated = [...prev, newsAlert];
                                        saveAlertHistory(updated);
                                        return updated;
                                    });
                                });
                            }
                        } catch (e) {
                            console.error('Error checking news for', ticker, e);
                        }
                    }
                };

                // Check immediately then every 2 minutes
                checkNews();
                const interval = setInterval(checkNews, 120000); // 2 minutes

                return () => clearInterval(interval);
            }, [newsWatchlist, seenNewsIds, settings.personality]);

            // Dismiss triggered alert
            const dismissTriggeredAlert = (idx) => {
                setTriggeredAlerts(prev => prev.filter((_, i) => i !== idx));
            };

            // Dismiss all triggered alerts
            const dismissAllTriggeredAlerts = () => {
                setTriggeredAlerts([]);
            };

            // Calculate total P&L
            const totalPnL = positions.reduce((sum, pos) => {
                return sum + (pos.currentPrice - pos.entryPrice) * pos.quantity;
            }, 0);

            // Get urgent positions
            const urgentPositions = positions.filter(p => {
                const urgency = getUrgency(p);
                return urgency.level === 'critical';
            });

            const handleAddPosition = (newPosition) => {
                setPositions([...positions, newPosition]);
            };

            const handleDeletePosition = (id) => {
                setPositions(positions.filter(p => p.id !== id));
            };

            return (
                <div className="min-h-screen pb-24">
                    {/* Header */}
                    <header className="sticky top-0 z-40 backdrop-blur-lg bg-gray-900/80 border-b border-gray-800">
                        <div className="max-w-lg mx-auto px-4 py-4">
                            <div className="flex justify-between items-center">
                                <div>
                                    <h1 className="text-xl font-bold">‚õÖ Zenith</h1>
                                    <p className="text-xs text-gray-400 flex items-center gap-2">
                                        {tradeSyncing ? (
                                            <span className="flex items-center gap-1"><span className="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></span> Syncing trades...</span>
                                        ) : loading ? (
                                            <span>‚è≥ Fetching live market data...</span>
                                        ) : isRefreshing ? (
                                            <span className="flex items-center gap-1"><span className="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></span> Updating prices...</span>
                                        ) : lastPriceUpdate ? (
                                            <span className="flex items-center gap-1"><span className="w-2 h-2 bg-green-400 rounded-full animate-pulse"></span> Live ‚Ä¢ Updated {lastPriceUpdate.toLocaleTimeString()}</span>
                                        ) : (
                                            <span>The logic you need when emotions take over</span>
                                        )}
                                    </p>
                                </div>
                                <div className="flex items-center gap-2">
                                    {/* Trading Mode Indicator */}
                                    <div
                                        onClick={() => setShowSettings(true)}
                                        className={`px-2 py-1 rounded-lg text-xs font-bold cursor-pointer transition-all ${
                                            settings.tradingMode === 'guardian' ? 'bg-red-500/20 text-red-400 border border-red-500/50 animate-pulse' :
                                            settings.tradingMode === 'aggressive' ? 'bg-yellow-500/20 text-yellow-400 border border-yellow-500/50' :
                                            'bg-blue-500/20 text-blue-400 border border-blue-500/50'
                                        }`}
                                        title={`${settings.tradingMode === 'guardian' ? 'Guardian' : settings.tradingMode === 'aggressive' ? 'Send It' : 'Standard'} Mode - Click to change`}
                                    >
                                        {settings.tradingMode === 'guardian' ? 'üõ°Ô∏è' : settings.tradingMode === 'aggressive' ? 'üöÄ' : '‚öñÔ∏è'}
                                    </div>
                                    {/* Scalper Mode */}
                                    <button
                                        onClick={() => setShowScalperMode(true)}
                                        className="p-2 hover:bg-gray-800 rounded-xl transition-colors"
                                        title="Scalper Mode"
                                    >
                                        üéØ
                                    </button>
                                    {/* Custom Alert Manager */}
                                    <button
                                        onClick={() => setShowAlertManager(true)}
                                        className="p-2 hover:bg-gray-800 rounded-xl transition-colors relative"
                                        title="Alert Manager"
                                    >
                                        ‚ö°
                                        {customAlerts.filter(a => a.active).length > 0 && (
                                            <span className="absolute -top-1 -right-1 w-5 h-5 bg-purple-500 rounded-full text-xs flex items-center justify-center font-bold">
                                                {customAlerts.filter(a => a.active).length}
                                            </span>
                                        )}
                                    </button>
                                    {/* Position Alerts Bell */}
                                    <button
                                        onClick={() => setShowAlerts(true)}
                                        className="p-2 hover:bg-gray-800 rounded-xl transition-colors relative"
                                        title="Position Alerts"
                                    >
                                        üîî
                                        {alerts.filter(a => a.type === 'critical' || a.type === 'warning').length > 0 && (
                                            <span className="absolute -top-1 -right-1 w-5 h-5 bg-red-500 rounded-full text-xs flex items-center justify-center font-bold animate-pulse">
                                                {alerts.filter(a => a.type === 'critical' || a.type === 'warning').length}
                                            </span>
                                        )}
                                    </button>
                                    <button
                                        onClick={() => setShowSettings(true)}
                                        className="p-2 hover:bg-gray-800 rounded-xl transition-colors"
                                    >
                                        ‚öôÔ∏è
                                    </button>
                                </div>
                            </div>
                        </div>
                    </header>

                    {/* Trade Sync Toast */}
                    {tradesImported > 0 && (
                        <div
                            className="fixed bottom-24 left-1/2 transform -translate-x-1/2 z-50 animate-bounce"
                            style={{ animation: 'fadeInOut 3s forwards' }}
                        >
                            <div className="bg-green-600 text-white px-4 py-2 rounded-full shadow-lg flex items-center gap-2 text-sm font-medium">
                                <span>‚úÖ</span>
                                <span>{tradesImported} trade{tradesImported > 1 ? 's' : ''} synced to journal</span>
                            </div>
                        </div>
                    )}

                    <main className="max-w-lg mx-auto px-4 py-6">

                        {/* Urgent Alerts */}
                        {urgentPositions.filter(pos => !dismissedAlertBanners.includes(pos.id)).map(pos => (
                            <AlertBanner
                                key={pos.id}
                                position={pos}
                                personality={settings.personality}
                                onDismiss={(id) => {
                                    const updated = [...dismissedAlertBanners, id];
                                    setDismissedAlertBanners(updated);
                                    localStorage.setItem('dismissedAlertBanners', JSON.stringify(updated));
                                }}
                            />
                        ))}

                        {/* Tab Navigation */}
                        <div className="flex gap-1 mb-4 overflow-x-auto">
                            <button
                                onClick={() => setActiveTab('dashboard')}
                                className={`flex-1 py-2 px-2 rounded-xl font-semibold transition-colors text-sm whitespace-nowrap ${activeTab === 'dashboard' ? 'bg-gradient-to-r from-blue-600 to-purple-600' : 'bg-gray-800 hover:bg-gray-700'}`}
                            >
                                üè† Home
                            </button>
                            <button
                                onClick={() => setActiveTab('positions')}
                                className={`flex-1 py-2 px-2 rounded-xl font-semibold transition-colors text-sm whitespace-nowrap ${activeTab === 'positions' ? 'bg-blue-600' : 'bg-gray-800 hover:bg-gray-700'}`}
                            >
                                üìä Trade
                            </button>
                            <button
                                onClick={() => setActiveTab('screeners')}
                                className={`flex-1 py-2 px-2 rounded-xl font-semibold transition-colors text-sm whitespace-nowrap ${activeTab === 'screeners' ? 'bg-blue-600' : 'bg-gray-800 hover:bg-gray-700'}`}
                            >
                                üîç Scan
                            </button>
                            <button
                                onClick={() => setActiveTab('edge')}
                                className={`flex-1 py-2 px-2 rounded-xl font-semibold transition-colors text-sm whitespace-nowrap ${activeTab === 'edge' ? 'bg-gradient-to-r from-green-600 to-emerald-600' : 'bg-gray-800 hover:bg-gray-700'}`}
                            >
                                ‚ö° Edge
                            </button>
                            <button
                                onClick={() => setActiveTab('watchlist')}
                                className={`flex-1 py-2 px-2 rounded-xl font-semibold transition-colors text-sm whitespace-nowrap ${activeTab === 'watchlist' ? 'bg-gradient-to-r from-yellow-600 to-orange-600' : 'bg-gray-800 hover:bg-gray-700'}`}
                            >
                                ‚≠ê Watch
                            </button>
                            <button
                                onClick={() => setActiveTab('journal')}
                                className={`flex-1 py-2 px-2 rounded-xl font-semibold transition-colors text-sm whitespace-nowrap ${activeTab === 'journal' ? 'bg-blue-600' : 'bg-gray-800 hover:bg-gray-700'}`}
                            >
                                üìì Journal
                            </button>
                        </div>

                        {/* Dashboard Tab - Command Center */}
                        {activeTab === 'dashboard' && (() => {
                            // Calculate today's stats
                            const today = new Date().toDateString();
                            const todayTrades = journalEntries.filter(t => new Date(t.entryDate).toDateString() === today);
                            const todayPnl = todayTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);
                            const todayWins = todayTrades.filter(t => t.pnl > 0).length;
                            const todayLosses = todayTrades.filter(t => t.pnl <= 0).length;
                            const todayWinRate = todayTrades.length > 0 ? (todayWins / todayTrades.length * 100).toFixed(0) : 0;

                            // This week stats
                            const weekAgo = new Date();
                            weekAgo.setDate(weekAgo.getDate() - 7);
                            const weekTrades = journalEntries.filter(t => new Date(t.entryDate) >= weekAgo);
                            const weekPnl = weekTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);

                            // Active alerts count
                            const activeAlertsCount = alerts.filter(a => a.enabled).length;

                            // Open positions from brokerage
                            const openPositionsCount = brokeragePositions.length;
                            const portfolioValue = brokeragePositions.reduce((sum, p) => sum + (p.marketValue || 0), 0);
                            const portfolioPnl = brokeragePositions.reduce((sum, p) => sum + (p.pnl || 0), 0);

                            // Daily trading wisdom (original Zenith tips)
                            const dailyTips = [
                                "Your edge only matters over many trades. One loss doesn't break a winning strategy.",
                                "Uncertainty is not your enemy‚Äîit's the source of opportunity. Embrace it.",
                                "Knowing when NOT to trade is just as valuable as knowing when to enter.",
                                "Position sizing is your first line of defense. Never bet more than you can lose twice.",
                                "The market doesn't care about your P&L. Detach ego from outcomes.",
                                "Every trade is independent. Yesterday's winner doesn't predict today's result.",
                                "Patience isn't passive‚Äîit's the hardest skill to master. Wait for YOUR setup.",
                                "A stopped-out trade followed the plan. That's a win for discipline.",
                                "The midday chop (11am-2pm) eats profits. Sometimes the best trade is no trade.",
                                "Your trading journal isn't homework‚Äîit's your edge over 90% of traders.",
                                "Revenge trading turns one loss into three. Walk away, reset, return fresh.",
                                "Green days are built on red days you survived with discipline.",
                                "The market will always be there tomorrow. Your capital might not be if you overtrade.",
                                "Trust your process. One trade doesn't define you‚Äîyour consistency does.",
                                "Fear of missing out costs more than actually missing out. Let setups come to you."
                            ];
                            const todayTip = dailyTips[new Date().getDate() % dailyTips.length];
                            const allChecked = checklistItems.every(item => item.checked);

                            return (
                                <div className="space-y-4">
                                    {/* Good Morning Header */}
                                    <div className="bg-gradient-to-r from-blue-900/40 to-purple-900/40 rounded-2xl p-4 border border-blue-500/30">
                                        <div className="text-lg font-bold mb-1">
                                            {new Date().getHours() < 12 ? '‚òÄÔ∏è Good Morning' : new Date().getHours() < 17 ? 'üå§Ô∏è Good Afternoon' : 'üåô Good Evening'}, {userName}
                                        </div>
                                        <div className="text-sm text-gray-400">
                                            {new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}
                                        </div>
                                    </div>

                                    {/* Quick Stats Row */}
                                    <div className="grid grid-cols-3 gap-2">
                                        <div className="bg-gray-800/50 rounded-xl p-3 text-center">
                                            <div className="text-2xl font-bold">{openPositionsCount}</div>
                                            <div className="text-xs text-gray-500">Open Positions</div>
                                        </div>
                                        <div className="bg-gray-800/50 rounded-xl p-3 text-center">
                                            <div className="text-2xl font-bold">{activeAlertsCount}</div>
                                            <div className="text-xs text-gray-500">Active Alerts</div>
                                        </div>
                                        <div className={`rounded-xl p-3 text-center ${weekPnl >= 0 ? 'bg-green-900/20' : 'bg-red-900/20'}`}>
                                            <div className={`text-2xl font-bold ${weekPnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                {weekPnl >= 0 ? '+' : ''}${weekPnl.toFixed(0)}
                                            </div>
                                            <div className="text-xs text-gray-500">This Week</div>
                                        </div>
                                    </div>

                                    {/* Portfolio Summary (if connected) */}
                                    {openPositionsCount > 0 && (
                                        <div className="bg-gradient-to-r from-blue-900/40 to-purple-900/40 rounded-xl p-4 border border-blue-500/40">
                                            <div className="flex items-center gap-2 mb-2">
                                                <span className="text-xl">üè¶</span>
                                                <span className="font-bold">Portfolio</span>
                                            </div>
                                            <div className="flex justify-between items-end">
                                                <div>
                                                    <div className="text-3xl font-bold">
                                                        ${portfolioValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                                                    </div>
                                                    <div className="text-xs text-gray-500 mt-1">
                                                        {openPositionsCount} position{openPositionsCount !== 1 ? 's' : ''}
                                                    </div>
                                                </div>
                                                <div className="text-right">
                                                    <div className={`text-xl font-bold ${portfolioPnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                        {portfolioPnl >= 0 ? '+' : ''}${portfolioPnl.toFixed(2)}
                                                    </div>
                                                    <div className="text-xs text-gray-500">Unrealized P&L</div>
                                                </div>
                                            </div>
                                            <button
                                                onClick={() => setActiveTab('positions')}
                                                className="w-full mt-3 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg text-sm transition-colors"
                                            >
                                                View All Positions ‚Üí
                                            </button>
                                        </div>
                                    )}

                                    {/* AI Coach Daily Tip */}
                                    <div className="bg-gradient-to-r from-purple-900/30 to-blue-900/30 rounded-xl p-4 border border-purple-500/30">
                                        <div className="flex items-center gap-2 mb-2">
                                            <span className="text-lg">üìö</span>
                                            <span className="font-bold text-sm">Daily Trading Wisdom</span>
                                        </div>
                                        <div className="text-sm text-gray-300 italic">"{todayTip}"</div>
                                    </div>

                                    {/* Quick Actions */}
                                    <div className="grid grid-cols-2 gap-3">
                                        <button
                                            onClick={() => { setActiveTab('journal'); setShowAddTrade(true); }}
                                            className="py-4 bg-gradient-to-r from-green-600 to-green-700 hover:from-green-500 hover:to-green-600 rounded-xl font-bold transition-all"
                                        >
                                            üìù Log Trade
                                        </button>
                                        <button
                                            onClick={() => setActiveTab('screeners')}
                                            className="py-4 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-500 hover:to-blue-600 rounded-xl font-bold transition-all"
                                        >
                                            üîç Find Setups
                                        </button>
                                    </div>

                                    {/* Recent Trades Today */}
                                    {todayTrades.length > 0 && (
                                        <div className="bg-gray-800/50 rounded-xl p-4">
                                            <div className="font-bold mb-3">Today's Trades</div>
                                            <div className="space-y-2">
                                                {todayTrades.slice(0, 5).map(trade => (
                                                    <div key={trade.id} className="flex justify-between items-center py-2 border-b border-gray-700 last:border-0">
                                                        <div className="flex items-center gap-2">
                                                            <span className="font-semibold">{trade.ticker}</span>
                                                            <span className={`text-xs px-1.5 py-0.5 rounded ${trade.side === 'long' ? 'bg-green-500/20 text-green-400' : 'bg-red-500/20 text-red-400'}`}>
                                                                {trade.side?.toUpperCase()}
                                                            </span>
                                                        </div>
                                                        <div className={`font-semibold ${trade.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                            {trade.pnl >= 0 ? '+' : ''}${trade.pnl?.toFixed(2)}
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                            {todayTrades.length > 5 && (
                                                <button
                                                    onClick={() => setActiveTab('journal')}
                                                    className="w-full mt-2 text-sm text-blue-400 hover:text-blue-300"
                                                >
                                                    View all {todayTrades.length} trades ‚Üí
                                                </button>
                                            )}
                                        </div>
                                    )}

                                    {/* Market Status */}
                                    <div className="bg-gray-800/30 rounded-xl p-3 text-center text-sm">
                                        {(() => {
                                            const now = new Date();
                                            const hour = now.getHours();
                                            const minute = now.getMinutes();
                                            const day = now.getDay();
                                            const isWeekend = day === 0 || day === 6;
                                            const isPreMarket = hour >= 4 && hour < 9 || (hour === 9 && minute < 30);
                                            const isMarketOpen = (hour === 9 && minute >= 30) || (hour > 9 && hour < 16);
                                            const isAfterHours = hour >= 16 && hour < 20;

                                            if (isWeekend) return <span className="text-gray-500">üåô Markets Closed (Weekend)</span>;
                                            if (isPreMarket) return <span className="text-yellow-400">üåÖ Pre-Market (4am-9:30am)</span>;
                                            if (isMarketOpen) return <span className="text-green-400">üü¢ Market Open</span>;
                                            if (isAfterHours) return <span className="text-orange-400">üåÜ After Hours (4pm-8pm)</span>;
                                            return <span className="text-gray-500">üåô Markets Closed</span>;
                                        })()}
                                    </div>
                                </div>
                            );
                        })()}

                        {/* Positions Tab */}
                        {activeTab === 'positions' && (() => {
                            // Calculate today's stats for this tab
                            const today = new Date().toDateString();
                            const todayTrades = journalEntries.filter(t => new Date(t.entryDate).toDateString() === today);
                            const todayPnl = todayTrades.reduce((sum, t) => sum + (t.pnl || 0), 0);
                            const todayWins = todayTrades.filter(t => t.pnl > 0).length;
                            const todayLosses = todayTrades.filter(t => t.pnl <= 0).length;
                            const allChecked = checklistItems.every(item => item.checked);

                            return (
                            <>
                                {/* Pre-Trade Checklist - Compact */}
                                <div className="bg-gradient-to-r from-yellow-900/20 to-orange-900/20 rounded-xl p-3 border border-yellow-500/30 mb-4">
                                    <div className="flex justify-between items-center mb-2">
                                        <div className="font-semibold text-sm">üìã Pre-Trade Checklist</div>
                                        {allChecked && <span className="text-green-400 text-xs">‚úì Ready!</span>}
                                    </div>
                                    <div className="space-y-1">
                                        {checklistItems.map(item => (
                                            <label key={item.id} className="flex items-center gap-2 cursor-pointer group">
                                                <input
                                                    type="checkbox"
                                                    checked={item.checked}
                                                    onChange={() => {
                                                        setChecklistItems(prev => prev.map(i =>
                                                            i.id === item.id ? {...i, checked: !i.checked} : i
                                                        ));
                                                    }}
                                                    className="w-4 h-4 rounded border-gray-600 bg-gray-700 text-green-500 focus:ring-green-500"
                                                />
                                                <span className={`text-xs ${item.checked ? 'text-green-400 line-through' : 'text-gray-300 group-hover:text-white'}`}>
                                                    {item.text}
                                                </span>
                                            </label>
                                        ))}
                                    </div>
                                    {!allChecked && (
                                        <div className="mt-2 text-xs text-yellow-400/70 italic">
                                            ‚ö†Ô∏è Complete before trading
                                        </div>
                                    )}
                                </div>

                                {/* P&L Summary Cards */}
                                <div className="grid grid-cols-2 gap-3 mb-4">
                                    {/* Today's P&L */}
                                    <div className={`rounded-xl p-4 ${todayPnl >= 0 ? 'bg-gradient-to-br from-green-900/30 to-green-800/10 border border-green-500/30' : 'bg-gradient-to-br from-red-900/30 to-red-800/10 border border-red-500/30'}`}>
                                        <div className="text-xs text-gray-400 mb-1">Today's P&L</div>
                                        <div className={`text-2xl font-bold ${todayPnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                            {todayPnl >= 0 ? '+' : ''}${todayPnl.toFixed(2)}
                                        </div>
                                        <div className="text-xs text-gray-500 mt-1">
                                            {todayTrades.length} trade{todayTrades.length !== 1 ? 's' : ''} | {todayWins}W/{todayLosses}L
                                        </div>
                                    </div>
                                    {/* All-Time P&L */}
                                    <div className="bg-gray-800/50 rounded-xl p-4 border border-gray-700">
                                        <div className="text-xs text-gray-400 mb-1">All-Time P&L</div>
                                        <div className={`text-2xl font-bold ${totalPnL >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                            {totalPnL >= 0 ? '+' : ''}{totalPnL.toLocaleString('en-US', { style: 'currency', currency: 'USD' })}
                                        </div>
                                        <div className="text-xs text-gray-500 mt-1">{positions.length} position{positions.length !== 1 ? 's' : ''}</div>
                                    </div>
                                </div>

                                {/* Unified Portfolio Header */}
                                {brokeragePositions.length > 0 && (
                                    <div className="bg-gradient-to-r from-blue-900/30 to-purple-900/30 rounded-xl p-4 mb-4 border border-blue-500/30">
                                        <div className="flex justify-between items-start mb-2">
                                            <div>
                                                <h3 className="text-sm text-gray-400">Unified Portfolio</h3>
                                                <div className="text-2xl font-bold">
                                                    ${brokeragePositions.reduce((sum, p) => sum + (p.marketValue || 0), 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                                                </div>
                                            </div>
                                            <div className="text-right">
                                                <div className={`text-lg font-semibold ${brokeragePositions.reduce((sum, p) => sum + (p.pnl || 0), 0) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                    {brokeragePositions.reduce((sum, p) => sum + (p.pnl || 0), 0) >= 0 ? '+' : ''}
                                                    ${brokeragePositions.reduce((sum, p) => sum + (p.pnl || 0), 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                                                </div>
                                                <div className="text-xs text-gray-500">
                                                    {connectedBrokerages.length} account{connectedBrokerages.length !== 1 ? 's' : ''} connected
                                                </div>
                                            </div>
                                        </div>
                                        <div className="flex gap-1 flex-wrap">
                                            {connectedBrokerages.map(code => {
                                                const brokerage = supportedBrokerages?.find(b => b.shortCode === code);
                                                return (
                                                    <span key={code} className="px-2 py-0.5 text-xs font-bold rounded" style={{ backgroundColor: brokerage?.color || '#888' }}>
                                                        {code}
                                                    </span>
                                                );
                                            })}
                                        </div>
                                        {brokerageSyncTime && (
                                            <div className="text-xs text-gray-500 mt-2">
                                                Last sync: {brokerageSyncTime.toLocaleTimeString()}
                                                <button
                                                    onClick={() => { fetchBrokeragePositions(); }}
                                                    className="ml-2 text-blue-400 hover:underline"
                                                >
                                                    Refresh
                                                </button>
                                            </div>
                                        )}
                                    </div>
                                )}

                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-lg font-semibold">
                                        {brokeragePositions.length > 0 ? 'All Positions' : 'Your Positions'}
                                    </h2>
                                    <button
                                        onClick={() => setShowAddPosition(true)}
                                        className="px-4 py-2 bg-blue-600 hover:bg-blue-500 rounded-xl text-sm font-semibold transition-colors"
                                    >
                                        + Add Manual
                                    </button>
                                </div>

                                {/* Synced Brokerage Positions */}
                                {brokeragePositions.length > 0 && (
                                    <div className="space-y-2 mb-4">
                                        {brokeragePositions.map(pos => (
                                            <div key={pos.id} className="bg-gray-800 rounded-xl p-3 border border-gray-700">
                                                <div className="flex justify-between items-start">
                                                    <div className="flex items-center gap-2">
                                                        <span className="px-1.5 py-0.5 text-[10px] font-bold rounded" style={{ backgroundColor: pos.sourceColor || '#888' }}>
                                                            {pos.source}
                                                        </span>
                                                        <span className="font-bold">{pos.ticker}</span>
                                                        <span className="text-xs text-gray-500">{pos.quantity} shares</span>
                                                    </div>
                                                    <div className="text-right">
                                                        <div className="font-semibold">${pos.marketValue?.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
                                                        <div className={`text-xs ${pos.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                            {pos.pnl >= 0 ? '+' : ''}${pos.pnl?.toFixed(2)} ({pos.pnlPercent?.toFixed(1)}%)
                                                        </div>
                                                    </div>
                                                </div>
                                                <div className="flex justify-between text-xs text-gray-500 mt-1">
                                                    <span>Avg: ${pos.averageCost?.toFixed(2)}</span>
                                                    <span>Current: ${pos.currentPrice?.toFixed(2)}</span>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}

                                {/* Manual Positions */}
                                {positions.length > 0 && brokeragePositions.length > 0 && (
                                    <h3 className="text-sm text-gray-400 mb-2 mt-4">Manual Positions</h3>
                                )}
                                <div className="space-y-3 mb-6">
                                    {positions.map(position => (
                                        <PositionCard
                                            key={position.id}
                                            position={position}
                                            onClick={() => setSelectedPositionDetail(position)}
                                        />
                                    ))}
                                </div>

                                {positions.length === 0 && brokeragePositions.length === 0 && (
                                    <div className="text-center py-12 text-gray-500">
                                        <div className="text-4xl mb-2">üìä</div>
                                        <p>No positions yet</p>
                                        <p className="text-sm">Add a position or connect a brokerage in Settings</p>
                                    </div>
                                )}
                            </>
                            );
                        })()}

                        {/* Screeners Tab */}
                        {activeTab === 'screeners' && (
                            <>
                                {/* Sub-tabs for screeners */}
                                <div className="flex gap-2 mb-4">
                                    <button
                                        onClick={() => setScreenerTab('patterns')}
                                        className={`flex-1 py-2 rounded-lg text-xs font-medium transition-colors ${screenerTab === 'patterns' ? 'bg-purple-600' : 'bg-gray-800 hover:bg-gray-700'}`}
                                    >
                                        üìê Patterns
                                    </button>
                                    <button
                                        onClick={() => setScreenerTab('technical')}
                                        className={`flex-1 py-2 rounded-lg text-xs font-medium transition-colors ${screenerTab === 'technical' ? 'bg-purple-600' : 'bg-gray-800 hover:bg-gray-700'}`}
                                    >
                                        üìä Technical
                                    </button>
                                    <button
                                        onClick={() => setScreenerTab('insider')}
                                        className={`flex-1 py-2 rounded-lg text-xs font-medium transition-colors ${screenerTab === 'insider' ? 'bg-purple-600' : 'bg-gray-800 hover:bg-gray-700'}`}
                                    >
                                        üïµÔ∏è Insider
                                    </button>
                                </div>

                                {/* Chart Patterns Screener */}
                                {screenerTab === 'patterns' && (
                                    <div>
                                        <div className="flex items-center justify-between mb-2">
                                            <h2 className="text-lg font-semibold">üìê Chart Patterns</h2>
                                            <span className="text-xs text-gray-500">{CHART_PATTERNS.length} patterns</span>
                                        </div>

                                        {/* Daily Timeframe Warning */}
                                        <div className="mb-3 px-3 py-2 bg-yellow-900/30 border border-yellow-600/50 rounded-lg">
                                            <div className="flex items-center gap-2 text-yellow-400 text-xs">
                                                <span>‚ö†Ô∏è</span>
                                                <span><strong>DAILY CHART ONLY</strong> ‚Äî Always confirm with your entry timeframe before trading</span>
                                            </div>
                                        </div>

                                        {/* Pattern Category Tabs */}
                                        <div className="flex gap-1 mb-3 overflow-x-auto pb-1">
                                            {[
                                                { id: 'all', label: 'All' },
                                                { id: 'wedge', label: 'Wedges' },
                                                { id: 'channel', label: 'Channels' },
                                                { id: 'reversal', label: 'Reversals' },
                                                { id: 'triangle', label: 'Triangles' },
                                                { id: 'flag', label: 'Flags' },
                                            ].map(cat => (
                                                <button
                                                    key={cat.id}
                                                    onClick={() => setPatternCategory(cat.id)}
                                                    className={`px-3 py-1 rounded-full text-xs font-medium whitespace-nowrap transition-colors ${
                                                        patternCategory === cat.id
                                                            ? 'bg-purple-600 text-white'
                                                            : 'bg-gray-800 text-gray-400 hover:bg-gray-700'
                                                    }`}
                                                >
                                                    {cat.label}
                                                </button>
                                            ))}
                                        </div>

                                        {/* Pattern Selector */}
                                        <div className="mb-4">
                                            <div className="grid grid-cols-2 gap-2 mb-3 max-h-48 overflow-y-auto pr-1">
                                                {(patternCategory === 'all'
                                                    ? getEnabledPatterns()
                                                    : getEnabledPatterns().filter(p => p.category === patternCategory)
                                                ).map(pattern => (
                                                    <button
                                                        key={pattern.id}
                                                        disabled={patternLoading && selectedPattern !== pattern.id}
                                                        onClick={async () => {
                                                            if (patternLoading) return;
                                                            const targetPattern = pattern.id;
                                                            setSelectedPattern(targetPattern);
                                                            setPatternStocks([]);
                                                            setChartStock(null);
                                                            setPatternLoading(true);
                                                            const stocks = await fetchPatternStocks(targetPattern);
                                                            if (stocks !== null) {
                                                                setPatternStocks(stocks);
                                                                setPatternLoading(false);
                                                            }
                                                        }}
                                                        className={`p-2 rounded-lg text-xs font-medium transition-all text-left ${
                                                            selectedPattern === pattern.id
                                                                ? pattern.type === 'bullish'
                                                                    ? 'bg-green-600 border-green-500'
                                                                    : pattern.type === 'bearish'
                                                                        ? 'bg-red-600 border-red-500'
                                                                        : 'bg-yellow-600 border-yellow-500'
                                                                : 'bg-gray-800 border-gray-700 hover:bg-gray-700'
                                                        } border`}
                                                    >
                                                        <div className="flex items-center gap-1">
                                                            <span className="truncate">{pattern.name}</span>
                                                        </div>
                                                        <div className={`text-xs mt-0.5 ${selectedPattern === pattern.id ? 'text-white/70' : 'text-gray-500'}`}>
                                                            {pattern.emoji} {pattern.type === 'bullish' ? 'Bullish' : pattern.type === 'bearish' ? 'Bearish' : 'Neutral'}
                                                        </div>
                                                    </button>
                                                ))}
                                                {/* Empty state when no patterns enabled */}
                                                {(patternCategory === 'all' ? getEnabledPatterns() : getEnabledPatterns().filter(p => p.category === patternCategory)).length === 0 && (
                                                    <div className="col-span-2 text-center py-6 text-gray-500">
                                                        <div className="text-2xl mb-2">üìä</div>
                                                        <p>No patterns enabled{patternCategory !== 'all' ? ' in this category' : ''}</p>
                                                        <button
                                                            onClick={() => setShowSettings(true)}
                                                            className="mt-2 text-purple-400 hover:text-purple-300 text-sm underline"
                                                        >
                                                            Go to Settings to enable patterns
                                                        </button>
                                                    </div>
                                                )}
                                            </div>
                                        </div>

                                        {/* Selected Pattern Info */}
                                        {CHART_PATTERNS.filter(p => p.id === selectedPattern).map(pattern => (
                                            <div key={pattern.id} className={`p-3 rounded-xl text-sm mb-4 ${
                                                pattern.type === 'bullish'
                                                    ? 'bg-green-500/10 border border-green-500/30 text-green-300'
                                                    : pattern.type === 'bearish'
                                                        ? 'bg-red-500/10 border border-red-500/30 text-red-300'
                                                        : 'bg-yellow-500/10 border border-yellow-500/30 text-yellow-300'
                                            }`}>
                                                <div className="font-semibold mb-1">{pattern.name} {pattern.emoji}</div>
                                                <div className="text-xs opacity-80">{pattern.desc}</div>
                                            </div>
                                        ))}

                                        {/* Results */}
                                        {patternLoading ? (
                                            <div className="text-center py-8 text-gray-500">
                                                <div className="text-2xl mb-2 animate-spin">‚è≥</div>
                                                Scanning for {CHART_PATTERNS.find(p => p.id === selectedPattern)?.name}...
                                            </div>
                                        ) : patternStocks.length > 0 && !patternStocks[0]?.error ? (
                                            <div className="space-y-2">
                                                {/* Chart Display */}
                                                {chartStock && (
                                                    <div className="mb-4 p-3 bg-gray-800 border border-blue-500 rounded-xl">
                                                        <div className="flex justify-between items-center mb-2">
                                                            <div className="flex items-center gap-2">
                                                                <span className="font-bold text-xl">${chartStock.ticker}</span>
                                                                <span className={`px-2 py-0.5 rounded text-xs font-semibold ${
                                                                    CHART_PATTERNS.find(p => p.id === selectedPattern)?.type === 'bullish'
                                                                        ? 'bg-green-500/20 text-green-400'
                                                                        : CHART_PATTERNS.find(p => p.id === selectedPattern)?.type === 'bearish'
                                                                            ? 'bg-red-500/20 text-red-400'
                                                                            : 'bg-yellow-500/20 text-yellow-400'
                                                                }`}>
                                                                    {CHART_PATTERNS.find(p => p.id === selectedPattern)?.emoji} {CHART_PATTERNS.find(p => p.id === selectedPattern)?.name}
                                                                </span>
                                                            </div>
                                                            <button
                                                                onClick={() => setChartStock(null)}
                                                                className="text-gray-400 hover:text-white text-xl"
                                                            >
                                                                ‚úï
                                                            </button>
                                                        </div>
                                                        <div className="text-sm text-gray-400 mb-2">{chartStock.company}</div>
                                                        <img
                                                            src={`https://finviz.com/chart.ashx?t=${chartStock.ticker}&ty=c&ta=1&p=d&s=l`}
                                                            alt={`${chartStock.ticker} chart`}
                                                            className="w-full rounded-lg border border-gray-700"
                                                            onError={(e) => {
                                                                e.target.style.display = 'none';
                                                                e.target.nextSibling.style.display = 'block';
                                                            }}
                                                        />
                                                        <div className="hidden text-center py-4 text-gray-500">
                                                            Chart unavailable - <a href={`https://finviz.com/quote.ashx?t=${chartStock.ticker}`} target="_blank" className="text-blue-400 underline">View on Finviz</a>
                                                        </div>
                                                        <div className="mt-2 p-2 bg-gray-700/50 rounded text-xs text-gray-300">
                                                            <span className="font-semibold">Pattern:</span> {CHART_PATTERNS.find(p => p.id === selectedPattern)?.desc}
                                                        </div>
                                                        <a
                                                            href={`https://finviz.com/quote.ashx?t=${chartStock.ticker}`}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            className="mt-2 block text-center text-xs text-blue-400 hover:underline"
                                                        >
                                                            Open full analysis on Finviz ‚Üí
                                                        </a>
                                                    </div>
                                                )}

                                                <div className="text-xs text-gray-400 mb-2">
                                                    Found <span className="text-white font-semibold">{patternStocks.length}</span> stocks matching pattern
                                                    <span className="text-gray-500 ml-2">‚Ä¢ Click to view chart</span>
                                                </div>
                                                {patternStocks.map((stock) => (
                                                    <button
                                                        key={stock.ticker}
                                                        onClick={() => setChartStock(stock)}
                                                        className={`block w-full text-left p-3 bg-gray-800 border rounded-xl hover:border-blue-500 transition-all cursor-pointer ${
                                                            chartStock?.ticker === stock.ticker ? 'border-blue-500' : 'border-gray-700'
                                                        }`}
                                                    >
                                                        <div className="flex justify-between items-start mb-1">
                                                            <div>
                                                                <span className="font-bold text-lg">${stock.ticker}</span>
                                                                <span className="text-gray-500 text-sm ml-2">{stock.price}</span>
                                                            </div>
                                                            <span className={`font-semibold ${stock.changeNum >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                                {stock.change}
                                                            </span>
                                                        </div>
                                                        <div className="text-sm text-gray-400">{stock.company}</div>
                                                        <div className="flex justify-between text-xs text-gray-500 mt-1">
                                                            <span>{stock.sector}</span>
                                                            <span>Cap: {stock.marketCap}</span>
                                                        </div>
                                                    </button>
                                                ))}
                                            </div>
                                        ) : (
                                            <div className="text-center py-6 text-gray-500">
                                                <div className="text-2xl mb-2">üëÜ</div>
                                                <p>Select a pattern to scan for matching stocks</p>
                                            </div>
                                        )}

                                        <div className="mt-4 p-3 bg-gray-800 border border-gray-700 rounded-xl text-xs text-gray-400">
                                            <div className="font-semibold text-gray-300 mb-1">üéØ Quality Filters:</div>
                                            <div>Market Cap &gt;$300M ‚Ä¢ Avg Volume &gt;200K ‚Ä¢ Price &gt;$5</div>
                                        </div>
                                    </div>
                                )}

                                {/* Technical Indicators Screener */}
                                {screenerTab === 'technical' && (
                                    <div>
                                        <div className="flex items-center justify-between mb-2">
                                            <h2 className="text-lg font-semibold">üìä Technical Screener</h2>
                                            <span className="text-xs text-gray-500">100+ stocks scanned</span>
                                        </div>

                                        {/* Info Banner */}
                                        <div className="mb-3 px-3 py-2 bg-blue-900/30 border border-blue-600/50 rounded-lg">
                                            <div className="flex items-center gap-2 text-blue-400 text-xs">
                                                <span>üí°</span>
                                                <span>Scans major stocks for RSI, Moving Averages, and Cross signals</span>
                                            </div>
                                        </div>

                                        {/* Screener Type Selector */}
                                        <div className="grid grid-cols-2 gap-2 mb-4">
                                            {TECHNICAL_SCREENERS.map(screen => (
                                                <button
                                                    key={screen.id}
                                                    onClick={async () => {
                                                        setTechnicalScreenType(screen.id);
                                                        setTechnicalLoading(true);
                                                        const results = await fetchTechnicalScreener(screen.id);
                                                        setTechnicalStocks(results);
                                                        setTechnicalLoading(false);
                                                    }}
                                                    className={`p-3 rounded-xl text-left transition-all ${
                                                        technicalScreenType === screen.id
                                                            ? screen.type === 'bullish' ? 'bg-green-600/30 border-2 border-green-500'
                                                            : screen.type === 'bearish' ? 'bg-red-600/30 border-2 border-red-500'
                                                            : 'bg-purple-600/30 border-2 border-purple-500'
                                                            : 'bg-gray-800 hover:bg-gray-700 border-2 border-transparent'
                                                    }`}
                                                >
                                                    <div className="flex items-center gap-2 font-medium text-sm">
                                                        <span>{screen.emoji}</span>
                                                        <span>{screen.name}</span>
                                                    </div>
                                                    <div className="text-xs text-gray-400 mt-1">{screen.desc}</div>
                                                </button>
                                            ))}
                                        </div>

                                        {/* Results */}
                                        <div className="space-y-2">
                                            {technicalLoading ? (
                                                <div className="text-center py-8">
                                                    <div className="text-4xl mb-2 animate-pulse">üìä</div>
                                                    <div className="text-gray-400">Scanning stocks...</div>
                                                    <div className="text-xs text-gray-500 mt-1">This may take 10-20 seconds</div>
                                                </div>
                                            ) : technicalStocks.length === 0 ? (
                                                <div className="text-center py-8 text-gray-500">
                                                    <p className="text-2xl mb-2">üëÜ</p>
                                                    <p>Select a screener above to scan</p>
                                                </div>
                                            ) : (technicalScreenType === 'sma_200_super' || technicalScreenType === 'sma_super') ? (
                                                /* Super 200 SMA Scanner - Categorized View */
                                                <>
                                                    <div className="text-sm text-gray-400 mb-3">
                                                        Scanned {technicalStocks.length} stocks ‚Ä¢ Categorized by 200 SMA position
                                                    </div>

                                                    {/* 200 SMA Section */}
                                                    <div className="mb-2 text-xs font-bold text-purple-400 uppercase tracking-wide">200 SMA</div>

                                                    {/* ON the 200 SMA */}
                                                    {(() => {
                                                        const touching = technicalStocks.filter(s => s.signal === 'ON 200 SMA');
                                                        if (touching.length === 0) return null;
                                                        return (
                                                            <div className="mb-3">
                                                                <div className="text-sm font-semibold text-yellow-400 mb-2">üéØ ON 200 SMA ({touching.length})</div>
                                                                <div className="grid grid-cols-3 gap-2">
                                                                    {touching.map(stock => (
                                                                        <div key={stock.ticker} onClick={() => setChartStock({ ticker: stock.ticker, name: stock.ticker })} className="p-2 bg-yellow-900/20 border border-yellow-500/30 rounded-lg cursor-pointer hover:bg-yellow-900/30 text-center">
                                                                            <div className="font-bold text-sm">{stock.ticker}</div>
                                                                            <div className="text-xs text-yellow-400">{stock.value}</div>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        );
                                                    })()}

                                                    {/* Near 200 SMA Above/Below */}
                                                    <div className="grid grid-cols-2 gap-3 mb-4">
                                                        {(() => {
                                                            const nearAbove = technicalStocks.filter(s => s.signal === '200 SMA Near Above');
                                                            if (nearAbove.length === 0) return null;
                                                            return (
                                                                <div>
                                                                    <div className="text-xs font-semibold text-green-400 mb-1">üìà Near Above ({nearAbove.length})</div>
                                                                    <div className="space-y-1">
                                                                        {nearAbove.map(stock => (
                                                                            <div key={stock.ticker} onClick={() => setChartStock({ ticker: stock.ticker, name: stock.ticker })} className="p-1.5 bg-green-900/20 border border-green-500/30 rounded cursor-pointer hover:bg-green-900/30 flex justify-between text-xs">
                                                                                <span className="font-bold">{stock.ticker}</span>
                                                                                <span className="text-green-400">{stock.value}</span>
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            );
                                                        })()}
                                                        {(() => {
                                                            const nearBelow = technicalStocks.filter(s => s.signal === '200 SMA Near Below');
                                                            if (nearBelow.length === 0) return null;
                                                            return (
                                                                <div>
                                                                    <div className="text-xs font-semibold text-red-400 mb-1">üìâ Near Below ({nearBelow.length})</div>
                                                                    <div className="space-y-1">
                                                                        {nearBelow.map(stock => (
                                                                            <div key={stock.ticker} onClick={() => setChartStock({ ticker: stock.ticker, name: stock.ticker })} className="p-1.5 bg-red-900/20 border border-red-500/30 rounded cursor-pointer hover:bg-red-900/30 flex justify-between text-xs">
                                                                                <span className="font-bold">{stock.ticker}</span>
                                                                                <span className="text-red-400">{stock.value}</span>
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            );
                                                        })()}
                                                    </div>

                                                    {/* 50 SMA Section */}
                                                    <div className="mb-2 text-xs font-bold text-blue-400 uppercase tracking-wide border-t border-gray-700 pt-3">50 SMA</div>

                                                    {/* ON the 50 SMA */}
                                                    {(() => {
                                                        const touching50 = technicalStocks.filter(s => s.signal === 'ON 50 SMA');
                                                        if (touching50.length === 0) return null;
                                                        return (
                                                            <div className="mb-3">
                                                                <div className="text-sm font-semibold text-cyan-400 mb-2">üéØ ON 50 SMA ({touching50.length})</div>
                                                                <div className="grid grid-cols-3 gap-2">
                                                                    {touching50.map(stock => (
                                                                        <div key={stock.ticker} onClick={() => setChartStock({ ticker: stock.ticker, name: stock.ticker })} className="p-2 bg-cyan-900/20 border border-cyan-500/30 rounded-lg cursor-pointer hover:bg-cyan-900/30 text-center">
                                                                            <div className="font-bold text-sm">{stock.ticker}</div>
                                                                            <div className="text-xs text-cyan-400">{stock.value}</div>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        );
                                                    })()}

                                                    {/* Near 50 SMA Above/Below */}
                                                    <div className="grid grid-cols-2 gap-3">
                                                        {(() => {
                                                            const near50Above = technicalStocks.filter(s => s.signal === '50 SMA Near Above');
                                                            if (near50Above.length === 0) return null;
                                                            return (
                                                                <div>
                                                                    <div className="text-xs font-semibold text-green-400 mb-1">üìà Near Above ({near50Above.length})</div>
                                                                    <div className="space-y-1">
                                                                        {near50Above.map(stock => (
                                                                            <div key={stock.ticker} onClick={() => setChartStock({ ticker: stock.ticker, name: stock.ticker })} className="p-1.5 bg-green-900/20 border border-green-500/30 rounded cursor-pointer hover:bg-green-900/30 flex justify-between text-xs">
                                                                                <span className="font-bold">{stock.ticker}</span>
                                                                                <span className="text-green-400">{stock.value}</span>
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            );
                                                        })()}
                                                        {(() => {
                                                            const near50Below = technicalStocks.filter(s => s.signal === '50 SMA Near Below');
                                                            if (near50Below.length === 0) return null;
                                                            return (
                                                                <div>
                                                                    <div className="text-xs font-semibold text-red-400 mb-1">üìâ Near Below ({near50Below.length})</div>
                                                                    <div className="space-y-1">
                                                                        {near50Below.map(stock => (
                                                                            <div key={stock.ticker} onClick={() => setChartStock({ ticker: stock.ticker, name: stock.ticker })} className="p-1.5 bg-red-900/20 border border-red-500/30 rounded cursor-pointer hover:bg-red-900/30 flex justify-between text-xs">
                                                                                <span className="font-bold">{stock.ticker}</span>
                                                                                <span className="text-red-400">{stock.value}</span>
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            );
                                                        })()}
                                                    </div>
                                                </>
                                            ) : (
                                                /* Standard Screener View */
                                                <>
                                                    <div className="text-sm text-gray-400 mb-2">
                                                        Found {technicalStocks.length} stocks matching "{TECHNICAL_SCREENERS.find(s => s.id === technicalScreenType)?.name}"
                                                    </div>
                                                    {technicalStocks.map((stock, i) => (
                                                        <div
                                                            key={stock.ticker}
                                                            onClick={() => setChartStock({ ticker: stock.ticker, name: stock.ticker })}
                                                            className="p-3 bg-gray-800 rounded-xl hover:bg-gray-700 cursor-pointer transition-colors"
                                                        >
                                                            <div className="flex justify-between items-center">
                                                                <div>
                                                                    <div className="font-bold text-lg">{stock.ticker}</div>
                                                                    <div className="text-sm text-gray-400">{stock.signal}</div>
                                                                </div>
                                                                <div className="text-right">
                                                                    <div className="font-semibold">${stock.price}</div>
                                                                    <div className={`text-sm ${
                                                                        TECHNICAL_SCREENERS.find(s => s.id === technicalScreenType)?.type === 'bullish' ? 'text-green-400'
                                                                        : TECHNICAL_SCREENERS.find(s => s.id === technicalScreenType)?.type === 'bearish' ? 'text-red-400'
                                                                        : 'text-yellow-400'
                                                                    }`}>
                                                                        {stock.value}
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            {stock.rsi && (
                                                                <div className="mt-2 text-xs text-gray-500">
                                                                    RSI: {stock.rsi} | 50 SMA: {stock.sma50Dist}% | 200 SMA: {stock.sma200Dist}%
                                                                </div>
                                                            )}
                                                        </div>
                                                    ))}
                                                </>
                                            )}
                                        </div>
                                    </div>
                                )}

                                {/* Insider Trading Screener */}
                                {screenerTab === 'insider' && (
                                    <div>
                                        <div className="flex items-center justify-between mb-3">
                                            <h2 className="text-lg font-semibold">üïµÔ∏è Insider Buys (Last 7 Days)</h2>
                                            <span className="text-xs text-gray-500">via SEC Form 4</span>
                                        </div>

                                        <div className="p-3 bg-green-500/10 border border-green-500/30 rounded-xl text-sm text-green-300 mb-4">
                                            üí° Insiders buying = They know something. Large cluster buys are especially bullish.
                                        </div>

                                        {loading ? (
                                            <div className="text-center py-8 text-gray-500">
                                                <div className="text-2xl mb-2">‚è≥</div>
                                                Loading insider data from SEC filings...
                                            </div>
                                        ) : insiderTrades.length > 0 ? (
                                            <div className="space-y-2">
                                                {insiderTrades.map((trade, i) => (
                                                    <div
                                                        key={i}
                                                        onClick={() => setChartStock({ ticker: trade.ticker, name: trade.company })}
                                                        className={`p-3 rounded-xl border transition-all hover:scale-[1.01] cursor-pointer ${
                                                            trade.valueNum >= 1000000 ? 'bg-green-900/30 border-green-500/50 hover:bg-green-900/40' :
                                                            trade.valueNum >= 500000 ? 'bg-yellow-900/20 border-yellow-500/30 hover:bg-yellow-900/30' :
                                                            'bg-gray-800 border-gray-700 hover:bg-gray-700'
                                                        }`}
                                                    >
                                                        <div className="flex justify-between items-start mb-1">
                                                            <div className="flex items-center gap-2">
                                                                <span className="font-bold text-lg">${trade.ticker}</span>
                                                                {trade.valueNum >= 1000000 && <span className="text-xs px-2 py-0.5 bg-green-500/30 rounded-full text-green-300">üêã WHALE</span>}
                                                                {trade.valueNum >= 500000 && trade.valueNum < 1000000 && <span className="text-xs px-2 py-0.5 bg-yellow-500/30 rounded-full text-yellow-300">üí∞ BIG</span>}
                                                            </div>
                                                            <span className="text-green-400 font-bold">{trade.value}</span>
                                                        </div>
                                                        <div className="text-sm text-gray-400 mb-1">{trade.company}</div>
                                                        <div className="flex justify-between text-xs text-gray-500">
                                                            <span>{trade.insiderName} ({trade.title})</span>
                                                            <span>{trade.filingDate}</span>
                                                        </div>
                                                        <div className="text-xs text-gray-500 mt-1">
                                                            {trade.qty} shares @ {trade.price}
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        ) : (
                                            <div className="text-center py-8 text-gray-500">
                                                <div className="text-2xl mb-2">üîç</div>
                                                No insider buys found. Check back later.
                                            </div>
                                        )}
                                    </div>
                                )}
                            </>
                        )}

                        {/* Hot Stocks Tab - Aggregated from all sources */}
                        {activeTab === 'trending' && (
                            <>
                                <div className="mb-4">
                                    <div className="flex items-center justify-between mb-3">
                                        <h2 className="text-lg font-semibold">üî• Hot Stocks</h2>
                                        <span className="text-xs text-gray-500">10 sources</span>
                                    </div>

                                    <div className="p-3 bg-purple-500/10 border border-purple-500/30 rounded-xl text-xs text-purple-300 mb-4">
                                        üìä Reddit ‚Ä¢ Yahoo ‚Ä¢ Stocktwits ‚Ä¢ Finviz ‚Ä¢ MarketWatch ‚Ä¢ CNBC ‚Ä¢ SeekingAlpha ‚Ä¢ MotleyFool ‚Ä¢ Bloomberg
                                    </div>

                                    {loading ? (
                                        <div className="text-center py-8 text-gray-500">
                                            <div className="text-2xl mb-2">‚è≥</div>
                                            Scanning all sources...
                                        </div>
                                    ) : trending.trending.length > 0 ? (
                                        <>
                                            {/* Hot stocks list */}
                                            <div className="space-y-2 mb-6">
                                                {trending.trending.slice(0, 20).map((item, i) => (
                                                    <div
                                                        key={item.ticker}
                                                        onClick={() => setChartStock({ ticker: item.ticker, name: item.ticker })}
                                                        className={`p-3 rounded-xl border transition-all cursor-pointer hover:scale-[1.02] ${
                                                            item.heat === 'extreme' ? 'bg-red-500/20 border-red-500/50 hover:bg-red-500/30' :
                                                            item.heat === 'high' ? 'bg-orange-500/20 border-orange-500/50 hover:bg-orange-500/30' :
                                                            item.heat === 'medium' ? 'bg-yellow-500/10 border-yellow-500/30 hover:bg-yellow-500/20' :
                                                            'bg-gray-800 border-gray-700 hover:bg-gray-700'
                                                        }`}
                                                    >
                                                        <div className="flex justify-between items-center mb-2">
                                                            <div className="flex items-center gap-2">
                                                                <span className="text-gray-500 text-sm w-6">#{i + 1}</span>
                                                                <span className="font-bold text-lg">${item.ticker}</span>
                                                                {item.heat === 'extreme' && <span className="text-xs px-2 py-0.5 bg-red-500/30 rounded-full text-red-300 animate-pulse">üî• EVERYWHERE</span>}
                                                                {item.heat === 'high' && <span className="text-xs px-2 py-0.5 bg-orange-500/30 rounded-full text-orange-300">üî• HOT</span>}
                                                                {item.heat === 'medium' && <span className="text-xs px-2 py-0.5 bg-yellow-500/30 rounded-full text-yellow-300">üìà BUZZING</span>}
                                                            </div>
                                                            <span className="text-xs text-gray-400">{item.sourceCount} sources</span>
                                                        </div>
                                                        <div className="flex flex-wrap gap-1" onClick={(e) => e.stopPropagation()}>
                                                            {item.sources.map(src => {
                                                                const sourceUrls = {
                                                                    'Yahoo': `https://finance.yahoo.com/quote/${item.ticker}`,
                                                                    'Stocktwits': `https://stocktwits.com/symbol/${item.ticker}`,
                                                                    'Finviz': `https://finviz.com/quote.ashx?t=${item.ticker}`,
                                                                    'MarketWatch': `https://www.marketwatch.com/investing/stock/${item.ticker.toLowerCase()}`,
                                                                    'CNBC': `https://www.cnbc.com/quotes/${item.ticker}`,
                                                                    'SeekingAlpha': `https://seekingalpha.com/symbol/${item.ticker}`,
                                                                    'MotleyFool': `https://www.fool.com/quote/${item.ticker.toLowerCase()}`,
                                                                    'Bloomberg': `https://www.bloomberg.com/quote/${item.ticker}:US`,
                                                                    'Reddit': `https://www.reddit.com/search/?q=${item.ticker}&type=link`
                                                                };
                                                                return (
                                                                    <a
                                                                        key={src}
                                                                        href={sourceUrls[src] || '#'}
                                                                        target="_blank"
                                                                        rel="noopener noreferrer"
                                                                        className={`text-xs px-2 py-0.5 rounded-full hover:opacity-80 transition-opacity ${
                                                                            src === 'Yahoo' ? 'bg-purple-500/30 text-purple-300' :
                                                                            src === 'Stocktwits' ? 'bg-blue-500/30 text-blue-300' :
                                                                            src === 'Finviz' ? 'bg-green-500/30 text-green-300' :
                                                                            src === 'MarketWatch' ? 'bg-teal-500/30 text-teal-300' :
                                                                            src === 'CNBC' ? 'bg-yellow-500/30 text-yellow-300' :
                                                                            src === 'SeekingAlpha' ? 'bg-emerald-500/30 text-emerald-300' :
                                                                            src === 'MotleyFool' ? 'bg-indigo-500/30 text-indigo-300' :
                                                                            src === 'Bloomberg' ? 'bg-sky-500/30 text-sky-300' :
                                                                            'bg-orange-500/30 text-orange-300'
                                                                        }`}
                                                                    >
                                                                        {src}
                                                                    </a>
                                                                );
                                                            })}
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>

                                            {/* Hot posts from Reddit */}
                                            {trending.posts.length > 0 && (
                                                <div className="mb-4">
                                                    <h3 className="text-sm font-semibold text-gray-400 mb-2">üì∞ Hot Reddit Posts</h3>
                                                    <div className="space-y-2">
                                                        {trending.posts.slice(0, 8).map((post, i) => (
                                                            <a
                                                                key={i}
                                                                href={post.url}
                                                                target="_blank"
                                                                rel="noopener noreferrer"
                                                                className="block p-3 bg-gray-800 hover:bg-gray-700 border border-gray-700 rounded-xl transition-colors"
                                                            >
                                                                <div className="flex items-start justify-between gap-2">
                                                                    <div className="text-sm flex-1">{post.title}</div>
                                                                    <span className={`text-xs px-2 py-0.5 rounded-full whitespace-nowrap ${
                                                                        post.category === 'meme' ? 'bg-purple-500/30 text-purple-300' :
                                                                        post.category === 'penny' ? 'bg-orange-500/30 text-orange-300' :
                                                                        'bg-blue-500/30 text-blue-300'
                                                                    }`}>
                                                                        r/{post.subreddit}
                                                                    </span>
                                                                </div>
                                                                <div className="text-xs text-gray-500 mt-1">‚¨ÜÔ∏è {post.score.toLocaleString()}</div>
                                                            </a>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                        </>
                                    ) : (
                                        <div className="text-center py-8 text-gray-500">
                                            <div className="text-2xl mb-2">üì°</div>
                                            No data available
                                        </div>
                                    )}
                                </div>

                                <div className="p-3 bg-yellow-500/10 border border-yellow-500/30 rounded-xl text-xs text-yellow-300">
                                    ‚ö†Ô∏è High buzz = everyone's talking. You might be late. Stocks appearing on 3+ sources are getting maximum attention.
                                </div>
                            </>
                        )}

                        {/* Market Edge Tab - Edgeful-style features */}
                        {activeTab === 'edge' && (
                            <MarketEdgeTab />
                        )}

                        {/* Journal Tab */}
                        {activeTab === 'journal' && (
                            <>
                                {/* Journal Header with Stats Summary */}
                                <div className="flex justify-between items-center mb-4">
                                    <div>
                                        <h2 className="text-lg font-semibold">Trade Journal</h2>
                                        <p className="text-xs text-gray-500">
                                            {journalEntries.length} trades ‚Ä¢ {journalStats.winRate.toFixed(0)}% win rate
                                        </p>
                                    </div>
                                    <div className="flex gap-2">
                                        <button
                                            onClick={() => setShowCoach(true)}
                                            className="px-4 py-2 bg-purple-600 hover:bg-purple-500 rounded-xl text-sm font-semibold transition-colors"
                                        >
                                            AI Coach
                                        </button>
                                        <button
                                            onClick={() => setShowAddTrade(true)}
                                            className="px-4 py-2 bg-green-600 hover:bg-green-500 rounded-xl text-sm font-semibold transition-colors"
                                        >
                                            + Log Trade
                                        </button>
                                    </div>
                                </div>

                                {/* Journal View Tabs */}
                                <div className="flex gap-2 mb-4">
                                    <button
                                        onClick={() => setJournalView('list')}
                                        className={`flex-1 py-2 rounded-lg text-sm font-medium transition-colors ${journalView === 'list' ? 'bg-gray-700' : 'bg-gray-800/50 hover:bg-gray-700/50'}`}
                                    >
                                        üìã Trades
                                    </button>
                                    <button
                                        onClick={() => setJournalView('stats')}
                                        className={`flex-1 py-2 rounded-lg text-sm font-medium transition-colors ${journalView === 'stats' ? 'bg-gray-700' : 'bg-gray-800/50 hover:bg-gray-700/50'}`}
                                    >
                                        üìä Stats
                                    </button>
                                    <button
                                        onClick={() => setJournalView('calendar')}
                                        className={`flex-1 py-2 rounded-lg text-sm font-medium transition-colors ${journalView === 'calendar' ? 'bg-gray-700' : 'bg-gray-800/50 hover:bg-gray-700/50'}`}
                                    >
                                        üìÖ Calendar
                                    </button>
                                </div>

                                {/* Stats View */}
                                {journalView === 'stats' && (
                                    <div className="space-y-4">
                                        {/* Main Stats Grid */}
                                        <div className="grid grid-cols-2 gap-3">
                                            <div className="bg-gray-800/50 p-4 rounded-xl border border-gray-700">
                                                <div className="text-xs text-gray-500 mb-1">Total P&L</div>
                                                <div className={`text-2xl font-bold ${journalStats.totalPnL >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                    {journalStats.totalPnL >= 0 ? '+' : ''}${journalStats.totalPnL.toFixed(2)}
                                                </div>
                                            </div>
                                            <div className="bg-gray-800/50 p-4 rounded-xl border border-gray-700">
                                                <div className="text-xs text-gray-500 mb-1">Win Rate</div>
                                                <div className={`text-2xl font-bold ${journalStats.winRate >= 50 ? 'text-green-400' : 'text-red-400'}`}>
                                                    {journalStats.winRate.toFixed(1)}%
                                                </div>
                                            </div>
                                            <div className="bg-gray-800/50 p-4 rounded-xl border border-gray-700">
                                                <div className="text-xs text-gray-500 mb-1">Profit Factor</div>
                                                <div className={`text-2xl font-bold ${journalStats.profitFactor >= 1 ? 'text-green-400' : 'text-red-400'}`}>
                                                    {journalStats.profitFactor === Infinity ? '‚àû' : journalStats.profitFactor.toFixed(2)}
                                                </div>
                                            </div>
                                            <div className="bg-gray-800/50 p-4 rounded-xl border border-gray-700">
                                                <div className="text-xs text-gray-500 mb-1">Avg R-Multiple</div>
                                                <div className={`text-2xl font-bold ${journalStats.avgRMultiple >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                    {journalStats.avgRMultiple.toFixed(2)}R
                                                </div>
                                            </div>
                                        </div>

                                        {/* Win/Loss Breakdown */}
                                        <div className="bg-gray-800/50 p-4 rounded-xl border border-gray-700">
                                            <div className="text-sm font-semibold mb-3">Win/Loss Breakdown</div>
                                            <div className="flex justify-between items-center mb-2">
                                                <span className="text-green-400">Wins: {journalStats.wins}</span>
                                                <span className="text-red-400">Losses: {journalStats.losses}</span>
                                            </div>
                                            <div className="w-full bg-gray-700 rounded-full h-3">
                                                <div
                                                    className="bg-green-500 h-3 rounded-full"
                                                    style={{ width: `${journalStats.totalTrades > 0 ? (journalStats.wins / journalStats.totalTrades) * 100 : 0}%` }}
                                                />
                                            </div>
                                            <div className="grid grid-cols-2 gap-4 mt-4 text-sm">
                                                <div>
                                                    <span className="text-gray-500">Avg Win:</span>
                                                    <span className="text-green-400 ml-2">+${journalStats.avgWin.toFixed(2)}</span>
                                                </div>
                                                <div>
                                                    <span className="text-gray-500">Avg Loss:</span>
                                                    <span className="text-red-400 ml-2">-${journalStats.avgLoss.toFixed(2)}</span>
                                                </div>
                                                <div>
                                                    <span className="text-gray-500">Largest Win:</span>
                                                    <span className="text-green-400 ml-2">+${journalStats.largestWin.toFixed(2)}</span>
                                                </div>
                                                <div>
                                                    <span className="text-gray-500">Largest Loss:</span>
                                                    <span className="text-red-400 ml-2">${journalStats.largestLoss.toFixed(2)}</span>
                                                </div>
                                            </div>
                                        </div>

                                        {/* Current Streak */}
                                        <div className="bg-gray-800/50 p-4 rounded-xl border border-gray-700">
                                            <div className="text-sm font-semibold mb-2">Current Streak</div>
                                            <div className={`text-xl font-bold ${journalStats.streakType === 'win' ? 'text-green-400' : journalStats.streakType === 'loss' ? 'text-red-400' : 'text-gray-400'}`}>
                                                {journalStats.currentStreak > 0 ? (
                                                    <>
                                                        {journalStats.streakType === 'win' ? 'üî•' : '‚ùÑÔ∏è'} {journalStats.currentStreak} {journalStats.streakType === 'win' ? 'Wins' : 'Losses'}
                                                    </>
                                                ) : (
                                                    'No streak'
                                                )}
                                            </div>
                                        </div>

                                        {/* Setup Performance */}
                                        {Object.keys(journalStats.setupStats).length > 0 && (
                                            <div className="bg-gray-800/50 p-4 rounded-xl border border-gray-700">
                                                <div className="text-sm font-semibold mb-3">Setup Performance</div>
                                                <div className="space-y-2">
                                                    {Object.entries(journalStats.setupStats)
                                                        .sort((a, b) => b[1].pnl - a[1].pnl)
                                                        .slice(0, 5)
                                                        .map(([setup, stats]) => {
                                                            const setupInfo = SETUP_TYPES.find(s => s.id === setup);
                                                            const winRate = stats.trades > 0 ? (stats.wins / stats.trades) * 100 : 0;
                                                            return (
                                                                <div key={setup} className="flex justify-between items-center text-sm">
                                                                    <span>{setupInfo?.emoji} {setupInfo?.label || setup}</span>
                                                                    <div className="flex items-center gap-3">
                                                                        <span className="text-gray-500">{stats.trades} trades</span>
                                                                        <span className={winRate >= 50 ? 'text-green-400' : 'text-red-400'}>{winRate.toFixed(0)}%</span>
                                                                        <span className={stats.pnl >= 0 ? 'text-green-400' : 'text-red-400'}>
                                                                            {stats.pnl >= 0 ? '+' : ''}${stats.pnl.toFixed(0)}
                                                                        </span>
                                                                    </div>
                                                                </div>
                                                            );
                                                        })}
                                                </div>
                                            </div>
                                        )}

                                        {/* Mistake Analysis */}
                                        {Object.keys(journalStats.mistakeStats).length > 0 && !journalStats.mistakeStats.none && (
                                            <div className="bg-gray-800/50 p-4 rounded-xl border border-red-500/30">
                                                <div className="text-sm font-semibold mb-3 text-red-400">üíÄ Costly Mistakes</div>
                                                <div className="space-y-2">
                                                    {Object.entries(journalStats.mistakeStats)
                                                        .filter(([m]) => m !== 'none')
                                                        .sort((a, b) => b[1].totalLoss - a[1].totalLoss)
                                                        .slice(0, 5)
                                                        .map(([mistake, stats]) => {
                                                            const mistakeInfo = MISTAKE_TYPES.find(m => m.id === mistake);
                                                            return (
                                                                <div key={mistake} className="flex justify-between items-center text-sm">
                                                                    <span>{mistakeInfo?.emoji} {mistakeInfo?.label || mistake}</span>
                                                                    <div className="flex items-center gap-3">
                                                                        <span className="text-gray-500">{stats.count}x</span>
                                                                        <span className="text-red-400">-${stats.totalLoss.toFixed(0)}</span>
                                                                    </div>
                                                                </div>
                                                            );
                                                        })}
                                                </div>
                                            </div>
                                        )}

                                        {journalEntries.length === 0 && (
                                            <div className="text-center py-8 text-gray-500">
                                                <p className="text-4xl mb-2">üìä</p>
                                                <p>No trades logged yet</p>
                                                <p className="text-sm">Log some trades to see your stats</p>
                                            </div>
                                        )}
                                    </div>
                                )}

                                {/* List View */}
                                {journalView === 'list' && (
                                    <div className="space-y-3">
                                        {journalEntries.length === 0 ? (
                                            <div className="text-center py-12 text-gray-500">
                                                <p className="text-5xl mb-3">üìì</p>
                                                <p className="font-semibold">Your Trade Journal</p>
                                                <p className="text-sm mt-2">Log your trades to track performance,<br/>identify patterns, and improve.</p>
                                                <button
                                                    onClick={() => setShowAddTrade(true)}
                                                    className="mt-4 px-6 py-2 bg-green-600 hover:bg-green-500 rounded-xl text-sm font-semibold"
                                                >
                                                    Log Your First Trade
                                                </button>
                                            </div>
                                        ) : (
                                            [...journalEntries]
                                                .sort((a, b) => new Date(b.exitDate || b.entryDate) - new Date(a.exitDate || a.entryDate))
                                                .map(trade => {
                                                    const grade = gradeJournalTrade(trade);
                                                    const setupInfo = SETUP_TYPES.find(s => s.id === trade.setup);
                                                    return (
                                                        <div
                                                            key={trade.id}
                                                            onClick={() => setSelectedJournalTrade(trade)}
                                                            className={`p-4 rounded-xl border cursor-pointer transition-colors hover:border-gray-500 ${
                                                                trade.pnl >= 0 ? 'bg-green-900/20 border-green-500/30' : 'bg-red-900/20 border-red-500/30'
                                                            }`}
                                                        >
                                                            <div className="flex justify-between items-start">
                                                                <div>
                                                                    <div className="flex items-center gap-2 flex-wrap">
                                                                        <span className="font-bold text-lg">{trade.ticker}</span>
                                                                        <span className={`text-xs px-2 py-0.5 rounded font-semibold ${
                                                                            trade.assetType === 'option' ? 'bg-purple-500/30 text-purple-300 border border-purple-500/50' :
                                                                            trade.assetType === 'crypto' ? 'bg-orange-500/30 text-orange-300 border border-orange-500/50' :
                                                                            trade.assetType === 'futures' ? 'bg-blue-500/30 text-blue-300 border border-blue-500/50' :
                                                                            'bg-gray-500/30 text-gray-300 border border-gray-500/50'
                                                                        }`}>
                                                                            {trade.assetType === 'option' ? 'OPTIONS' :
                                                                             trade.assetType === 'crypto' ? 'CRYPTO' :
                                                                             trade.assetType === 'futures' ? 'FUTURES' : 'STOCK'}
                                                                        </span>
                                                                        {trade.tradeStyle && (
                                                                            <span className={`text-xs px-2 py-0.5 rounded font-semibold ${
                                                                                trade.tradeStyle === 'scalp' ? 'bg-yellow-500/30 text-yellow-300 border border-yellow-500/50' :
                                                                                trade.tradeStyle === 'swing' ? 'bg-cyan-500/30 text-cyan-300 border border-cyan-500/50' :
                                                                                'bg-indigo-500/30 text-indigo-300 border border-indigo-500/50'
                                                                            }`}>
                                                                                {trade.tradeStyle === 'scalp' ? '‚ö° SCALP' :
                                                                                 trade.tradeStyle === 'swing' ? 'üåä SWING' : '‚òÄÔ∏è DAY'}
                                                                            </span>
                                                                        )}
                                                                        <span className={`text-xs px-2 py-0.5 rounded ${trade.side === 'long' ? 'bg-green-500/30 text-green-300' : 'bg-red-500/30 text-red-300'}`}>
                                                                            {trade.side?.toUpperCase()}
                                                                        </span>
                                                                    </div>
                                                                    <div className="flex items-center gap-2 mt-1">
                                                                        {setupInfo && (
                                                                            <span className="text-xs text-gray-400">{setupInfo.emoji} {setupInfo.label}</span>
                                                                        )}
                                                                    </div>
                                                                    <div className="text-xs text-gray-500 mt-1">
                                                                        {new Date(trade.entryDate).toLocaleDateString()} ‚Ä¢
                                                                        ${trade.entryPrice?.toFixed(2)} ‚Üí ${trade.exitPrice?.toFixed(2)}
                                                                        {trade.assetType === 'option' && trade.quantity && ` ‚Ä¢ ${trade.quantity} contract${trade.quantity > 1 ? 's' : ''}`}
                                                                    </div>
                                                                </div>
                                                                <div className="text-right">
                                                                    <div className={`font-bold text-lg ${trade.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                                        {trade.pnl >= 0 ? '+' : ''}${trade.pnl?.toFixed(2)}
                                                                    </div>
                                                                    <div className={`text-sm font-bold ${grade.color}`}>
                                                                        {grade.grade}
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            {trade.notes && (
                                                                <div className="mt-2 text-xs text-gray-400 line-clamp-1">
                                                                    üìù {trade.notes}
                                                                </div>
                                                            )}
                                                        </div>
                                                    );
                                                })
                                        )}
                                    </div>
                                )}

                                {/* Calendar View */}
                                {journalView === 'calendar' && (
                                    <CalendarView
                                        entries={journalEntries}
                                        onDayClick={(date, trades) => {
                                            if (trades.length === 1) {
                                                setSelectedJournalTrade(trades[0]);
                                            }
                                        }}
                                        dayOfWeekStats={journalStats.dayOfWeekStats}
                                    />
                                )}
                            </>
                        )}

                        {/* Disclaimer */}
                        <div className="mt-8 p-4 bg-gray-800/50 border border-gray-700 rounded-xl text-xs text-gray-500 text-center">
                            ‚öñÔ∏è Educational tool only. Not financial advice. All trading decisions are yours. You can lose money trading.
                        </div>
                    </main>

                    {/* Talk Me Down / Pump Me Up Button - Fixed at bottom */}
                    <div className="fixed bottom-0 left-0 right-0 p-4 bg-gradient-to-t from-gray-900 via-gray-900 to-transparent">
                        <div className="max-w-lg mx-auto">
                            <button
                                onClick={() => setShowTalkMeDown(true)}
                                className={`w-full py-4 rounded-2xl font-bold text-lg transition-all ${
                                    settings.tradingMode === 'aggressive'
                                        ? 'bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 shadow-lg shadow-green-500/30'
                                        : 'talk-me-down-btn'
                                }`}
                            >
                                {settings.tradingMode === 'aggressive' ? 'üöÄ PUMP ME UP' : 'üß† THE VOICE OF LOGIC'}
                            </button>
                        </div>
                    </div>

                    {/* Modals */}
                    <TalkMeDownModal
                        isOpen={showTalkMeDown}
                        onClose={() => setShowTalkMeDown(false)}
                        positions={positions}
                        personality={settings.personality}
                        tradingMode={settings.tradingMode}
                    />
                    <AddPositionModal
                        isOpen={showAddPosition}
                        onClose={() => setShowAddPosition(false)}
                        onAdd={handleAddPosition}
                        journalEntries={journalEntries}
                        journalStats={journalStats}
                        settings={settings}
                        lastLossTime={lastLossTime}
                        lockout={lockout}
                        positions={positions}
                    />
                    <SettingsModal
                        isOpen={showSettings}
                        onClose={() => setShowSettings(false)}
                        settings={settings}
                        onSave={setSettings}
                        userName={userName}
                        onUserNameChange={(name) => {
                            setUserName(name);
                            localStorage.setItem('userName', name);
                        }}
                        supportedBrokerages={supportedBrokerages}
                        connectedBrokerages={connectedBrokerages}
                        brokerageLoading={brokerageLoading}
                        brokerageSyncTime={brokerageSyncTime}
                        brokerageError={brokerageError}
                        onConnectBrokerage={connectBrokerage}
                        onSyncBrokerages={() => { fetchBrokeragePositions(); fetchBrokerageTrades(); }}
                        autoImportTrades={autoImportTrades}
                        onToggleAutoImport={(value) => {
                            setAutoImportTrades(value);
                            localStorage.setItem('autoImportTrades', value.toString());
                        }}
                    />

                    {/* Welcome Screen for New Users */}
                    {showWelcome && (
                        <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-[100] p-4">
                            <div className="bg-gray-900 rounded-2xl w-full max-w-md overflow-hidden border border-gray-700">
                                <div className="p-6 text-center">
                                    <div className="text-5xl mb-4">‚õÖ</div>
                                    <h1 className="text-2xl font-bold mb-2">Welcome to Zenith</h1>
                                    <p className="text-gray-400 mb-4">Your personal trading companion</p>

                                    {/* Name Input */}
                                    <div className="mt-4 mb-2">
                                        <label className="text-sm text-gray-400 block mb-2">What should we call you?</label>
                                        <input
                                            type="text"
                                            value={welcomeNameInput}
                                            onChange={(e) => setWelcomeNameInput(e.target.value)}
                                            placeholder="Enter your name or nickname"
                                            className="w-full px-4 py-3 bg-gray-800 border border-gray-600 rounded-xl text-center focus:border-blue-500 focus:outline-none"
                                            autoFocus
                                        />
                                    </div>
                                </div>

                                <div className="px-6 pb-6 space-y-4">
                                    <div className="bg-gray-800/50 p-4 rounded-xl border border-gray-700">
                                        <div className="flex items-start gap-3">
                                            <span className="text-2xl">üîó</span>
                                            <div>
                                                <div className="font-semibold mb-1">Connect Your Brokerages</div>
                                                <p className="text-sm text-gray-400">
                                                    For the best experience, link your trading accounts in Settings.
                                                    This enables automatic trade syncing, unified portfolio view, and smarter AI coaching.
                                                </p>
                                            </div>
                                        </div>
                                    </div>

                                    <div className="bg-gray-800/50 p-4 rounded-xl border border-gray-700">
                                        <div className="flex items-start gap-3">
                                            <span className="text-2xl">üìì</span>
                                            <div>
                                                <div className="font-semibold mb-1">Log Your Trades</div>
                                                <p className="text-sm text-gray-400">
                                                    Track wins, losses, and emotions to discover patterns.
                                                    Your AI Coach will analyze your data and give personalized insights.
                                                </p>
                                            </div>
                                        </div>
                                    </div>

                                    <div className="bg-gray-800/50 p-4 rounded-xl border border-gray-700">
                                        <div className="flex items-start gap-3">
                                            <span className="text-2xl">‚ö†Ô∏è</span>
                                            <div>
                                                <p className="text-sm text-gray-400">
                                                    This app is a trading tool, not financial advice.
                                                    Always do your own research and trade responsibly.
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div className="p-4 bg-gray-800/30 border-t border-gray-700 flex gap-3">
                                    <button
                                        onClick={() => {
                                            const name = welcomeNameInput.trim() || 'Trader';
                                            localStorage.setItem('userName', name);
                                            setUserName(name);
                                            localStorage.setItem('welcomeSeen', 'true');
                                            setShowWelcome(false);
                                            setShowSettings(true);
                                        }}
                                        className="flex-1 py-3 bg-blue-600 hover:bg-blue-500 rounded-xl font-semibold transition-colors"
                                    >
                                        Open Settings
                                    </button>
                                    <button
                                        onClick={() => {
                                            const name = welcomeNameInput.trim() || 'Trader';
                                            localStorage.setItem('userName', name);
                                            setUserName(name);
                                            localStorage.setItem('welcomeSeen', 'true');
                                            setShowWelcome(false);
                                        }}
                                        className="flex-1 py-3 bg-gray-700 hover:bg-gray-600 rounded-xl font-semibold transition-colors"
                                    >
                                        Get Started
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    <AlertPanel
                        isOpen={showAlerts}
                        onClose={() => {
                            setShowAlerts(false);
                            const now = Date.now();
                            setAlertsDismissedAt(now);
                            localStorage.setItem('alertsDismissedAt', now.toString()); // Persist - don't show again for 24 hours
                        }}
                        alerts={alerts}
                        lastCheck={lastAlertCheck}
                    />
                    <PositionDetailModal
                        position={selectedPositionDetail ? positions.find(p => p.id === selectedPositionDetail.id) || selectedPositionDetail : null}
                        onClose={() => setSelectedPositionDetail(null)}
                        onDelete={(id) => {
                            setPositions(positions.filter(p => p.id !== id));
                        }}
                        onUpdate={(updatedPosition) => {
                            // Update position with new entries/exits
                            setPositions(positions.map(p =>
                                p.id === updatedPosition.id ? updatedPosition : p
                            ));
                            // Also update the selected detail view
                            setSelectedPositionDetail(updatedPosition);
                        }}
                        onLogToJournal={(journalEntry) => {
                            // Add to journal entries and save
                            const updated = [...journalEntries, journalEntry];
                            setJournalEntries(updated);
                            saveJournalEntries(updated);
                        }}
                    />

                    {/* Custom Alert Manager */}
                    <AlertManager
                        isOpen={showAlertManager}
                        onClose={() => setShowAlertManager(false)}
                        customAlerts={customAlerts}
                        setCustomAlerts={setCustomAlerts}
                        alertHistory={alertHistory}
                        setAlertHistory={setAlertHistory}
                        newsWatchlist={newsWatchlist}
                        setNewsWatchlist={setNewsWatchlist}
                        pushEnabled={pushEnabled}
                        setPushEnabled={setPushEnabled}
                        fcmToken={fcmToken}
                        setFcmToken={setFcmToken}
                        fcmError={fcmError}
                        setFcmError={setFcmError}
                    />

                    {/* Real-time Alert Notifications */}
                    <AlertNotification
                        alerts={triggeredAlerts}
                        onDismiss={dismissTriggeredAlert}
                        onDismissAll={dismissAllTriggeredAlerts}
                    />

                    {/* AI Trading Coach Modal */}
                    {showCoach && (
                        <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
                            <div className="bg-gray-900 rounded-2xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
                                <div className="p-4 border-b border-gray-700 flex justify-between items-center sticky top-0 bg-gray-900 z-10">
                                    <div>
                                        <h2 className="text-xl font-bold">AI Trading Coach</h2>
                                        <p className="text-xs text-gray-500">Personalized insights from your trading data</p>
                                    </div>
                                    <button onClick={() => { setShowCoach(false); setCoachResponse(null); setCoachQuestion(''); }} className="text-gray-400 hover:text-white text-2xl">‚úï</button>
                                </div>

                                <div className="p-4 space-y-4">
                                    {journalEntries.length < 5 ? (
                                        <div className="text-center py-8">
                                            <div className="text-4xl mb-4">üìä</div>
                                            <div className="text-gray-400 mb-2">Not enough data yet</div>
                                            <p className="text-sm text-gray-500">
                                                Log at least 5 trades to unlock AI coaching insights.
                                                <br />You have {journalEntries.length} trade{journalEntries.length !== 1 ? 's' : ''} logged.
                                            </p>
                                        </div>
                                    ) : (
                                        <>
                                            {/* Pick a Position to Coach */}
                                            <div className="mb-4">
                                                <h3 className="font-semibold text-sm text-gray-400 uppercase tracking-wider mb-3">Analyze a Trade</h3>
                                                <div className="max-h-72 overflow-y-auto space-y-2 bg-gray-800/50 rounded-xl p-3">
                                                    {[...journalEntries].sort((a, b) => new Date(b.entryDate) - new Date(a.entryDate)).slice(0, 10).map((trade) => {
                                                        const grade = gradeJournalTrade(trade);
                                                        return (
                                                            <button
                                                                key={trade.id}
                                                                onClick={() => { setSelectedJournalTrade(trade); setShowCoach(false); }}
                                                                className="w-full p-3 bg-gray-700/50 hover:bg-gray-600/50 rounded-lg text-left flex items-center justify-between transition-colors"
                                                            >
                                                                <div className="flex items-center gap-3">
                                                                    <span className="font-bold">{trade.ticker}</span>
                                                                    <span className={`text-sm ${trade.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                                        {trade.pnl >= 0 ? '+' : ''}${trade.pnl?.toFixed(2)}
                                                                    </span>
                                                                    <span className="text-xs font-medium text-gray-400">{new Date(trade.entryDate).toLocaleDateString()}</span>
                                                                </div>
                                                                <span className={`text-sm font-bold ${grade.color}`}>{grade.grade}</span>
                                                            </button>
                                                        );
                                                    })}
                                                </div>
                                                <p className="text-xs text-gray-500 mt-2 text-center">Click a trade for deep AI analysis</p>
                                            </div>


                                        </>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Scalper Mode Dashboard */}
                    {showScalperMode && (
                        <ScalperDashboard
                            positions={positions}
                            tradeStats={tradeStats}
                            setTradeStats={setTradeStats}
                            dailyGoal={dailyGoal}
                            setDailyGoal={setDailyGoal}
                            onClose={() => setShowScalperMode(false)}
                        />
                    )}

                    {/* Add Trade Modal */}
                    {showAddTrade && (
                        <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
                            <div className="bg-gray-900 rounded-2xl w-full max-w-lg max-h-[90vh] overflow-y-auto">
                                <div className="p-4 border-b border-gray-700 flex justify-between items-center sticky top-0 bg-gray-900 z-10">
                                    <h2 className="text-xl font-bold">üìì Log Trade</h2>
                                    <button onClick={() => setShowAddTrade(false)} className="text-gray-400 hover:text-white text-2xl">‚úï</button>
                                </div>
                                <form
                                    className="p-4 space-y-4"
                                    onSubmit={(e) => {
                                        e.preventDefault();
                                        const form = e.target;
                                        const entryPrice = parseFloat(form.entryPrice.value);
                                        const exitPrice = parseFloat(form.exitPrice.value);
                                        const quantity = parseFloat(form.quantity.value) || 1;
                                        const side = form.side.value;
                                        const pnl = side === 'long'
                                            ? (exitPrice - entryPrice) * quantity
                                            : (entryPrice - exitPrice) * quantity;

                                        const newTrade = {
                                            id: Date.now(),
                                            ticker: form.ticker.value.toUpperCase(),
                                            side,
                                            assetType: form.assetType.value,
                                            tradeStyle: form.tradeStyle.value,
                                            entryPrice,
                                            exitPrice,
                                            quantity,
                                            entryDate: form.entryDate.value,
                                            exitDate: form.exitDate.value,
                                            pnl,
                                            fees: parseFloat(form.fees.value) || 0,
                                            setup: form.setup.value,
                                            mistakes: Array.from(form.querySelectorAll('input[name="mistakes"]:checked')).map(el => el.value),
                                            emotionBefore: form.emotionBefore.value,
                                            emotionAfter: form.emotionAfter.value,
                                            followedPlan: form.followedPlan.checked,
                                            riskAmount: parseFloat(form.riskAmount.value) || null,
                                            notes: form.notes.value,
                                            screenshot: document.getElementById('screenshot-preview').src?.startsWith('data:')
                                                ? document.getElementById('screenshot-preview').src
                                                : null
                                        };

                                        const updated = [...journalEntries, newTrade];
                                        setJournalEntries(updated);
                                        saveJournalEntries(updated);
                                        setShowAddTrade(false);
                                    }}
                                >
                                    {/* Basic Info */}
                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-1">Ticker *</label>
                                            <input name="ticker" type="text" required placeholder="AAPL" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700 focus:border-blue-500 outline-none" />
                                        </div>
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-1">Side *</label>
                                            <select name="side" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700">
                                                <option value="long">Long</option>
                                                <option value="short">Short</option>
                                            </select>
                                        </div>
                                    </div>

                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-1">Asset Type</label>
                                            <select name="assetType" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700">
                                                <option value="stock">Stock</option>
                                                <option value="option">Option</option>
                                                <option value="crypto">Crypto</option>
                                                <option value="futures">Futures</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-1">Trade Style</label>
                                            <select name="tradeStyle" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700">
                                                {TRADE_STYLES.map(style => (
                                                    <option key={style.id} value={style.id}>{style.emoji} {style.label}</option>
                                                ))}
                                            </select>
                                        </div>
                                    </div>

                                    {/* Prices */}
                                    <div className="grid grid-cols-3 gap-3">
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-1">Entry $ *</label>
                                            <input name="entryPrice" type="number" step="0.01" required placeholder="100.00" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700 focus:border-blue-500 outline-none" />
                                        </div>
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-1">Exit $ *</label>
                                            <input name="exitPrice" type="number" step="0.01" required placeholder="105.00" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700 focus:border-blue-500 outline-none" />
                                        </div>
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-1">Qty</label>
                                            <input name="quantity" type="number" step="1" defaultValue="1" placeholder="100" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700 focus:border-blue-500 outline-none" />
                                        </div>
                                    </div>

                                    {/* Dates */}
                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-1">Entry Date</label>
                                            <input name="entryDate" type="datetime-local" defaultValue={new Date().toISOString().slice(0, 16)} className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700 focus:border-blue-500 outline-none" />
                                        </div>
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-1">Exit Date</label>
                                            <input name="exitDate" type="datetime-local" defaultValue={new Date().toISOString().slice(0, 16)} className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700 focus:border-blue-500 outline-none" />
                                        </div>
                                    </div>

                                    {/* Risk & Fees */}
                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-1">Risk Amount ($)</label>
                                            <input name="riskAmount" type="number" step="0.01" placeholder="50.00" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700 focus:border-blue-500 outline-none" />
                                        </div>
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-1">Fees ($)</label>
                                            <input name="fees" type="number" step="0.01" placeholder="0.00" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700 focus:border-blue-500 outline-none" />
                                        </div>
                                    </div>

                                    {/* Setup Type */}
                                    <div>
                                        <label className="text-xs text-gray-500 block mb-2">Setup Type</label>
                                        <select name="setup" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700">
                                            {SETUP_TYPES.map(s => (
                                                <option key={s.id} value={s.id}>{s.emoji} {s.label}</option>
                                            ))}
                                        </select>
                                    </div>

                                    {/* Emotions */}
                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-2">Emotion Before</label>
                                            <select name="emotionBefore" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700">
                                                {EMOTIONS.map(e => (
                                                    <option key={e.id} value={e.id}>{e.emoji} {e.label}</option>
                                                ))}
                                            </select>
                                        </div>
                                        <div>
                                            <label className="text-xs text-gray-500 block mb-2">Emotion After</label>
                                            <select name="emotionAfter" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700">
                                                {EMOTIONS.map(e => (
                                                    <option key={e.id} value={e.id}>{e.emoji} {e.label}</option>
                                                ))}
                                            </select>
                                        </div>
                                    </div>

                                    {/* Mistakes */}
                                    <div>
                                        <label className="text-xs text-gray-500 block mb-2">Mistakes Made</label>
                                        <div className="grid grid-cols-2 gap-2">
                                            {MISTAKE_TYPES.map(m => (
                                                <label key={m.id} className="flex items-center gap-2 text-sm p-2 bg-gray-800/50 rounded-lg cursor-pointer hover:bg-gray-700/50">
                                                    <input type="checkbox" name="mistakes" value={m.id} className="rounded" />
                                                    <span>{m.emoji} {m.label}</span>
                                                </label>
                                            ))}
                                        </div>
                                    </div>

                                    {/* Followed Plan */}
                                    <label className="flex items-center gap-3 p-3 bg-gray-800/50 rounded-xl cursor-pointer">
                                        <input type="checkbox" name="followedPlan" defaultChecked className="w-5 h-5 rounded" />
                                        <span>I followed my trading plan</span>
                                    </label>

                                    {/* Notes */}
                                    <div>
                                        <label className="text-xs text-gray-500 block mb-1">Notes & Lessons</label>
                                        <textarea name="notes" rows="3" placeholder="What did you learn? Why did you take this trade?" className="w-full p-3 bg-gray-800 rounded-xl border border-gray-700 focus:border-blue-500 outline-none resize-none" />
                                    </div>

                                    {/* Screenshot Upload */}
                                    <div>
                                        <label className="text-xs text-gray-500 block mb-1">Chart Screenshot</label>
                                        <div className="relative">
                                            <input
                                                type="file"
                                                name="screenshot"
                                                accept="image/*"
                                                className="hidden"
                                                id="screenshot-upload"
                                                onChange={(e) => {
                                                    const file = e.target.files[0];
                                                    const preview = document.getElementById('screenshot-preview');
                                                    const previewContainer = document.getElementById('screenshot-preview-container');
                                                    if (file) {
                                                        const reader = new FileReader();
                                                        reader.onload = (event) => {
                                                            preview.src = event.target.result;
                                                            previewContainer.classList.remove('hidden');
                                                        };
                                                        reader.readAsDataURL(file);
                                                    } else {
                                                        previewContainer.classList.add('hidden');
                                                    }
                                                }}
                                            />
                                            <label
                                                htmlFor="screenshot-upload"
                                                className="flex items-center justify-center gap-2 p-4 bg-gray-800 rounded-xl border border-gray-700 border-dashed cursor-pointer hover:border-gray-500 transition-colors"
                                            >
                                                <span className="text-2xl">üì∑</span>
                                                <span className="text-sm text-gray-400">Tap to add chart screenshot</span>
                                            </label>
                                            <div id="screenshot-preview-container" className="hidden mt-2">
                                                <div className="relative">
                                                    <img id="screenshot-preview" className="w-full rounded-xl" alt="Preview" />
                                                    <button
                                                        type="button"
                                                        onClick={() => {
                                                            document.getElementById('screenshot-upload').value = '';
                                                            document.getElementById('screenshot-preview-container').classList.add('hidden');
                                                        }}
                                                        className="absolute top-2 right-2 bg-red-600 hover:bg-red-500 rounded-full w-8 h-8 flex items-center justify-center text-sm"
                                                    >
                                                        ‚úï
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Submit */}
                                    <button type="submit" className="w-full py-4 bg-green-600 hover:bg-green-500 rounded-xl font-bold text-lg transition-colors">
                                        Log Trade
                                    </button>
                                </form>
                            </div>
                        </div>
                    )}

                    {/* Trade Detail Modal */}
                    {selectedJournalTrade && (
                        <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
                            <div className="bg-gray-900 rounded-2xl w-full max-w-lg max-h-[90vh] overflow-y-auto">
                                <div className="p-4 border-b border-gray-700 flex justify-between items-center sticky top-0 bg-gray-900">
                                    <div>
                                        <div className="flex items-center gap-2">
                                            <h2 className="text-xl font-bold">{selectedJournalTrade.ticker}</h2>
                                            <span className={`text-xs px-2 py-0.5 rounded font-semibold ${
                                                selectedJournalTrade.assetType === 'option' ? 'bg-purple-500/30 text-purple-300 border border-purple-500/50' :
                                                selectedJournalTrade.assetType === 'crypto' ? 'bg-orange-500/30 text-orange-300 border border-orange-500/50' :
                                                selectedJournalTrade.assetType === 'futures' ? 'bg-blue-500/30 text-blue-300 border border-blue-500/50' :
                                                'bg-gray-500/30 text-gray-300 border border-gray-500/50'
                                            }`}>
                                                {selectedJournalTrade.assetType === 'option' ? 'OPTIONS' :
                                                 selectedJournalTrade.assetType === 'crypto' ? 'CRYPTO' :
                                                 selectedJournalTrade.assetType === 'futures' ? 'FUTURES' : 'STOCK'}
                                            </span>
                                            {selectedJournalTrade.tradeStyle && (
                                                <span className={`text-xs px-2 py-0.5 rounded font-semibold ${
                                                    selectedJournalTrade.tradeStyle === 'scalp' ? 'bg-yellow-500/30 text-yellow-300 border border-yellow-500/50' :
                                                    selectedJournalTrade.tradeStyle === 'swing' ? 'bg-cyan-500/30 text-cyan-300 border border-cyan-500/50' :
                                                    'bg-indigo-500/30 text-indigo-300 border border-indigo-500/50'
                                                }`}>
                                                    {selectedJournalTrade.tradeStyle === 'scalp' ? '‚ö° SCALP' :
                                                     selectedJournalTrade.tradeStyle === 'swing' ? 'üåä SWING' : '‚òÄÔ∏è DAY'}
                                                </span>
                                            )}
                                            <span className={`text-xs px-2 py-0.5 rounded ${selectedJournalTrade.side === 'long' ? 'bg-green-500/30 text-green-300' : 'bg-red-500/30 text-red-300'}`}>
                                                {selectedJournalTrade.side?.toUpperCase()}
                                            </span>
                                        </div>
                                        <div className="text-xs text-gray-500 mt-1">Trade Review</div>
                                    </div>
                                    <button onClick={() => { setSelectedJournalTrade(null); setShowTradeAnalysis(false); setEditingNotes(false); }} className="text-gray-400 hover:text-white text-2xl">‚úï</button>
                                </div>
                                <div className="p-4 space-y-4">
                                    {/* P&L Header */}
                                    <div className={`text-center p-6 rounded-xl ${selectedJournalTrade.pnl >= 0 ? 'bg-green-900/30' : 'bg-red-900/30'}`}>
                                        <div className={`text-4xl font-bold ${selectedJournalTrade.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                            {selectedJournalTrade.pnl >= 0 ? '+' : ''}${selectedJournalTrade.pnl?.toFixed(2)}
                                        </div>
                                        <div className="text-sm text-gray-400 mt-1">
                                            {selectedJournalTrade.side?.toUpperCase()} ‚Ä¢ ${selectedJournalTrade.entryPrice?.toFixed(2)} ‚Üí ${selectedJournalTrade.exitPrice?.toFixed(2)}
                                            {selectedJournalTrade.assetType === 'option' && selectedJournalTrade.quantity && ` ‚Ä¢ ${selectedJournalTrade.quantity} contract${selectedJournalTrade.quantity > 1 ? 's' : ''}`}
                                        </div>
                                        <div className={`text-2xl font-bold mt-2 ${gradeJournalTrade(selectedJournalTrade).color}`}>
                                            Grade: {gradeJournalTrade(selectedJournalTrade).grade}
                                        </div>
                                    </div>

                                    {/* Voice of Logic Review */}
                                    <div className="p-4 bg-blue-900/20 border border-blue-500/30 rounded-xl">
                                        <div className="text-sm font-semibold mb-2">üß† Voice of Logic Says:</div>
                                        <p className="text-sm text-gray-300">{getTradeReview(selectedJournalTrade, settings.personality)}</p>
                                    </div>

                                    {/* Trade Replay Chart */}
                                    <TradeReplayChart trade={selectedJournalTrade} />

                                    {/* Trade Details */}
                                    <div className="grid grid-cols-2 gap-3 text-sm">
                                        <div className="bg-gray-800/50 p-3 rounded-xl">
                                            <div className="text-gray-500">Setup</div>
                                            <div>{SETUP_TYPES.find(s => s.id === selectedJournalTrade.setup)?.emoji} {SETUP_TYPES.find(s => s.id === selectedJournalTrade.setup)?.label}</div>
                                        </div>
                                        <div className="bg-gray-800/50 p-3 rounded-xl">
                                            <div className="text-gray-500">R-Multiple</div>
                                            <div className={selectedJournalTrade.riskAmount ? (selectedJournalTrade.pnl / selectedJournalTrade.riskAmount >= 0 ? 'text-green-400' : 'text-red-400') : ''}>
                                                {selectedJournalTrade.riskAmount ? `${(selectedJournalTrade.pnl / selectedJournalTrade.riskAmount).toFixed(2)}R` : 'N/A'}
                                            </div>
                                        </div>
                                        <div className="bg-gray-800/50 p-3 rounded-xl">
                                            <div className="text-gray-500">Duration</div>
                                            <div className="text-blue-400">
                                                {(() => {
                                                    if (!selectedJournalTrade.entryDate || !selectedJournalTrade.exitDate) return 'N/A';
                                                    const entry = new Date(selectedJournalTrade.entryDate);
                                                    const exit = new Date(selectedJournalTrade.exitDate);
                                                    const diffMs = exit - entry;
                                                    if (diffMs < 0) return 'N/A';
                                                    const diffMins = Math.floor(diffMs / 60000);
                                                    const diffHours = Math.floor(diffMins / 60);
                                                    const diffDays = Math.floor(diffHours / 24);
                                                    if (diffDays > 0) {
                                                        return `${diffDays}d ${diffHours % 24}h`;
                                                    } else if (diffHours > 0) {
                                                        return `${diffHours}h ${diffMins % 60}m`;
                                                    } else {
                                                        return `${diffMins}m`;
                                                    }
                                                })()}
                                            </div>
                                        </div>
                                        <div className="bg-gray-800/50 p-3 rounded-xl">
                                            <div className="text-gray-500">Followed Plan</div>
                                            <div>{selectedJournalTrade.followedPlan ? '‚úÖ Yes' : '‚ùå No'}</div>
                                        </div>
                                        <div className="bg-gray-800/50 p-3 rounded-xl">
                                            <div className="text-gray-500">Emotion Before</div>
                                            <div>{EMOTIONS.find(e => e.id === selectedJournalTrade.emotionBefore)?.emoji} {EMOTIONS.find(e => e.id === selectedJournalTrade.emotionBefore)?.label}</div>
                                        </div>
                                        <div className="bg-gray-800/50 p-3 rounded-xl">
                                            <div className="text-gray-500">Entry Time</div>
                                            <div className="text-xs">
                                                {selectedJournalTrade.entryDate ? new Date(selectedJournalTrade.entryDate).toLocaleString('en-US', {
                                                    month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true
                                                }) : 'N/A'}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Multiple Entries/Exits (if available) */}
                                    {(selectedJournalTrade.entries?.length > 0 || selectedJournalTrade.exits?.length > 0) && (
                                        <div className="p-3 bg-gray-800/50 rounded-xl">
                                            <div className="text-sm font-semibold mb-3">üìä Scaling History</div>

                                            {/* Entries */}
                                            {selectedJournalTrade.entries?.length > 0 && (
                                                <div className="mb-3">
                                                    <div className="text-xs text-gray-400 mb-2">Entries ({selectedJournalTrade.entries.length})</div>
                                                    <div className="space-y-2">
                                                        {selectedJournalTrade.entries.map((entry, idx) => (
                                                            <div key={idx} className="flex justify-between items-center bg-blue-500/10 border border-blue-500/30 rounded-lg px-3 py-2">
                                                                <div className="flex items-center gap-2">
                                                                    <span className={idx === 0 ? 'text-blue-400' : 'text-blue-300'}>
                                                                        {idx === 0 ? 'üéØ' : '‚ûï'}
                                                                    </span>
                                                                    <div>
                                                                        <div className="text-sm font-medium">
                                                                            ${entry.price.toFixed(2)} √ó {entry.quantity}
                                                                        </div>
                                                                        {entry.note && <div className="text-xs text-gray-400">{entry.note}</div>}
                                                                    </div>
                                                                </div>
                                                                <div className="text-xs text-gray-400">
                                                                    {new Date(entry.date).toLocaleString('en-US', {
                                                                        month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true
                                                                    })}
                                                                </div>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}

                                            {/* Exits */}
                                            {selectedJournalTrade.exits?.length > 0 && (
                                                <div>
                                                    <div className="text-xs text-gray-400 mb-2">Exits ({selectedJournalTrade.exits.length})</div>
                                                    <div className="space-y-2">
                                                        {selectedJournalTrade.exits.map((exit, idx) => {
                                                            const avgEntry = selectedJournalTrade.entryPrice || selectedJournalTrade.entries?.[0]?.price || 0;
                                                            const isProfit = selectedJournalTrade.side === 'long'
                                                                ? exit.price > avgEntry
                                                                : exit.price < avgEntry;
                                                            return (
                                                                <div key={idx} className={`flex justify-between items-center rounded-lg px-3 py-2 ${isProfit ? 'bg-green-500/10 border border-green-500/30' : 'bg-red-500/10 border border-red-500/30'}`}>
                                                                    <div className="flex items-center gap-2">
                                                                        <span className={isProfit ? 'text-green-400' : 'text-red-400'}>
                                                                            {idx === selectedJournalTrade.exits.length - 1 ? 'üèÅ' : '‚úÇÔ∏è'}
                                                                        </span>
                                                                        <div>
                                                                            <div className="text-sm font-medium">
                                                                                ${exit.price.toFixed(2)} √ó {exit.quantity}
                                                                            </div>
                                                                            {exit.note && <div className="text-xs text-gray-400">{exit.note}</div>}
                                                                        </div>
                                                                    </div>
                                                                    <div className="text-xs text-gray-400">
                                                                        {new Date(exit.date).toLocaleString('en-US', {
                                                                            month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true
                                                                        })}
                                                                    </div>
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    )}

                                    {/* Mistakes */}
                                    {selectedJournalTrade.mistakes?.length > 0 && !selectedJournalTrade.mistakes.includes('none') && (
                                        <div className="p-3 bg-red-900/20 border border-red-500/30 rounded-xl">
                                            <div className="text-sm font-semibold text-red-400 mb-2">Mistakes Made:</div>
                                            <div className="flex flex-wrap gap-2">
                                                {selectedJournalTrade.mistakes.map(m => {
                                                    const mistake = MISTAKE_TYPES.find(mt => mt.id === m);
                                                    return (
                                                        <span key={m} className="text-xs bg-red-500/20 px-2 py-1 rounded">
                                                            {mistake?.emoji} {mistake?.label}
                                                        </span>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    )}

                                    {/* Notes - Editable */}
                                    <div className="p-3 bg-gray-800/50 rounded-xl">
                                        <div className="flex justify-between items-center mb-2">
                                            <div className="text-sm font-semibold">üìù Notes</div>
                                            {!editingNotes ? (
                                                <button
                                                    onClick={() => {
                                                        setEditedNotes(selectedJournalTrade.notes || '');
                                                        setEditingNotes(true);
                                                    }}
                                                    className="text-xs text-blue-400 hover:text-blue-300"
                                                >
                                                    Edit
                                                </button>
                                            ) : (
                                                <div className="flex gap-2">
                                                    <button
                                                        onClick={() => {
                                                            // Save the edited notes
                                                            const updated = journalEntries.map(t =>
                                                                t.id === selectedJournalTrade.id
                                                                    ? { ...t, notes: editedNotes }
                                                                    : t
                                                            );
                                                            setJournalEntries(updated);
                                                            saveJournalEntries(updated);
                                                            setSelectedJournalTrade({ ...selectedJournalTrade, notes: editedNotes });
                                                            setEditingNotes(false);
                                                        }}
                                                        className="text-xs text-green-400 hover:text-green-300"
                                                    >
                                                        Save
                                                    </button>
                                                    <button
                                                        onClick={() => setEditingNotes(false)}
                                                        className="text-xs text-gray-400 hover:text-gray-300"
                                                    >
                                                        Cancel
                                                    </button>
                                                </div>
                                            )}
                                        </div>
                                        {editingNotes ? (
                                            <textarea
                                                value={editedNotes}
                                                onChange={(e) => setEditedNotes(e.target.value)}
                                                className="w-full p-2 bg-gray-700 rounded-lg border border-gray-600 focus:border-blue-500 outline-none text-sm text-gray-200 resize-none"
                                                rows={4}
                                                placeholder="Add notes about this trade..."
                                                autoFocus
                                            />
                                        ) : (
                                            <p className="text-sm text-gray-300">
                                                {selectedJournalTrade.notes || <span className="text-gray-500 italic">No notes yet. Click Edit to add.</span>}
                                            </p>
                                        )}
                                    </div>

                                    {/* Screenshot */}
                                    {selectedJournalTrade.screenshot && (
                                        <div className="rounded-xl overflow-hidden">
                                            <div className="text-sm font-semibold mb-2">üì∑ Chart Screenshot</div>
                                            <img
                                                src={selectedJournalTrade.screenshot}
                                                alt="Trade chart"
                                                className="w-full rounded-xl cursor-pointer hover:opacity-90 transition-opacity"
                                                onClick={() => {
                                                    // Open full screen preview
                                                    const overlay = document.createElement('div');
                                                    overlay.className = 'fixed inset-0 bg-black/95 z-[100] flex items-center justify-center p-4';
                                                    overlay.onclick = () => overlay.remove();
                                                    const img = document.createElement('img');
                                                    img.src = selectedJournalTrade.screenshot;
                                                    img.className = 'max-w-full max-h-full object-contain';
                                                    overlay.appendChild(img);
                                                    document.body.appendChild(overlay);
                                                }}
                                            />
                                            <p className="text-xs text-gray-500 text-center mt-1">Tap to enlarge</p>
                                        </div>
                                    )}

                                    {/* AI Deep Analysis Button */}
                                    <button
                                        id="deep-analysis-btn"
                                        onClick={() => {
                                            const newState = !showTradeAnalysis;
                                            setShowTradeAnalysis(newState);
                                            if (newState) {
                                                setTimeout(() => {
                                                    const panel = document.getElementById('deep-analysis-panel');
                                                    const modal = panel?.closest('.overflow-y-auto');
                                                    if (panel && modal) {
                                                        // Scroll the modal container to show the panel
                                                        const panelTop = panel.offsetTop;
                                                        modal.scrollTo({ top: panelTop - 100, behavior: 'smooth' });
                                                    }
                                                }, 200);
                                            }
                                        }}
                                        className={`w-full py-3 rounded-xl text-sm font-semibold transition-colors ${
                                            showTradeAnalysis
                                                ? 'bg-purple-600 text-white'
                                                : 'bg-purple-600/20 hover:bg-purple-600/40 border border-purple-500/30 text-purple-300'
                                        }`}
                                    >
                                        {showTradeAnalysis ? '‚úï Close Analysis' : 'üîÆ Deep Analysis by AI Coach'}
                                    </button>

                                    {/* AI Deep Analysis Panel */}
                                    {showTradeAnalysis && (() => {
                                        try {
                                            const analysis = analyzeIndividualTrade(
                                                selectedJournalTrade,
                                                journalEntries,
                                                settings.coachPersonality || 'oracle'
                                            );
                                            return (
                                                <div id="deep-analysis-panel" className="space-y-4 p-4 bg-purple-900/30 border-2 border-purple-500/50 rounded-xl mt-3">
                                                    {/* Panel Header */}
                                                    <div className="flex items-center gap-2 pb-3 border-b border-purple-500/30">
                                                        <span className="text-2xl">üîÆ</span>
                                                        <div>
                                                            <div className="text-sm font-bold text-purple-300">AI Deep Analysis</div>
                                                            <div className="text-xs text-gray-500">Wisdom from legendary traders</div>
                                                        </div>
                                                    </div>

                                                    {/* Summary */}
                                                    <div className="text-sm text-gray-200 leading-relaxed">
                                                        {analysis.summary}
                                                    </div>

                                                {/* Positives */}
                                                {analysis.positives.length > 0 && (
                                                    <div>
                                                        <div className="text-xs text-green-400 font-semibold mb-2 uppercase tracking-wider">What You Did Right</div>
                                                        <div className="space-y-2">
                                                            {analysis.positives.map((item, idx) => (
                                                                <div key={idx} className="p-3 bg-green-900/20 border border-green-500/20 rounded-lg">
                                                                    <div className="text-sm font-semibold text-green-300">{item.title}</div>
                                                                    <div className="text-xs text-gray-400 mt-1">{item.detail}</div>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}

                                                {/* Insights */}
                                                {analysis.insights.length > 0 && (
                                                    <div>
                                                        <div className="text-xs text-yellow-400 font-semibold mb-2 uppercase tracking-wider">Things to Consider</div>
                                                        <div className="space-y-2">
                                                            {analysis.insights.map((item, idx) => (
                                                                <div key={idx} className="p-3 bg-yellow-900/20 border border-yellow-500/20 rounded-lg">
                                                                    <div className="text-sm font-semibold text-yellow-300">{item.title}</div>
                                                                    <div className="text-xs text-gray-400 mt-1">{item.detail}</div>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}

                                                {/* Improvements */}
                                                {analysis.improvements.length > 0 && (
                                                    <div>
                                                        <div className="text-xs text-red-400 font-semibold mb-2 uppercase tracking-wider">Areas for Improvement</div>
                                                        <div className="space-y-2">
                                                            {analysis.improvements.map((item, idx) => (
                                                                <div key={idx} className="p-3 bg-red-900/20 border border-red-500/20 rounded-lg">
                                                                    <div className="text-sm font-semibold text-red-300">{item.title}</div>
                                                                    <div className="text-xs text-gray-400 mt-1">{item.detail}</div>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}

                                                {/* Grade Breakdown */}
                                                <div className="pt-3 border-t border-gray-700">
                                                    <div className="flex justify-between items-center">
                                                        <span className="text-xs text-gray-500">Trade Grade</span>
                                                        <span className={`text-lg font-bold ${analysis.grade.color}`}>{analysis.grade.grade}</span>
                                                    </div>
                                                </div>
                                            </div>
                                            );
                                        } catch (error) {
                                            console.error('Deep Analysis Error:', error);
                                            return (
                                                <div id="deep-analysis-panel" className="p-4 bg-red-900/30 border-2 border-red-500/50 rounded-xl mt-3">
                                                    <div className="text-red-400 font-semibold mb-2">‚ö†Ô∏è Analysis Error</div>
                                                    <div className="text-sm text-gray-300 mb-2">Something went wrong analyzing this trade.</div>
                                                    <div className="text-xs text-gray-500 font-mono bg-gray-800 p-2 rounded">{error.message}</div>
                                                </div>
                                            );
                                        }
                                    })()}

                                    {/* Delete Button */}
                                    <button
                                        onClick={() => {
                                            if (confirm('Delete this trade from journal?')) {
                                                const updated = journalEntries.filter(t => t.id !== selectedJournalTrade.id);
                                                setJournalEntries(updated);
                                                saveJournalEntries(updated);
                                                setSelectedJournalTrade(null);
                                            }
                                        }}
                                        className="w-full py-3 bg-red-600/20 hover:bg-red-600/40 border border-red-500/30 rounded-xl text-red-400 text-sm"
                                    >
                                        üóëÔ∏è Delete Trade
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Emergency Brake Button (Guardian Mode only) */}
                    {settings.tradingMode === 'guardian' && !lockout.active && (
                        <button
                            onClick={() => {
                                if (confirm('Activate Emergency Brake? This will lock you out of trading for 1 hour.')) {
                                    activateEmergencyBrake(1);
                                }
                            }}
                            className="fixed bottom-24 right-4 w-14 h-14 bg-red-600 hover:bg-red-500 rounded-full shadow-lg shadow-red-600/50 flex items-center justify-center text-2xl z-40 animate-pulse transition-all hover:scale-110"
                            title="Emergency Brake - Lock yourself out for 1 hour"
                        >
                            üõë
                        </button>
                    )}

                    {/* Lockout Overlay */}
                    {lockout.active && (
                        <div className="fixed inset-0 bg-black/95 z-[100] flex items-center justify-center p-4">
                            <div className="bg-gray-900 border-2 border-red-500 rounded-2xl w-full max-w-md p-8 text-center">
                                <div className="text-6xl mb-4">
                                    {lockout.reason === 'emergency' ? 'üõë' : lockout.reason === 'daily_loss' ? 'üí∏' : '‚è≥'}
                                </div>
                                <h2 className="text-2xl font-bold text-red-400 mb-2">
                                    {lockout.reason === 'emergency' ? 'Emergency Brake Active' :
                                     lockout.reason === 'daily_loss' ? 'Daily Loss Limit Reached' :
                                     lockout.reason === 'cooldown' ? 'Cooling Down' : 'Trading Locked'}
                                </h2>
                                <p className="text-gray-400 mb-6">
                                    {lockout.reason === 'emergency' ? 'You activated the emergency brake. Take a break and come back with a clear head.' :
                                     lockout.reason === 'daily_loss' ? `You've hit your daily loss limit. Protect your capital - come back tomorrow.` :
                                     lockout.reason === 'cooldown' ? 'Take a moment after that loss. Breathe. The market will still be there.' :
                                     'Trading is temporarily locked.'}
                                </p>

                                {/* Countdown Timer */}
                                <div className="bg-gray-800 rounded-xl p-4 mb-6">
                                    <div className="text-sm text-gray-400 mb-1">Trading unlocks in:</div>
                                    <div className="text-3xl font-mono font-bold text-red-400">
                                        {(() => {
                                            const timeLeft = Math.max(0, (lockout.until || 0) - Date.now());
                                            const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                                            const mins = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                                            const secs = Math.floor((timeLeft % (1000 * 60)) / 1000);
                                            return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                                        })()}
                                    </div>
                                </div>

                                {/* Motivational Message */}
                                <div className="bg-blue-900/20 border border-blue-500/30 rounded-xl p-4 mb-6">
                                    <p className="text-blue-300 text-sm">
                                        {settings.personality === 'homie' ? '"Best traders know when to sit out. You got this fam. üí™"' :
                                         settings.personality === 'sergeant' ? '"A disciplined trader lives to fight another day. REST UP, SOLDIER."' :
                                         settings.personality === 'nerd' ? '"Statistically, trading when emotionally compromised leads to 73% more losses. Smart move taking a break."' :
                                         '"The market will always be there. Your capital won\'t if you don\'t protect it."'}
                                    </p>
                                </div>

                                {/* Actions */}
                                <div className="space-y-3">
                                    <button
                                        onClick={() => setActiveTab('journal')}
                                        className="w-full py-3 bg-gray-700 hover:bg-gray-600 rounded-xl font-medium transition-colors"
                                    >
                                        üìì Review Your Journal
                                    </button>
                                    {lockout.reason !== 'daily_loss' && (
                                        <button
                                            onClick={() => {
                                                if (confirm('Are you sure? The lockout is there to protect you.')) {
                                                    setLockout({ active: false, reason: '', until: null });
                                                    localStorage.removeItem('lockoutUntil');
                                                    localStorage.removeItem('emergencyBrakeUntil');
                                                }
                                            }}
                                            className="w-full py-3 bg-red-900/30 hover:bg-red-900/50 border border-red-500/30 rounded-xl text-red-400 text-sm transition-colors"
                                        >
                                            Override Lockout (Not Recommended)
                                        </button>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
